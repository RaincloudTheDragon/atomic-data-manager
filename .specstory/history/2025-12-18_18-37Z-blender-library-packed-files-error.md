<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 54ebe65b-6c18-4ef2-af41-51ed531aaa24 (2025-12-18 18:37Z) -->

# Blender library packed files error (2025-12-18 18:37Z)

_**User**_

have a look at issue 3 https://github.com/RaincloudTheDragon/atomic-data-manager/issues/3 
additional context: @.specstory/history/2025-12-01_20-46Z-setting-up-a-blender-extension-api.md @.specstory/history/2025-12-16_23-24Z-blender-library-packed-files-error.md 

---

_**Agent (model default, mode Agent)**_

Reviewing the issue and context files, then searching the codebase for Smart Select and Clean operations and their threading.


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\.specstory\history\2025-12-01_20-46Z-setting-up-a-blender-extension-api.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\.specstory\history\2025-12-16_23-24Z-blender-library-packed-files-error.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Smart Select and Clean operations multithreading",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {
            "line": 367,
            "column": 27
          },
          "endPosition": {
            "line": 420
          }
        },
        "contents": "# Atomic Data Manager Smart Select Operator\nclass ATOMIC_OT_smart_select(bpy.types.Operator):\n    \"\"\"Auto-select categories with unused data\"\"\"\n    bl_idname = \"atomic.smart_select\"\n    bl_label = \"Smart Select\"\n\n    def execute(self, context):\n\n        bpy.context.scene.atomic.collections = \\\n            any(unused.collections_deep())\n\n        bpy.context.scene.atomic.images = \\\n            any(unused.images_deep())\n\n        bpy.context.scene.atomic.lights = \\\n            any(unused.lights_deep())\n\n        bpy.context.scene.atomic.materials = \\\n            any(unused.materials_deep())\n\n        bpy.context.scene.atomic.node_groups = \\\n            any(unused.node_groups_deep())\n\n        bpy.context.scene.atomic.particles = \\\n            any(unused.particles_deep())\n\n        bpy.context.scene.atomic.textures = \\\n            any(unused.textures_deep())\n\n        bpy.context.scene.atomic.worlds = \\\n            any(unused.worlds())\n\n        return {'FINISHED'}\n\n\n# Atomic Data Manager Select All Operator\nclass ATOMIC_OT_select_all(bpy.types.Operator):\n    \"\"\"Select all categories\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Smart Select Operator",
            "lineNumber": 371
          },
          {
            "text": "class ATOMIC_OT_smart_select(bpy.types.Operator):",
            "lineNumber": 372,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Auto-select categories with unused data\"\"\"",
            "lineNumber": 373
          },
          {
            "text": "    bl_idname = \"atomic.smart_select\"",
            "lineNumber": 374
          },
          {
            "text": "    bl_label = \"Smart Select\"",
            "lineNumber": 375
          },
          {
            "lineNumber": 376
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 377
          },
          {
            "lineNumber": 378
          },
          {
            "text": "        bpy.context.scene.atomic.collections = \\",
            "lineNumber": 379
          },
          {
            "text": "            any(unused.collections_deep())",
            "lineNumber": 380
          },
          {
            "lineNumber": 381
          },
          {
            "text": "        bpy.context.scene.atomic.images = \\",
            "lineNumber": 382
          },
          {
            "text": "            any(unused.images_deep())",
            "lineNumber": 383
          },
          {
            "lineNumber": 384
          },
          {
            "text": "        bpy.context.scene.atomic.lights = \\",
            "lineNumber": 385
          },
          {
            "text": "            any(unused.lights_deep())",
            "lineNumber": 386
          },
          {
            "lineNumber": 387
          },
          {
            "text": "        bpy.context.scene.atomic.materials = \\",
            "lineNumber": 388
          },
          {
            "text": "            any(unused.materials_deep())",
            "lineNumber": 389
          },
          {
            "lineNumber": 390
          },
          {
            "text": "        bpy.context.scene.atomic.node_groups = \\",
            "lineNumber": 391
          },
          {
            "text": "            any(unused.node_groups_deep())",
            "lineNumber": 392
          },
          {
            "lineNumber": 393
          },
          {
            "text": "        bpy.context.scene.atomic.particles = \\",
            "lineNumber": 394
          },
          {
            "text": "            any(unused.particles_deep())",
            "lineNumber": 395
          },
          {
            "lineNumber": 396
          },
          {
            "text": "        bpy.context.scene.atomic.textures = \\",
            "lineNumber": 397
          },
          {
            "text": "            any(unused.textures_deep())",
            "lineNumber": 398
          },
          {
            "lineNumber": 399
          },
          {
            "text": "        bpy.context.scene.atomic.worlds = \\",
            "lineNumber": 400
          },
          {
            "text": "            any(unused.worlds())",
            "lineNumber": 401
          },
          {
            "lineNumber": 402
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 403,
            "isSignature": true
          },
          {
            "lineNumber": 404
          },
          {
            "lineNumber": 405
          },
          {
            "text": "# Atomic Data Manager Select All Operator",
            "lineNumber": 406
          },
          {
            "text": "class ATOMIC_OT_select_all(bpy.types.Operator):",
            "lineNumber": 407,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Select all categories\"\"\"",
            "lineNumber": 408
          }
        ]
      },
      "score": 0.2493375539779663
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {
            "line": 192
          },
          "endPosition": {
            "line": 367
          }
        },
        "contents": "class ATOMIC_OT_clean(bpy.types.Operator):\n\n\n    def execute(self, context):\n        atom = bpy.context.scene.atomic\n\n        if atom.collections:\n            clean.collections()\n\n        if atom.images:\n            clean.images()\n\n        if atom.lights:\n            clean.lights()\n\n        if atom.materials:\n            clean.materials()\n\n        if atom.node_groups:\n            clean.node_groups()\n\n        if atom.particles:\n            clean.particles()\n\n        if atom.textures:\n            clean.textures()\n\n        if atom.worlds:\n            clean.worlds()\n\n        bpy.ops.atomic.deselect_all()\n\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        atom = bpy.context.scene.atomic\n\n        if atom.collections:\n            self.unused_collections = unused.collections_deep()\n\n        if atom.images:\n            self.unused_images = unused.images_deep()\n\n        if atom.lights:\n            self.unused_lights = unused.lights_deep()\n\n        if atom.materials:\n            self.unused_materials = unused.materials_deep()\n\n        if atom.node_groups:\n            self.unused_node_groups = unused.node_groups_deep()\n\n        if atom.particles:\n            self.unused_particles = unused.particles_deep()\n\n        if atom.textures:\n            self.unused_textures = unused.textures_deep()\n\n        if atom.worlds:\n            self.unused_worlds = unused.worlds()\n\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Undo Operator\nclass ATOMIC_OT_undo(bpy.types.Operator):\n    \"\"\"Undo the previous action\"\"\"",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 193,
                "column": 1
              },
              "endPosition": {
                "line": 194,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_OT_clean(bpy.types.Operator):",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "lineNumber": 296
          },
          {
            "lineNumber": 297
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 298
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 299
          },
          {
            "lineNumber": 300
          },
          {
            "text": "        if atom.collections:",
            "lineNumber": 301
          },
          {
            "text": "            clean.collections()",
            "lineNumber": 302
          },
          {
            "lineNumber": 303
          },
          {
            "text": "        if atom.images:",
            "lineNumber": 304
          },
          {
            "text": "            clean.images()",
            "lineNumber": 305
          },
          {
            "lineNumber": 306
          },
          {
            "text": "        if atom.lights:",
            "lineNumber": 307
          },
          {
            "text": "            clean.lights()",
            "lineNumber": 308
          },
          {
            "lineNumber": 309
          },
          {
            "text": "        if atom.materials:",
            "lineNumber": 310
          },
          {
            "text": "            clean.materials()",
            "lineNumber": 311
          },
          {
            "lineNumber": 312
          },
          {
            "text": "        if atom.node_groups:",
            "lineNumber": 313
          },
          {
            "text": "            clean.node_groups()",
            "lineNumber": 314
          },
          {
            "lineNumber": 315
          },
          {
            "text": "        if atom.particles:",
            "lineNumber": 316
          },
          {
            "text": "            clean.particles()",
            "lineNumber": 317
          },
          {
            "lineNumber": 318
          },
          {
            "text": "        if atom.textures:",
            "lineNumber": 319
          },
          {
            "text": "            clean.textures()",
            "lineNumber": 320
          },
          {
            "lineNumber": 321
          },
          {
            "text": "        if atom.worlds:",
            "lineNumber": 322
          },
          {
            "text": "            clean.worlds()",
            "lineNumber": 323
          },
          {
            "lineNumber": 324
          },
          {
            "text": "        bpy.ops.atomic.deselect_all()",
            "lineNumber": 325
          },
          {
            "lineNumber": 326
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 327
          },
          {
            "lineNumber": 328
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 329
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 330
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 331
          },
          {
            "lineNumber": 332
          },
          {
            "text": "        if atom.collections:",
            "lineNumber": 333
          },
          {
            "text": "            self.unused_collections = unused.collections_deep()",
            "lineNumber": 334
          },
          {
            "lineNumber": 335
          },
          {
            "text": "        if atom.images:",
            "lineNumber": 336
          },
          {
            "text": "            self.unused_images = unused.images_deep()",
            "lineNumber": 337
          },
          {
            "lineNumber": 338
          },
          {
            "text": "        if atom.lights:",
            "lineNumber": 339
          },
          {
            "text": "            self.unused_lights = unused.lights_deep()",
            "lineNumber": 340
          },
          {
            "lineNumber": 341
          },
          {
            "text": "        if atom.materials:",
            "lineNumber": 342
          },
          {
            "text": "            self.unused_materials = unused.materials_deep()",
            "lineNumber": 343
          },
          {
            "lineNumber": 344
          },
          {
            "text": "        if atom.node_groups:",
            "lineNumber": 345
          },
          {
            "text": "            self.unused_node_groups = unused.node_groups_deep()",
            "lineNumber": 346
          },
          {
            "lineNumber": 347
          },
          {
            "text": "        if atom.particles:",
            "lineNumber": 348
          },
          {
            "text": "            self.unused_particles = unused.particles_deep()",
            "lineNumber": 349
          },
          {
            "lineNumber": 350
          },
          {
            "text": "        if atom.textures:",
            "lineNumber": 351
          },
          {
            "text": "            self.unused_textures = unused.textures_deep()",
            "lineNumber": 352
          },
          {
            "lineNumber": 353
          },
          {
            "text": "        if atom.worlds:",
            "lineNumber": 354
          },
          {
            "text": "            self.unused_worlds = unused.worlds()",
            "lineNumber": 355
          },
          {
            "lineNumber": 356
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 357,
            "isSignature": true
          },
          {
            "lineNumber": 358
          },
          {
            "lineNumber": 359
          },
          {
            "text": "# Atomic Data Manager Undo Operator",
            "lineNumber": 360
          },
          {
            "text": "class ATOMIC_OT_undo(bpy.types.Operator):",
            "lineNumber": 361,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Undo the previous action\"\"\"",
            "lineNumber": 362
          }
        ]
      },
      "score": 0.2091611623764038
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ui\\main_panel_ui.py",
        "range": {
          "startPosition": {
            "line": 36
          },
          "endPosition": {
            "line": 239
          }
        },
        "contents": "class ATOMIC_PT_main_panel(bpy.types.Panel):\ndef draw(self, context):\n\n        splitcol.prop(\n            atom,\n            \"worlds\",\n            text=\"Worlds\",\n            icon='WORLD',\n            toggle=True\n        )\n\n        splitcol.operator(\n            \"atomic.inspect_worlds\",\n            icon='VIEWZOOM',\n            text=\"\"\n        )\n\n        # selection operators\n        row = layout.row(align=True)\n\n        row.operator(\n            \"atomic.smart_select\",\n            text='Smart Select',\n            icon='ZOOM_SELECTED'\n        )\n\n        if all(prop is True for prop in category_props):\n            row.operator(\n                \"atomic.deselect_all\",\n                text=\"Deselect All\",\n                icon='RESTRICT_SELECT_ON'\n            )\n\n        else:\n            row.operator(\n                \"atomic.select_all\",\n                text=\"Select All\",\n                icon='RESTRICT_SELECT_OFF'\n            )\n\n\nreg_list = [ATOMIC_PT_main_panel]\n\n\ndef register():\n    for cls in reg_list:",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 37,
                "column": 1
              },
              "endPosition": {
                "line": 38,
                "column": 5
              }
            },
            {
              "startPosition": {
                "line": 44,
                "column": 5
              },
              "endPosition": {
                "line": 45,
                "column": 9
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_PT_main_panel(bpy.types.Panel):",
            "lineNumber": 37,
            "isSignature": true
          },
          {
            "text": "def draw(self, context):",
            "lineNumber": 44
          },
          {
            "lineNumber": 196
          },
          {
            "text": "        splitcol.prop(",
            "lineNumber": 197
          },
          {
            "text": "            atom,",
            "lineNumber": 198
          },
          {
            "text": "            \"worlds\",",
            "lineNumber": 199
          },
          {
            "text": "            text=\"Worlds\",",
            "lineNumber": 200
          },
          {
            "text": "            icon='WORLD',",
            "lineNumber": 201
          },
          {
            "text": "            toggle=True",
            "lineNumber": 202
          },
          {
            "text": "        )",
            "lineNumber": 203
          },
          {
            "lineNumber": 204
          },
          {
            "text": "        splitcol.operator(",
            "lineNumber": 205
          },
          {
            "text": "            \"atomic.inspect_worlds\",",
            "lineNumber": 206
          },
          {
            "text": "            icon='VIEWZOOM',",
            "lineNumber": 207
          },
          {
            "text": "            text=\"\"",
            "lineNumber": 208
          },
          {
            "text": "        )",
            "lineNumber": 209
          },
          {
            "lineNumber": 210
          },
          {
            "text": "        # selection operators",
            "lineNumber": 211
          },
          {
            "text": "        row = layout.row(align=True)",
            "lineNumber": 212
          },
          {
            "lineNumber": 213
          },
          {
            "text": "        row.operator(",
            "lineNumber": 214
          },
          {
            "text": "            \"atomic.smart_select\",",
            "lineNumber": 215
          },
          {
            "text": "            text='Smart Select',",
            "lineNumber": 216
          },
          {
            "text": "            icon='ZOOM_SELECTED'",
            "lineNumber": 217
          },
          {
            "text": "        )",
            "lineNumber": 218
          },
          {
            "lineNumber": 219
          },
          {
            "text": "        if all(prop is True for prop in category_props):",
            "lineNumber": 220
          },
          {
            "text": "            row.operator(",
            "lineNumber": 221
          },
          {
            "text": "                \"atomic.deselect_all\",",
            "lineNumber": 222
          },
          {
            "text": "                text=\"Deselect All\",",
            "lineNumber": 223
          },
          {
            "text": "                icon='RESTRICT_SELECT_ON'",
            "lineNumber": 224
          },
          {
            "text": "            )",
            "lineNumber": 225
          },
          {
            "lineNumber": 226
          },
          {
            "text": "        else:",
            "lineNumber": 227
          },
          {
            "text": "            row.operator(",
            "lineNumber": 228
          },
          {
            "text": "                \"atomic.select_all\",",
            "lineNumber": 229
          },
          {
            "text": "                text=\"Select All\",",
            "lineNumber": 230
          },
          {
            "text": "                icon='RESTRICT_SELECT_OFF'",
            "lineNumber": 231
          },
          {
            "text": "            )",
            "lineNumber": 232,
            "isSignature": true
          },
          {
            "lineNumber": 233
          },
          {
            "lineNumber": 234
          },
          {
            "text": "reg_list = [ATOMIC_PT_main_panel]",
            "lineNumber": 235
          },
          {
            "lineNumber": 236
          },
          {
            "lineNumber": 237
          },
          {
            "text": "def register():",
            "lineNumber": 238,
            "isSignature": true
          },
          {
            "text": "    for cls in reg_list:",
            "lineNumber": 239
          }
        ]
      },
      "score": 0.19221186637878418
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {
            "line": 439,
            "column": 27
          },
          "endPosition": {
            "line": 459,
            "column": 42
          }
        },
        "contents": "reg_list = [\n    ATOMIC_OT_nuke,\n    ATOMIC_OT_clean,\n    ATOMIC_OT_undo,\n    ATOMIC_OT_smart_select,\n    ATOMIC_OT_select_all,\n    ATOMIC_OT_deselect_all\n]\n\n\ndef register():\n    for item in reg_list:\n        register_class(item)\n\n\ndef unregister():\n    for item in reg_list:\n        compat.safe_unregister_class(item)",
        "signatures": {},
        "detailedLines": [
          {
            "text": "reg_list = [",
            "lineNumber": 443
          },
          {
            "text": "    ATOMIC_OT_nuke,",
            "lineNumber": 444
          },
          {
            "text": "    ATOMIC_OT_clean,",
            "lineNumber": 445
          },
          {
            "text": "    ATOMIC_OT_undo,",
            "lineNumber": 446
          },
          {
            "text": "    ATOMIC_OT_smart_select,",
            "lineNumber": 447
          },
          {
            "text": "    ATOMIC_OT_select_all,",
            "lineNumber": 448
          },
          {
            "text": "    ATOMIC_OT_deselect_all",
            "lineNumber": 449
          },
          {
            "text": "]",
            "lineNumber": 450
          },
          {
            "lineNumber": 451
          },
          {
            "lineNumber": 452
          },
          {
            "text": "def register():",
            "lineNumber": 453,
            "isSignature": true
          },
          {
            "text": "    for item in reg_list:",
            "lineNumber": 454
          },
          {
            "text": "        register_class(item)",
            "lineNumber": 455,
            "isSignature": true
          },
          {
            "lineNumber": 456
          },
          {
            "lineNumber": 457
          },
          {
            "text": "def unregister():",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "    for item in reg_list:",
            "lineNumber": 459
          },
          {
            "text": "        compat.safe_unregister_class(item)",
            "lineNumber": 460,
            "isSignature": true
          }
        ]
      },
      "score": 0.14725005626678467
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 149
          },
          "endPosition": {
            "line": 290
          }
        },
        "contents": "class ATOMIC_OT_clean_all(bpy.types.Operator):\ndef draw(self, context):\n\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Textures\",\n            items=textures,\n            icon=\"TEXTURE\"\n        )\n\n        worlds = sorted(unused.worlds())\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Worlds\",\n            items=worlds,\n            icon=\"WORLD\"\n        )\n\n        row = layout.row()  # extra spacing\n\n    def execute(self, context):\n\n        clean.collections()\n        clean.images()\n        clean.lights()\n        clean.materials()\n        clean.node_groups()\n        clean.particles()\n        clean.textures()\n        clean.worlds()\n\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n\n        self.unused_collections = unused.collections_deep()\n        self.unused_images = unused.images_deep()\n        self.unused_lights = unused.lights_deep()\n        self.unused_materials = unused.materials_deep()\n        self.unused_node_groups = unused.node_groups_deep()\n        self.unused_particles = unused.particles_deep()\n        self.unused_textures = unused.textures_deep()\n        self.unused_worlds = unused.worlds()\n\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Nuke Collections Operator\nclass ATOMIC_OT_nuke_collections(bpy.types.Operator):\n    \"\"\"Remove all collections from this project\"\"\"",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 150,
                "column": 1
              },
              "endPosition": {
                "line": 151,
                "column": 5
              }
            },
            {
              "startPosition": {
                "line": 164,
                "column": 5
              },
              "endPosition": {
                "line": 165,
                "column": 9
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_OT_clean_all(bpy.types.Operator):",
            "lineNumber": 150,
            "isSignature": true
          },
          {
            "text": "def draw(self, context):",
            "lineNumber": 164
          },
          {
            "lineNumber": 218
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 219
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 220
          },
          {
            "text": "            title=\"Textures\",",
            "lineNumber": 221
          },
          {
            "text": "            items=textures,",
            "lineNumber": 222
          },
          {
            "text": "            icon=\"TEXTURE\"",
            "lineNumber": 223
          },
          {
            "text": "        )",
            "lineNumber": 224
          },
          {
            "lineNumber": 225
          },
          {
            "text": "        worlds = sorted(unused.worlds())",
            "lineNumber": 226
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 227
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 228
          },
          {
            "text": "            title=\"Worlds\",",
            "lineNumber": 229
          },
          {
            "text": "            items=worlds,",
            "lineNumber": 230
          },
          {
            "text": "            icon=\"WORLD\"",
            "lineNumber": 231
          },
          {
            "text": "        )",
            "lineNumber": 232
          },
          {
            "lineNumber": 233
          },
          {
            "text": "        row = layout.row()  # extra spacing",
            "lineNumber": 234
          },
          {
            "lineNumber": 235
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 236
          },
          {
            "lineNumber": 237
          },
          {
            "text": "        clean.collections()",
            "lineNumber": 238
          },
          {
            "text": "        clean.images()",
            "lineNumber": 239
          },
          {
            "text": "        clean.lights()",
            "lineNumber": 240
          },
          {
            "text": "        clean.materials()",
            "lineNumber": 241
          },
          {
            "text": "        clean.node_groups()",
            "lineNumber": 242
          },
          {
            "text": "        clean.particles()",
            "lineNumber": 243
          },
          {
            "text": "        clean.textures()",
            "lineNumber": 244
          },
          {
            "text": "        clean.worlds()",
            "lineNumber": 245
          },
          {
            "lineNumber": 246
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 247
          },
          {
            "lineNumber": 248
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 249
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 250
          },
          {
            "lineNumber": 251
          },
          {
            "text": "        self.unused_collections = unused.collections_deep()",
            "lineNumber": 252
          },
          {
            "text": "        self.unused_images = unused.images_deep()",
            "lineNumber": 253
          },
          {
            "text": "        self.unused_lights = unused.lights_deep()",
            "lineNumber": 254
          },
          {
            "text": "        self.unused_materials = unused.materials_deep()",
            "lineNumber": 255
          },
          {
            "text": "        self.unused_node_groups = unused.node_groups_deep()",
            "lineNumber": 256
          },
          {
            "text": "        self.unused_particles = unused.particles_deep()",
            "lineNumber": 257
          },
          {
            "text": "        self.unused_textures = unused.textures_deep()",
            "lineNumber": 258
          },
          {
            "text": "        self.unused_worlds = unused.worlds()",
            "lineNumber": 259
          },
          {
            "lineNumber": 260
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 261,
            "isSignature": true
          },
          {
            "lineNumber": 262
          },
          {
            "lineNumber": 263
          },
          {
            "text": "# Atomic Data Manager Nuke Collections Operator",
            "lineNumber": 264
          },
          {
            "text": "class ATOMIC_OT_nuke_collections(bpy.types.Operator):",
            "lineNumber": 265,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all collections from this project\"\"\"",
            "lineNumber": 266
          }
        ]
      },
      "score": 0.14655590057373047
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {
            "line": 188,
            "column": 43
          },
          "endPosition": {
            "line": 356
          }
        },
        "contents": "# Atomic Data Manager Clean Operator\nclass ATOMIC_OT_clean(bpy.types.Operator):\n    \"\"\"Remove all unused data-blocks from the selected categories\"\"\"\n    bl_idname = \"atomic.clean\"\n    bl_label = \"Clean\"\n\n    unused_collections = []\n    unused_images = []\n    unused_lights = []\n    unused_materials = []\n    unused_node_groups = []\n    unused_particles = []\n    unused_textures = []\n    unused_worlds = []\n\n    def draw(self, context):\n        atom = bpy.context.scene.atomic\n        layout = self.layout\n\n        col = layout.column()\n        col.label(text=\"Remove the following data-blocks?\")\n\n        # display if no main panel properties are toggled\n        if not (atom.collections or atom.images or atom.lights or\n                atom.materials or atom.node_groups or atom.particles\n                or atom.textures or atom.worlds):\n\n            ui_layouts.box_list(\n                layout=layout,\n            )\n\n        # display when the main panel collections property is toggled\n        if atom.collections:\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Collections\",\n                items=self.unused_collections,\n                icon=\"OUTLINER_OB_GROUP_INSTANCE\"\n            )\n\n        # display when the main panel images property is toggled\n        if atom.images:\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Images\",\n                items=self.unused_images,\n                icon=\"IMAGE_DATA\"\n            )\n\n        # display when the main panel lights property is toggled\n        if atom.lights:\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Lights\",\n                items=self.unused_lights,\n                icon=\"OUTLINER_OB_LIGHT\"\n            )\n\n        # display when the main panel materials property is toggled\n        if",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Operator",
            "lineNumber": 192
          },
          {
            "text": "class ATOMIC_OT_clean(bpy.types.Operator):",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused data-blocks from the selected categories\"\"\"",
            "lineNumber": 194
          },
          {
            "text": "    bl_idname = \"atomic.clean\"",
            "lineNumber": 195
          },
          {
            "text": "    bl_label = \"Clean\"",
            "lineNumber": 196
          },
          {
            "lineNumber": 197
          },
          {
            "text": "    unused_collections = []",
            "lineNumber": 198
          },
          {
            "text": "    unused_images = []",
            "lineNumber": 199
          },
          {
            "text": "    unused_lights = []",
            "lineNumber": 200
          },
          {
            "text": "    unused_materials = []",
            "lineNumber": 201
          },
          {
            "text": "    unused_node_groups = []",
            "lineNumber": 202
          },
          {
            "text": "    unused_particles = []",
            "lineNumber": 203
          },
          {
            "text": "    unused_textures = []",
            "lineNumber": 204
          },
          {
            "text": "    unused_worlds = []",
            "lineNumber": 205
          },
          {
            "lineNumber": 206
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 207
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 208
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 209
          },
          {
            "lineNumber": 210
          },
          {
            "text": "        col = layout.column()",
            "lineNumber": 211
          },
          {
            "text": "        col.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 212
          },
          {
            "lineNumber": 213
          },
          {
            "text": "        # display if no main panel properties are toggled",
            "lineNumber": 214
          },
          {
            "text": "        if not (atom.collections or atom.images or atom.lights or",
            "lineNumber": 215
          },
          {
            "text": "                atom.materials or atom.node_groups or atom.particles",
            "lineNumber": 216
          },
          {
            "text": "                or atom.textures or atom.worlds):",
            "lineNumber": 217
          },
          {
            "lineNumber": 218
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 219
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 220
          },
          {
            "text": "            )",
            "lineNumber": 221
          },
          {
            "lineNumber": 222
          },
          {
            "text": "        # display when the main panel collections property is toggled",
            "lineNumber": 223
          },
          {
            "text": "        if atom.collections:",
            "lineNumber": 224
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 225
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 226
          },
          {
            "text": "                title=\"Collections\",",
            "lineNumber": 227
          },
          {
            "text": "                items=self.unused_collections,",
            "lineNumber": 228
          },
          {
            "text": "                icon=\"OUTLINER_OB_GROUP_INSTANCE\"",
            "lineNumber": 229
          },
          {
            "text": "            )",
            "lineNumber": 230
          },
          {
            "lineNumber": 231
          },
          {
            "text": "        # display when the main panel images property is toggled",
            "lineNumber": 232
          },
          {
            "text": "        if atom.images:",
            "lineNumber": 233
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 234
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 235
          },
          {
            "text": "                title=\"Images\",",
            "lineNumber": 236
          },
          {
            "text": "                items=self.unused_images,",
            "lineNumber": 237
          },
          {
            "text": "                icon=\"IMAGE_DATA\"",
            "lineNumber": 238
          },
          {
            "text": "            )",
            "lineNumber": 239
          },
          {
            "lineNumber": 240
          },
          {
            "text": "        # display when the main panel lights property is toggled",
            "lineNumber": 241
          },
          {
            "text": "        if atom.lights:",
            "lineNumber": 242
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 243
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 244
          },
          {
            "text": "                title=\"Lights\",",
            "lineNumber": 245
          },
          {
            "text": "                items=self.unused_lights,",
            "lineNumber": 246
          },
          {
            "text": "                icon=\"OUTLINER_OB_LIGHT\"",
            "lineNumber": 247
          },
          {
            "text": "            )",
            "lineNumber": 248
          },
          {
            "lineNumber": 249
          },
          {
            "text": "        # display when the main panel materials property is toggled",
            "lineNumber": 250
          },
          {
            "text": "        if",
            "lineNumber": 251
          }
        ]
      },
      "score": 0.1363317370414734
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 145,
            "column": 43
          },
          "endPosition": {
            "line": 260
          }
        },
        "contents": "# Atomic Data Manager Clean All Operator\nclass ATOMIC_OT_clean_all(bpy.types.Operator):\n    \"\"\"Remove all unused data-blocks from the selected categories\"\"\"\n    bl_idname = \"atomic.clean_all\"\n    bl_label = \"Clean All\"\n\n    unused_collections = []\n    unused_images = []\n    unused_lights = []\n    unused_materials = []\n    unused_node_groups = []\n    unused_particles = []\n    unused_textures = []\n    unused_worlds = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        col = layout.column()\n        col.label(text=\"Remove the following data-blocks?\")\n\n        collections = sorted(unused.collections_deep())\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Collections\",\n            items=collections,\n            icon=\"OUTLINER_OB_GROUP_INSTANCE\"\n        )\n\n        images = sorted(unused.images_deep())\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Images\",\n            items=images,\n            icon=\"IMAGE_DATA\"\n        )\n\n        lights = sorted(unused.lights_deep())\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Lights\",\n            items=lights,\n            icon=\"OUTLINER_OB_LIGHT\"\n        )\n\n        materials = sorted(unused.materials_deep())\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Materials\",\n            items=materials,\n            icon=\"MATERIAL\"\n        )\n\n        node_groups = sorted(unused.node_groups_deep())\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Node Groups\",\n            items=node_groups,\n            icon=\"NODETREE\"\n        )\n\n        particles = sorted(unused.particles_deep())\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Particle Systems\",\n            items=particles,\n            icon=\"PARTICLES\"\n        )\n\n        textures = sorted(unused.textures_deep())\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Textures\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean All Operator",
            "lineNumber": 149
          },
          {
            "text": "class ATOMIC_OT_clean_all(bpy.types.Operator):",
            "lineNumber": 150,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused data-blocks from the selected categories\"\"\"",
            "lineNumber": 151
          },
          {
            "text": "    bl_idname = \"atomic.clean_all\"",
            "lineNumber": 152
          },
          {
            "text": "    bl_label = \"Clean All\"",
            "lineNumber": 153
          },
          {
            "lineNumber": 154
          },
          {
            "text": "    unused_collections = []",
            "lineNumber": 155
          },
          {
            "text": "    unused_images = []",
            "lineNumber": 156
          },
          {
            "text": "    unused_lights = []",
            "lineNumber": 157
          },
          {
            "text": "    unused_materials = []",
            "lineNumber": 158
          },
          {
            "text": "    unused_node_groups = []",
            "lineNumber": 159
          },
          {
            "text": "    unused_particles = []",
            "lineNumber": 160
          },
          {
            "text": "    unused_textures = []",
            "lineNumber": 161
          },
          {
            "text": "    unused_worlds = []",
            "lineNumber": 162
          },
          {
            "lineNumber": 163
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 164
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 165
          },
          {
            "lineNumber": 166
          },
          {
            "text": "        col = layout.column()",
            "lineNumber": 167
          },
          {
            "text": "        col.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 168
          },
          {
            "lineNumber": 169
          },
          {
            "text": "        collections = sorted(unused.collections_deep())",
            "lineNumber": 170
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 171
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 172
          },
          {
            "text": "            title=\"Collections\",",
            "lineNumber": 173
          },
          {
            "text": "            items=collections,",
            "lineNumber": 174
          },
          {
            "text": "            icon=\"OUTLINER_OB_GROUP_INSTANCE\"",
            "lineNumber": 175
          },
          {
            "text": "        )",
            "lineNumber": 176
          },
          {
            "lineNumber": 177
          },
          {
            "text": "        images = sorted(unused.images_deep())",
            "lineNumber": 178
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 179
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 180
          },
          {
            "text": "            title=\"Images\",",
            "lineNumber": 181
          },
          {
            "text": "            items=images,",
            "lineNumber": 182
          },
          {
            "text": "            icon=\"IMAGE_DATA\"",
            "lineNumber": 183
          },
          {
            "text": "        )",
            "lineNumber": 184
          },
          {
            "lineNumber": 185
          },
          {
            "text": "        lights = sorted(unused.lights_deep())",
            "lineNumber": 186
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 187
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 188
          },
          {
            "text": "            title=\"Lights\",",
            "lineNumber": 189
          },
          {
            "text": "            items=lights,",
            "lineNumber": 190
          },
          {
            "text": "            icon=\"OUTLINER_OB_LIGHT\"",
            "lineNumber": 191
          },
          {
            "text": "        )",
            "lineNumber": 192
          },
          {
            "lineNumber": 193
          },
          {
            "text": "        materials = sorted(unused.materials_deep())",
            "lineNumber": 194
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 195
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 196
          },
          {
            "text": "            title=\"Materials\",",
            "lineNumber": 197
          },
          {
            "text": "            items=materials,",
            "lineNumber": 198
          },
          {
            "text": "            icon=\"MATERIAL\"",
            "lineNumber": 199
          },
          {
            "text": "        )",
            "lineNumber": 200
          },
          {
            "lineNumber": 201
          },
          {
            "text": "        node_groups = sorted(unused.node_groups_deep())",
            "lineNumber": 202
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 203
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 204
          },
          {
            "text": "            title=\"Node Groups\",",
            "lineNumber": 205
          },
          {
            "text": "            items=node_groups,",
            "lineNumber": 206
          },
          {
            "text": "            icon=\"NODETREE\"",
            "lineNumber": 207
          },
          {
            "text": "        )",
            "lineNumber": 208
          },
          {
            "lineNumber": 209
          },
          {
            "text": "        particles = sorted(unused.particles_deep())",
            "lineNumber": 210
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 211
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 212
          },
          {
            "text": "            title=\"Particle Systems\",",
            "lineNumber": 213
          },
          {
            "text": "            items=particles,",
            "lineNumber": 214
          },
          {
            "text": "            icon=\"PARTICLES\"",
            "lineNumber": 215
          },
          {
            "text": "        )",
            "lineNumber": 216
          },
          {
            "lineNumber": 217
          },
          {
            "text": "        textures = sorted(unused.textures_deep())",
            "lineNumber": 218
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 219
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 220
          },
          {
            "text": "            title=\"Textures\"",
            "lineNumber": 221
          }
        ]
      },
      "score": 0.12864309549331665
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {
            "line": 36
          },
          "endPosition": {
            "line": 356
          }
        },
        "contents": "class ATOMIC_OT_nuke(bpy.types.Operator):\ndef draw(self, context):\n\n\n        # display when the main panel textures property is toggled\n        if atom.textures:\n            from ..utils import compat\n            textures = sorted([t.name for t in bpy.data.textures \n                              if not compat.is_library_or_override(t)])\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Textures\",\n                items=textures,\n                icon=\"TEXTURE\"\n            )\n\n        # display when the main panel worlds property is toggled\n        if atom.worlds:\n            from ..utils import compat\n            worlds = sorted([w.name for w in bpy.data.worlds \n                           if not compat.is_library_or_override(w)])\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Worlds\",\n                items=worlds,\n                icon=\"WORLD\"\n            )\n\n        row = layout.row()  # extra spacing\n\n    def execute(self, context):\n        atom = bpy.context.scene.atomic\n\n        if atom.collections:\n            nuke.collections()\n\n        if atom.images:\n            nuke.images()\n\n        if atom.lights:\n            nuke.lights()\n\n        if atom.materials:\n            nuke.materials()\n\n        if atom.node_groups:\n            nuke.node_groups()\n\n        if atom.particles:\n            nuke.particles()\n\n        if atom.textures:\n            nuke.textures()\n\n        if atom.worlds:\n            nuke.worlds()\n\n        bpy.ops.atomic.deselect_all()\n\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Operator\nclass ATOMIC_OT_clean(bpy.types.Operator):\n    \"\"\"Remove all unused data-blocks from the selected categories\"\"\"",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 37,
                "column": 1
              },
              "endPosition": {
                "line": 38,
                "column": 5
              }
            },
            {
              "startPosition": {
                "line": 42,
                "column": 5
              },
              "endPosition": {
                "line": 43,
                "column": 9
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_OT_nuke(bpy.types.Operator):",
            "lineNumber": 37,
            "isSignature": true
          },
          {
            "text": "def draw(self, context):",
            "lineNumber": 42
          },
          {
            "lineNumber": 128
          },
          {
            "lineNumber": 129
          },
          {
            "text": "        # display when the main panel textures property is toggled",
            "lineNumber": 130
          },
          {
            "text": "        if atom.textures:",
            "lineNumber": 131
          },
          {
            "text": "            from ..utils import compat",
            "lineNumber": 132
          },
          {
            "text": "            textures = sorted([t.name for t in bpy.data.textures ",
            "lineNumber": 133
          },
          {
            "text": "                              if not compat.is_library_or_override(t)])",
            "lineNumber": 134
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 135
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 136
          },
          {
            "text": "                title=\"Textures\",",
            "lineNumber": 137
          },
          {
            "text": "                items=textures,",
            "lineNumber": 138
          },
          {
            "text": "                icon=\"TEXTURE\"",
            "lineNumber": 139
          },
          {
            "text": "            )",
            "lineNumber": 140
          },
          {
            "lineNumber": 141
          },
          {
            "text": "        # display when the main panel worlds property is toggled",
            "lineNumber": 142
          },
          {
            "text": "        if atom.worlds:",
            "lineNumber": 143
          },
          {
            "text": "            from ..utils import compat",
            "lineNumber": 144
          },
          {
            "text": "            worlds = sorted([w.name for w in bpy.data.worlds ",
            "lineNumber": 145
          },
          {
            "text": "                           if not compat.is_library_or_override(w)])",
            "lineNumber": 146
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 147
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 148
          },
          {
            "text": "                title=\"Worlds\",",
            "lineNumber": 149
          },
          {
            "text": "                items=worlds,",
            "lineNumber": 150
          },
          {
            "text": "                icon=\"WORLD\"",
            "lineNumber": 151
          },
          {
            "text": "            )",
            "lineNumber": 152
          },
          {
            "lineNumber": 153
          },
          {
            "text": "        row = layout.row()  # extra spacing",
            "lineNumber": 154
          },
          {
            "lineNumber": 155
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 156
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 157
          },
          {
            "lineNumber": 158
          },
          {
            "text": "        if atom.collections:",
            "lineNumber": 159
          },
          {
            "text": "            nuke.collections()",
            "lineNumber": 160
          },
          {
            "lineNumber": 161
          },
          {
            "text": "        if atom.images:",
            "lineNumber": 162
          },
          {
            "text": "            nuke.images()",
            "lineNumber": 163
          },
          {
            "lineNumber": 164
          },
          {
            "text": "        if atom.lights:",
            "lineNumber": 165
          },
          {
            "text": "            nuke.lights()",
            "lineNumber": 166
          },
          {
            "lineNumber": 167
          },
          {
            "text": "        if atom.materials:",
            "lineNumber": 168
          },
          {
            "text": "            nuke.materials()",
            "lineNumber": 169
          },
          {
            "lineNumber": 170
          },
          {
            "text": "        if atom.node_groups:",
            "lineNumber": 171
          },
          {
            "text": "            nuke.node_groups()",
            "lineNumber": 172
          },
          {
            "lineNumber": 173
          },
          {
            "text": "        if atom.particles:",
            "lineNumber": 174
          },
          {
            "text": "            nuke.particles()",
            "lineNumber": 175
          },
          {
            "lineNumber": 176
          },
          {
            "text": "        if atom.textures:",
            "lineNumber": 177
          },
          {
            "text": "            nuke.textures()",
            "lineNumber": 178
          },
          {
            "lineNumber": 179
          },
          {
            "text": "        if atom.worlds:",
            "lineNumber": 180
          },
          {
            "text": "            nuke.worlds()",
            "lineNumber": 181
          },
          {
            "lineNumber": 182
          },
          {
            "text": "        bpy.ops.atomic.deselect_all()",
            "lineNumber": 183
          },
          {
            "lineNumber": 184
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 185
          },
          {
            "lineNumber": 186
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 187
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 188
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 189,
            "isSignature": true
          },
          {
            "lineNumber": 190
          },
          {
            "lineNumber": 191
          },
          {
            "text": "# Atomic Data Manager Clean Operator",
            "lineNumber": 192
          },
          {
            "text": "class ATOMIC_OT_clean(bpy.types.Operator):",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused data-blocks from the selected categories\"\"\"",
            "lineNumber": 194
          }
        ]
      },
      "score": 0.12817776203155518
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ui\\pie_menu_ui.py",
        "range": {
          "startPosition": {
            "line": 113,
            "column": 63
          },
          "endPosition": {
            "line": 181
          }
        },
        "contents": "# Atomic Data Manager Clean Pie Menu\nclass ATOMIC_MT_clean_pie(bpy.types.Menu):\n    bl_idname = \"ATOMIC_MT_clean_pie\"\n    bl_label = \"Atomic Clean\"\n\n    def draw(self, context):\n        layout = self.layout\n        pie = layout.menu_pie()\n\n        # clean node groups operator\n        pie.operator(\"atomic.clean_node_groups\", icon=\"NODETREE\")\n\n        # clean materials operator\n        pie.operator(\"atomic.clean_materials\", icon=\"MATERIAL\")\n\n        # clean worlds operator\n        pie.operator(\"atomic.clean_worlds\", icon=\"WORLD\")\n\n        # clean collections operator\n        pie.operator(\"atomic.clean_collections\", icon=\"GROUP\")\n\n        # clean lights operator\n        pie.operator(\"atomic.clean_lights\", icon=\"LIGHT\")\n\n        # clean images operator\n        pie.operator(\"atomic.clean_images\", icon=\"IMAGE_DATA\")\n\n        # clean textures operator\n        pie.operator(\"atomic.clean_textures\", icon=\"TEXTURE\")\n\n        # clean materials operator\n        pie.operator(\"atomic.clean_particles\", icon=\"PARTICLES\")\n\n\n# Atomic Data Manager Inspect Pie Menu\nclass ATOMIC_MT_inspect_pie(bpy.types.Menu):\n    bl_idname = \"ATOMIC_MT_inspect_pie\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Pie Menu",
            "lineNumber": 117
          },
          {
            "text": "class ATOMIC_MT_clean_pie(bpy.types.Menu):",
            "lineNumber": 118,
            "isSignature": true
          },
          {
            "text": "    bl_idname = \"ATOMIC_MT_clean_pie\"",
            "lineNumber": 119
          },
          {
            "text": "    bl_label = \"Atomic Clean\"",
            "lineNumber": 120
          },
          {
            "lineNumber": 121
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 122
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 123
          },
          {
            "text": "        pie = layout.menu_pie()",
            "lineNumber": 124
          },
          {
            "lineNumber": 125
          },
          {
            "text": "        # clean node groups operator",
            "lineNumber": 126
          },
          {
            "text": "        pie.operator(\"atomic.clean_node_groups\", icon=\"NODETREE\")",
            "lineNumber": 127
          },
          {
            "lineNumber": 128
          },
          {
            "text": "        # clean materials operator",
            "lineNumber": 129
          },
          {
            "text": "        pie.operator(\"atomic.clean_materials\", icon=\"MATERIAL\")",
            "lineNumber": 130
          },
          {
            "lineNumber": 131
          },
          {
            "text": "        # clean worlds operator",
            "lineNumber": 132
          },
          {
            "text": "        pie.operator(\"atomic.clean_worlds\", icon=\"WORLD\")",
            "lineNumber": 133
          },
          {
            "lineNumber": 134
          },
          {
            "text": "        # clean collections operator",
            "lineNumber": 135
          },
          {
            "text": "        pie.operator(\"atomic.clean_collections\", icon=\"GROUP\")",
            "lineNumber": 136
          },
          {
            "lineNumber": 137
          },
          {
            "text": "        # clean lights operator",
            "lineNumber": 138
          },
          {
            "text": "        pie.operator(\"atomic.clean_lights\", icon=\"LIGHT\")",
            "lineNumber": 139
          },
          {
            "lineNumber": 140
          },
          {
            "text": "        # clean images operator",
            "lineNumber": 141
          },
          {
            "text": "        pie.operator(\"atomic.clean_images\", icon=\"IMAGE_DATA\")",
            "lineNumber": 142
          },
          {
            "lineNumber": 143
          },
          {
            "text": "        # clean textures operator",
            "lineNumber": 144
          },
          {
            "text": "        pie.operator(\"atomic.clean_textures\", icon=\"TEXTURE\")",
            "lineNumber": 145
          },
          {
            "lineNumber": 146
          },
          {
            "text": "        # clean materials operator",
            "lineNumber": 147
          },
          {
            "text": "        pie.operator(\"atomic.clean_particles\", icon=\"PARTICLES\")",
            "lineNumber": 148,
            "isSignature": true
          },
          {
            "lineNumber": 149
          },
          {
            "lineNumber": 150
          },
          {
            "text": "# Atomic Data Manager Inspect Pie Menu",
            "lineNumber": 151
          },
          {
            "text": "class ATOMIC_MT_inspect_pie(bpy.types.Menu):",
            "lineNumber": 152,
            "isSignature": true
          },
          {
            "text": "    bl_idname = \"ATOMIC_MT_inspect_pie\"",
            "lineNumber": 153
          }
        ]
      },
      "score": 0.1253363937139511
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 724,
            "column": 43
          },
          "endPosition": {
            "line": 762,
            "column": 23
          }
        },
        "contents": "# Atomic Data Manager Clean Worlds Operator\nclass ATOMIC_OT_clean_worlds(bpy.types.Operator):\n    \"\"\"Remove all unused worlds from this project\"\"\"\n    bl_idname = \"atomic.clean_worlds\"\n    bl_label = \"Clean Worlds\"\n\n    unused_worlds = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_worlds,\n            icon=\"WORLD\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.worlds()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_worlds = unused.worlds()\n        return wm.invoke_props_dialog(self)\n\n\nreg_list = [\n    ATOMIC_OT_invoke_pie_menu_ui,\n\n    ATOMIC_OT_nuke_all,",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Worlds Operator",
            "lineNumber": 728
          },
          {
            "text": "class ATOMIC_OT_clean_worlds(bpy.types.Operator):",
            "lineNumber": 729,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused worlds from this project\"\"\"",
            "lineNumber": 730
          },
          {
            "text": "    bl_idname = \"atomic.clean_worlds\"",
            "lineNumber": 731
          },
          {
            "text": "    bl_label = \"Clean Worlds\"",
            "lineNumber": 732
          },
          {
            "lineNumber": 733
          },
          {
            "text": "    unused_worlds = []",
            "lineNumber": 734
          },
          {
            "lineNumber": 735
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 736
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 737
          },
          {
            "lineNumber": 738
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 739
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 740
          },
          {
            "lineNumber": 741
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 742
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 743
          },
          {
            "text": "            items=self.unused_worlds,",
            "lineNumber": 744
          },
          {
            "text": "            icon=\"WORLD\"",
            "lineNumber": 745
          },
          {
            "text": "        )",
            "lineNumber": 746
          },
          {
            "lineNumber": 747
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 748
          },
          {
            "lineNumber": 749
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 750
          },
          {
            "text": "        clean.worlds()",
            "lineNumber": 751
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 752
          },
          {
            "lineNumber": 753
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 754
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 755
          },
          {
            "text": "        self.unused_worlds = unused.worlds()",
            "lineNumber": 756
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 757,
            "isSignature": true
          },
          {
            "lineNumber": 758
          },
          {
            "lineNumber": 759
          },
          {
            "text": "reg_list = [",
            "lineNumber": 760
          },
          {
            "text": "    ATOMIC_OT_invoke_pie_menu_ui,",
            "lineNumber": 761
          },
          {
            "lineNumber": 762
          },
          {
            "text": "    ATOMIC_OT_nuke_all,",
            "lineNumber": 763
          }
        ]
      },
      "score": 0.12190210074186325
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 596,
            "column": 43
          },
          "endPosition": {
            "line": 660
          }
        },
        "contents": "# Atomic Data Manager Clean Materials Operator\nclass ATOMIC_OT_clean_materials(bpy.types.Operator):\n    \"\"\"Remove all unused materials from this project\"\"\"\n    bl_idname = \"atomic.clean_materials\"\n    bl_label = \"Clean Materials\"\n\n    unused_materials = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_materials,\n            icon=\"MATERIAL\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.materials()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_materials = unused.materials_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Node Groups Operator\nclass ATOMIC_OT_clean_node_groups(bpy.types.Operator):\n    \"\"\"Remove all unused node groups from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Materials Operator",
            "lineNumber": 600
          },
          {
            "text": "class ATOMIC_OT_clean_materials(bpy.types.Operator):",
            "lineNumber": 601,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused materials from this project\"\"\"",
            "lineNumber": 602
          },
          {
            "text": "    bl_idname = \"atomic.clean_materials\"",
            "lineNumber": 603
          },
          {
            "text": "    bl_label = \"Clean Materials\"",
            "lineNumber": 604
          },
          {
            "lineNumber": 605
          },
          {
            "text": "    unused_materials = []",
            "lineNumber": 606
          },
          {
            "lineNumber": 607
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 608
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 609
          },
          {
            "lineNumber": 610
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 611
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 612
          },
          {
            "lineNumber": 613
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 614
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 615
          },
          {
            "text": "            items=self.unused_materials,",
            "lineNumber": 616
          },
          {
            "text": "            icon=\"MATERIAL\"",
            "lineNumber": 617
          },
          {
            "text": "        )",
            "lineNumber": 618
          },
          {
            "lineNumber": 619
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 620
          },
          {
            "lineNumber": 621
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 622
          },
          {
            "text": "        clean.materials()",
            "lineNumber": 623
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 624
          },
          {
            "lineNumber": 625
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 626
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 627
          },
          {
            "text": "        self.unused_materials = unused.materials_deep()",
            "lineNumber": 628
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 629,
            "isSignature": true
          },
          {
            "lineNumber": 630
          },
          {
            "lineNumber": 631
          },
          {
            "text": "# Atomic Data Manager Clean Node Groups Operator",
            "lineNumber": 632
          },
          {
            "text": "class ATOMIC_OT_clean_node_groups(bpy.types.Operator):",
            "lineNumber": 633,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused node groups from this project\"\"\"",
            "lineNumber": 634
          }
        ]
      },
      "score": 0.11988069862127304
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 660,
            "column": 43
          },
          "endPosition": {
            "line": 724
          }
        },
        "contents": "# Atomic Data Manager Clean Particles Operator\nclass ATOMIC_OT_clean_particles(bpy.types.Operator):\n    \"\"\"Remove all unused particle systems from this project\"\"\"\n    bl_idname = \"atomic.clean_particles\"\n    bl_label = \"Clean Particles\"\n\n    unused_particles = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_particles,\n            icon=\"PARTICLES\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.particles()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_particles = unused.particles_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Textures Operator\nclass ATOMIC_OT_clean_textures(bpy.types.Operator):\n    \"\"\"Remove all unused textures from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Particles Operator",
            "lineNumber": 664
          },
          {
            "text": "class ATOMIC_OT_clean_particles(bpy.types.Operator):",
            "lineNumber": 665,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused particle systems from this project\"\"\"",
            "lineNumber": 666
          },
          {
            "text": "    bl_idname = \"atomic.clean_particles\"",
            "lineNumber": 667
          },
          {
            "text": "    bl_label = \"Clean Particles\"",
            "lineNumber": 668
          },
          {
            "lineNumber": 669
          },
          {
            "text": "    unused_particles = []",
            "lineNumber": 670
          },
          {
            "lineNumber": 671
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 672
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 673
          },
          {
            "lineNumber": 674
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 675
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 676
          },
          {
            "lineNumber": 677
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 678
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 679
          },
          {
            "text": "            items=self.unused_particles,",
            "lineNumber": 680
          },
          {
            "text": "            icon=\"PARTICLES\"",
            "lineNumber": 681
          },
          {
            "text": "        )",
            "lineNumber": 682
          },
          {
            "lineNumber": 683
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 684
          },
          {
            "lineNumber": 685
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 686
          },
          {
            "text": "        clean.particles()",
            "lineNumber": 687
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 688
          },
          {
            "lineNumber": 689
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 690
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 691
          },
          {
            "text": "        self.unused_particles = unused.particles_deep()",
            "lineNumber": 692
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 693,
            "isSignature": true
          },
          {
            "lineNumber": 694
          },
          {
            "lineNumber": 695
          },
          {
            "text": "# Atomic Data Manager Clean Textures Operator",
            "lineNumber": 696
          },
          {
            "text": "class ATOMIC_OT_clean_textures(bpy.types.Operator):",
            "lineNumber": 697,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused textures from this project\"\"\"",
            "lineNumber": 698
          }
        ]
      },
      "score": 0.11693280190229416
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 188
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains the main operators found in the main panel of the\nAtomic Data Manager interface. This includes nuke, clean, undo, and the\nvarious selection operations.\n\n\"\"\"\n\nimport bpy\nfrom bpy.utils import register_class\nfrom ..utils import compat\nfrom ..stats import unused\nfrom .utils import clean\nfrom .utils import nuke\nfrom ..ui.utils import ui_layouts\n\n\n# Atomic Data Manager Nuke Operator\nclass ATOMIC_OT_nuke(bpy.types.Operator):\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains the main operators found in the main panel of the",
            "lineNumber": 21
          },
          {
            "text": "Atomic Data Manager interface. This includes nuke, clean, undo, and the",
            "lineNumber": 22
          },
          {
            "text": "various selection operations.",
            "lineNumber": 23
          },
          {
            "lineNumber": 24
          },
          {
            "text": "\"\"\"",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "import bpy",
            "lineNumber": 27
          },
          {
            "text": "from bpy.utils import register_class",
            "lineNumber": 28
          },
          {
            "text": "from ..utils import compat",
            "lineNumber": 29
          },
          {
            "text": "from ..stats import unused",
            "lineNumber": 30
          },
          {
            "text": "from .utils import clean",
            "lineNumber": 31
          },
          {
            "text": "from .utils import nuke",
            "lineNumber": 32
          },
          {
            "text": "from ..ui.utils import ui_layouts",
            "lineNumber": 33
          },
          {
            "lineNumber": 34
          },
          {
            "lineNumber": 35
          },
          {
            "text": "# Atomic Data Manager Nuke Operator",
            "lineNumber": 36
          },
          {
            "text": "class ATOMIC_OT_nuke(bpy.types.Operator):",
            "lineNumber": 37,
            "isSignature": true
          },
          {
            "text": "    ",
            "lineNumber": 38
          }
        ]
      },
      "score": 0.11650974303483963
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 692,
            "column": 43
          },
          "endPosition": {
            "line": 756
          }
        },
        "contents": "# Atomic Data Manager Clean Textures Operator\nclass ATOMIC_OT_clean_textures(bpy.types.Operator):\n    \"\"\"Remove all unused textures from this project\"\"\"\n    bl_idname = \"atomic.clean_textures\"\n    bl_label = \"Clean Textures\"\n\n    unused_textures = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_textures,\n            icon=\"TEXTURE\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.textures()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_textures = unused.textures_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Worlds Operator\nclass ATOMIC_OT_clean_worlds(bpy.types.Operator):\n    \"\"\"Remove all unused worlds from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Textures Operator",
            "lineNumber": 696
          },
          {
            "text": "class ATOMIC_OT_clean_textures(bpy.types.Operator):",
            "lineNumber": 697,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused textures from this project\"\"\"",
            "lineNumber": 698
          },
          {
            "text": "    bl_idname = \"atomic.clean_textures\"",
            "lineNumber": 699
          },
          {
            "text": "    bl_label = \"Clean Textures\"",
            "lineNumber": 700
          },
          {
            "lineNumber": 701
          },
          {
            "text": "    unused_textures = []",
            "lineNumber": 702
          },
          {
            "lineNumber": 703
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 704
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 705
          },
          {
            "lineNumber": 706
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 707
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 708
          },
          {
            "lineNumber": 709
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 710
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 711
          },
          {
            "text": "            items=self.unused_textures,",
            "lineNumber": 712
          },
          {
            "text": "            icon=\"TEXTURE\"",
            "lineNumber": 713
          },
          {
            "text": "        )",
            "lineNumber": 714
          },
          {
            "lineNumber": 715
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 716
          },
          {
            "lineNumber": 717
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 718
          },
          {
            "text": "        clean.textures()",
            "lineNumber": 719
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 720
          },
          {
            "lineNumber": 721
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 722
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 723
          },
          {
            "text": "        self.unused_textures = unused.textures_deep()",
            "lineNumber": 724
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 725,
            "isSignature": true
          },
          {
            "lineNumber": 726
          },
          {
            "lineNumber": 727
          },
          {
            "text": "# Atomic Data Manager Clean Worlds Operator",
            "lineNumber": 728
          },
          {
            "text": "class ATOMIC_OT_clean_worlds(bpy.types.Operator):",
            "lineNumber": 729,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused worlds from this project\"\"\"",
            "lineNumber": 730
          }
        ]
      },
      "score": 0.11241614818572998
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 532,
            "column": 43
          },
          "endPosition": {
            "line": 596
          }
        },
        "contents": "# Atomic Data Manager Clean Images Operator\nclass ATOMIC_OT_clean_images(bpy.types.Operator):\n    \"\"\"Remove all unused images from this project\"\"\"\n    bl_idname = \"atomic.clean_images\"\n    bl_label = \"Clean Images\"\n\n    unused_images = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_images,\n            icon=\"IMAGE_DATA\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.images()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_images =unused.images_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Lights Operator\nclass ATOMIC_OT_clean_lights(bpy.types.Operator):\n    \"\"\"Remove all unused lights from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Images Operator",
            "lineNumber": 536
          },
          {
            "text": "class ATOMIC_OT_clean_images(bpy.types.Operator):",
            "lineNumber": 537,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused images from this project\"\"\"",
            "lineNumber": 538
          },
          {
            "text": "    bl_idname = \"atomic.clean_images\"",
            "lineNumber": 539
          },
          {
            "text": "    bl_label = \"Clean Images\"",
            "lineNumber": 540
          },
          {
            "lineNumber": 541
          },
          {
            "text": "    unused_images = []",
            "lineNumber": 542
          },
          {
            "lineNumber": 543
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 544
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 545
          },
          {
            "lineNumber": 546
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 547
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 548
          },
          {
            "lineNumber": 549
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 550
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 551
          },
          {
            "text": "            items=self.unused_images,",
            "lineNumber": 552
          },
          {
            "text": "            icon=\"IMAGE_DATA\"",
            "lineNumber": 553
          },
          {
            "text": "        )",
            "lineNumber": 554
          },
          {
            "lineNumber": 555
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 556
          },
          {
            "lineNumber": 557
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 558
          },
          {
            "text": "        clean.images()",
            "lineNumber": 559
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 560
          },
          {
            "lineNumber": 561
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 562
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 563
          },
          {
            "text": "        self.unused_images =unused.images_deep()",
            "lineNumber": 564
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 565,
            "isSignature": true
          },
          {
            "lineNumber": 566
          },
          {
            "lineNumber": 567
          },
          {
            "text": "# Atomic Data Manager Clean Lights Operator",
            "lineNumber": 568
          },
          {
            "text": "class ATOMIC_OT_clean_lights(bpy.types.Operator):",
            "lineNumber": 569,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused lights from this project\"\"\"",
            "lineNumber": 570
          }
        ]
      },
      "score": 0.11066489666700363
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ui\\main_panel_ui.py",
        "range": {
          "startPosition": {
            "line": 32,
            "column": 29
          },
          "endPosition": {
            "line": 231
          }
        },
        "contents": "# Atomic Data Manager Main Panel\nclass ATOMIC_PT_main_panel(bpy.types.Panel):\n    \"\"\"The main Atomic Data Manager panel\"\"\"\n    bl_label = \"Atomic Data Manager\"\n    bl_space_type = \"PROPERTIES\"\n    bl_region_type = \"WINDOW\"\n    bl_context = \"scene\"\n\n    def draw(self, context):\n        layout = self.layout\n        atom = bpy.context.scene.atomic\n        category_props = [\n            atom.collections,\n            atom.images,\n            atom.lights,\n            atom.materials,\n            atom.node_groups,\n            atom.particles,\n            atom.textures,\n            atom.worlds\n        ]\n\n        # nuke and clean buttons\n        row = layout.row(align=True)\n        row.scale_y = 2.0\n        row.operator(\"atomic.nuke\", text=\"Nuke\", icon=\"GHOST_ENABLED\")\n        row.operator(\"atomic.clean\", text=\"Clean\", icon=\"PARTICLEMODE\")\n        row.operator(\"atomic.undo\", text=\"Undo\", icon=\"LOOP_BACK\")\n\n        row = layout.row()\n\n        # category toggles\n        split = layout.split(align=False)\n\n        # left column\n        col = split.column(align=True)\n\n        # collections buttons\n        splitcol = col.split(factor=0.8, align=True)\n\n        splitcol.prop(\n            atom,\n            \"collections\",\n            text=\"Collections\",\n            icon='GROUP',\n            toggle=True\n        )\n\n        splitcol.operator(\n            \"atomic.inspect_collections\",\n            icon='VIEWZOOM',\n            text=\"\"\n        )\n\n        # lights buttons\n        splitcol = col.split(factor=0.8, align=True)\n\n        splitcol.prop(\n            atom,\n            \"lights\",\n            text=\"Lights\",\n            icon='LIGHT',\n            toggle=True\n        )\n\n        splitcol.operator(\n            \"atomic.inspect_lights\",\n            icon='VIEWZOOM',\n            text=\"\"\n        )\n\n        # node groups buttons\n        splitcol = col.split(factor=0.8, align=True)\n\n        splitcol.prop(\n            atom,\n            \"node_groups\",",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Main Panel",
            "lineNumber": 36
          },
          {
            "text": "class ATOMIC_PT_main_panel(bpy.types.Panel):",
            "lineNumber": 37,
            "isSignature": true
          },
          {
            "text": "    \"\"\"The main Atomic Data Manager panel\"\"\"",
            "lineNumber": 38
          },
          {
            "text": "    bl_label = \"Atomic Data Manager\"",
            "lineNumber": 39
          },
          {
            "text": "    bl_space_type = \"PROPERTIES\"",
            "lineNumber": 40
          },
          {
            "text": "    bl_region_type = \"WINDOW\"",
            "lineNumber": 41
          },
          {
            "text": "    bl_context = \"scene\"",
            "lineNumber": 42
          },
          {
            "lineNumber": 43
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 44
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 45
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 46
          },
          {
            "text": "        category_props = [",
            "lineNumber": 47
          },
          {
            "text": "            atom.collections,",
            "lineNumber": 48
          },
          {
            "text": "            atom.images,",
            "lineNumber": 49
          },
          {
            "text": "            atom.lights,",
            "lineNumber": 50
          },
          {
            "text": "            atom.materials,",
            "lineNumber": 51
          },
          {
            "text": "            atom.node_groups,",
            "lineNumber": 52
          },
          {
            "text": "            atom.particles,",
            "lineNumber": 53
          },
          {
            "text": "            atom.textures,",
            "lineNumber": 54
          },
          {
            "text": "            atom.worlds",
            "lineNumber": 55
          },
          {
            "text": "        ]",
            "lineNumber": 56
          },
          {
            "lineNumber": 57
          },
          {
            "text": "        # nuke and clean buttons",
            "lineNumber": 58
          },
          {
            "text": "        row = layout.row(align=True)",
            "lineNumber": 59
          },
          {
            "text": "        row.scale_y = 2.0",
            "lineNumber": 60
          },
          {
            "text": "        row.operator(\"atomic.nuke\", text=\"Nuke\", icon=\"GHOST_ENABLED\")",
            "lineNumber": 61
          },
          {
            "text": "        row.operator(\"atomic.clean\", text=\"Clean\", icon=\"PARTICLEMODE\")",
            "lineNumber": 62
          },
          {
            "text": "        row.operator(\"atomic.undo\", text=\"Undo\", icon=\"LOOP_BACK\")",
            "lineNumber": 63
          },
          {
            "lineNumber": 64
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 65
          },
          {
            "lineNumber": 66
          },
          {
            "text": "        # category toggles",
            "lineNumber": 67
          },
          {
            "text": "        split = layout.split(align=False)",
            "lineNumber": 68
          },
          {
            "lineNumber": 69
          },
          {
            "text": "        # left column",
            "lineNumber": 70
          },
          {
            "text": "        col = split.column(align=True)",
            "lineNumber": 71
          },
          {
            "lineNumber": 72
          },
          {
            "text": "        # collections buttons",
            "lineNumber": 73
          },
          {
            "text": "        splitcol = col.split(factor=0.8, align=True)",
            "lineNumber": 74
          },
          {
            "lineNumber": 75
          },
          {
            "text": "        splitcol.prop(",
            "lineNumber": 76
          },
          {
            "text": "            atom,",
            "lineNumber": 77
          },
          {
            "text": "            \"collections\",",
            "lineNumber": 78
          },
          {
            "text": "            text=\"Collections\",",
            "lineNumber": 79
          },
          {
            "text": "            icon='GROUP',",
            "lineNumber": 80
          },
          {
            "text": "            toggle=True",
            "lineNumber": 81
          },
          {
            "text": "        )",
            "lineNumber": 82
          },
          {
            "lineNumber": 83
          },
          {
            "text": "        splitcol.operator(",
            "lineNumber": 84
          },
          {
            "text": "            \"atomic.inspect_collections\",",
            "lineNumber": 85
          },
          {
            "text": "            icon='VIEWZOOM',",
            "lineNumber": 86
          },
          {
            "text": "            text=\"\"",
            "lineNumber": 87
          },
          {
            "text": "        )",
            "lineNumber": 88
          },
          {
            "lineNumber": 89
          },
          {
            "text": "        # lights buttons",
            "lineNumber": 90
          },
          {
            "text": "        splitcol = col.split(factor=0.8, align=True)",
            "lineNumber": 91
          },
          {
            "lineNumber": 92
          },
          {
            "text": "        splitcol.prop(",
            "lineNumber": 93
          },
          {
            "text": "            atom,",
            "lineNumber": 94
          },
          {
            "text": "            \"lights\",",
            "lineNumber": 95
          },
          {
            "text": "            text=\"Lights\",",
            "lineNumber": 96
          },
          {
            "text": "            icon='LIGHT',",
            "lineNumber": 97
          },
          {
            "text": "            toggle=True",
            "lineNumber": 98
          },
          {
            "text": "        )",
            "lineNumber": 99
          },
          {
            "lineNumber": 100
          },
          {
            "text": "        splitcol.operator(",
            "lineNumber": 101
          },
          {
            "text": "            \"atomic.inspect_lights\",",
            "lineNumber": 102
          },
          {
            "text": "            icon='VIEWZOOM',",
            "lineNumber": 103
          },
          {
            "text": "            text=\"\"",
            "lineNumber": 104
          },
          {
            "text": "        )",
            "lineNumber": 105
          },
          {
            "lineNumber": 106
          },
          {
            "text": "        # node groups buttons",
            "lineNumber": 107
          },
          {
            "text": "        splitcol = col.split(factor=0.8, align=True)",
            "lineNumber": 108
          },
          {
            "lineNumber": 109
          },
          {
            "text": "        splitcol.prop(",
            "lineNumber": 110
          },
          {
            "text": "            atom,",
            "lineNumber": 111
          },
          {
            "text": "            \"node_groups\",",
            "lineNumber": 112
          }
        ]
      },
      "score": 0.10901830345392227
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 756,
            "column": 43
          },
          "endPosition": {
            "line": 792,
            "column": 42
          }
        },
        "contents": "reg_list = [\n    ATOMIC_OT_invoke_pie_menu_ui,\n\n    ATOMIC_OT_nuke_all,\n    ATOMIC_OT_clean_all,\n\n    ATOMIC_OT_nuke_collections,\n    ATOMIC_OT_nuke_images,\n    ATOMIC_OT_nuke_lights,\n    ATOMIC_OT_nuke_materials,\n    ATOMIC_OT_nuke_node_groups,\n    ATOMIC_OT_nuke_particles,\n    ATOMIC_OT_nuke_textures,\n    ATOMIC_OT_nuke_worlds,\n\n    ATOMIC_OT_clean_collections,\n    ATOMIC_OT_clean_images,\n    ATOMIC_OT_clean_lights,\n    ATOMIC_OT_clean_materials,\n    ATOMIC_OT_clean_node_groups,\n    ATOMIC_OT_clean_particles,\n    ATOMIC_OT_clean_textures,\n    ATOMIC_OT_clean_worlds\n]\n\n\ndef register():\n    for item in reg_list:\n        register_class(item)\n\n\ndef unregister():\n    for item in reg_list:\n        compat.safe_unregister_class(item)",
        "signatures": {},
        "detailedLines": [
          {
            "text": "reg_list = [",
            "lineNumber": 760
          },
          {
            "text": "    ATOMIC_OT_invoke_pie_menu_ui,",
            "lineNumber": 761
          },
          {
            "lineNumber": 762
          },
          {
            "text": "    ATOMIC_OT_nuke_all,",
            "lineNumber": 763
          },
          {
            "text": "    ATOMIC_OT_clean_all,",
            "lineNumber": 764
          },
          {
            "lineNumber": 765
          },
          {
            "text": "    ATOMIC_OT_nuke_collections,",
            "lineNumber": 766
          },
          {
            "text": "    ATOMIC_OT_nuke_images,",
            "lineNumber": 767
          },
          {
            "text": "    ATOMIC_OT_nuke_lights,",
            "lineNumber": 768
          },
          {
            "text": "    ATOMIC_OT_nuke_materials,",
            "lineNumber": 769
          },
          {
            "text": "    ATOMIC_OT_nuke_node_groups,",
            "lineNumber": 770
          },
          {
            "text": "    ATOMIC_OT_nuke_particles,",
            "lineNumber": 771
          },
          {
            "text": "    ATOMIC_OT_nuke_textures,",
            "lineNumber": 772
          },
          {
            "text": "    ATOMIC_OT_nuke_worlds,",
            "lineNumber": 773
          },
          {
            "lineNumber": 774
          },
          {
            "text": "    ATOMIC_OT_clean_collections,",
            "lineNumber": 775
          },
          {
            "text": "    ATOMIC_OT_clean_images,",
            "lineNumber": 776
          },
          {
            "text": "    ATOMIC_OT_clean_lights,",
            "lineNumber": 777
          },
          {
            "text": "    ATOMIC_OT_clean_materials,",
            "lineNumber": 778
          },
          {
            "text": "    ATOMIC_OT_clean_node_groups,",
            "lineNumber": 779
          },
          {
            "text": "    ATOMIC_OT_clean_particles,",
            "lineNumber": 780
          },
          {
            "text": "    ATOMIC_OT_clean_textures,",
            "lineNumber": 781
          },
          {
            "text": "    ATOMIC_OT_clean_worlds",
            "lineNumber": 782
          },
          {
            "text": "]",
            "lineNumber": 783
          },
          {
            "lineNumber": 784
          },
          {
            "lineNumber": 785
          },
          {
            "text": "def register():",
            "lineNumber": 786,
            "isSignature": true
          },
          {
            "text": "    for item in reg_list:",
            "lineNumber": 787
          },
          {
            "text": "        register_class(item)",
            "lineNumber": 788,
            "isSignature": true
          },
          {
            "lineNumber": 789
          },
          {
            "lineNumber": 790
          },
          {
            "text": "def unregister():",
            "lineNumber": 791,
            "isSignature": true
          },
          {
            "text": "    for item in reg_list:",
            "lineNumber": 792
          },
          {
            "text": "        compat.safe_unregister_class(item)",
            "lineNumber": 793,
            "isSignature": true
          }
        ]
      },
      "score": 0.10647886991500854
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 564,
            "column": 43
          },
          "endPosition": {
            "line": 628
          }
        },
        "contents": "# Atomic Data Manager Clean Lights Operator\nclass ATOMIC_OT_clean_lights(bpy.types.Operator):\n    \"\"\"Remove all unused lights from this project\"\"\"\n    bl_idname = \"atomic.clean_lights\"\n    bl_label = \"Clean Lights\"\n\n    unused_lights = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_lights,\n            icon=\"OUTLINER_OB_LIGHT\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.lights()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_lights = unused.lights_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Materials Operator\nclass ATOMIC_OT_clean_materials(bpy.types.Operator):\n    \"\"\"Remove all unused materials from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Lights Operator",
            "lineNumber": 568
          },
          {
            "text": "class ATOMIC_OT_clean_lights(bpy.types.Operator):",
            "lineNumber": 569,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused lights from this project\"\"\"",
            "lineNumber": 570
          },
          {
            "text": "    bl_idname = \"atomic.clean_lights\"",
            "lineNumber": 571
          },
          {
            "text": "    bl_label = \"Clean Lights\"",
            "lineNumber": 572
          },
          {
            "lineNumber": 573
          },
          {
            "text": "    unused_lights = []",
            "lineNumber": 574
          },
          {
            "lineNumber": 575
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 576
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 577
          },
          {
            "lineNumber": 578
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 579
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 580
          },
          {
            "lineNumber": 581
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 582
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 583
          },
          {
            "text": "            items=self.unused_lights,",
            "lineNumber": 584
          },
          {
            "text": "            icon=\"OUTLINER_OB_LIGHT\"",
            "lineNumber": 585
          },
          {
            "text": "        )",
            "lineNumber": 586
          },
          {
            "lineNumber": 587
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 588
          },
          {
            "lineNumber": 589
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 590
          },
          {
            "text": "        clean.lights()",
            "lineNumber": 591
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 592
          },
          {
            "lineNumber": 593
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 594
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 595
          },
          {
            "text": "        self.unused_lights = unused.lights_deep()",
            "lineNumber": 596
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 597,
            "isSignature": true
          },
          {
            "lineNumber": 598
          },
          {
            "lineNumber": 599
          },
          {
            "text": "# Atomic Data Manager Clean Materials Operator",
            "lineNumber": 600
          },
          {
            "text": "class ATOMIC_OT_clean_materials(bpy.types.Operator):",
            "lineNumber": 601,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused materials from this project\"\"\"",
            "lineNumber": 602
          }
        ]
      },
      "score": 0.10489373654127121
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 500,
            "column": 43
          },
          "endPosition": {
            "line": 564
          }
        },
        "contents": "# Atomic Data Manager Clean Collections Operator\nclass ATOMIC_OT_clean_collections(bpy.types.Operator):\n    \"\"\"Remove all unused collections from this project\"\"\"\n    bl_idname = \"atomic.clean_collections\"\n    bl_label = \"Clean Collections\"\n\n    unused_collections = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_collections,\n            icon=\"OUTLINER_OB_GROUP_INSTANCE\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.collections()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_collections = unused.collections_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Images Operator\nclass ATOMIC_OT_clean_images(bpy.types.Operator):\n    \"\"\"Remove all unused images from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Collections Operator",
            "lineNumber": 504
          },
          {
            "text": "class ATOMIC_OT_clean_collections(bpy.types.Operator):",
            "lineNumber": 505,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused collections from this project\"\"\"",
            "lineNumber": 506
          },
          {
            "text": "    bl_idname = \"atomic.clean_collections\"",
            "lineNumber": 507
          },
          {
            "text": "    bl_label = \"Clean Collections\"",
            "lineNumber": 508
          },
          {
            "lineNumber": 509
          },
          {
            "text": "    unused_collections = []",
            "lineNumber": 510
          },
          {
            "lineNumber": 511
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 512
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 513
          },
          {
            "lineNumber": 514
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 515
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 516
          },
          {
            "lineNumber": 517
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 518
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 519
          },
          {
            "text": "            items=self.unused_collections,",
            "lineNumber": 520
          },
          {
            "text": "            icon=\"OUTLINER_OB_GROUP_INSTANCE\"",
            "lineNumber": 521
          },
          {
            "text": "        )",
            "lineNumber": 522
          },
          {
            "lineNumber": 523
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 524
          },
          {
            "lineNumber": 525
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 526
          },
          {
            "text": "        clean.collections()",
            "lineNumber": 527
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 528
          },
          {
            "lineNumber": 529
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 530
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 531
          },
          {
            "text": "        self.unused_collections = unused.collections_deep()",
            "lineNumber": 532
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 533,
            "isSignature": true
          },
          {
            "lineNumber": 534
          },
          {
            "lineNumber": 535
          },
          {
            "text": "# Atomic Data Manager Clean Images Operator",
            "lineNumber": 536
          },
          {
            "text": "class ATOMIC_OT_clean_images(bpy.types.Operator):",
            "lineNumber": 537,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused images from this project\"\"\"",
            "lineNumber": 538
          }
        ]
      },
      "score": 0.09983575344085693
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {
            "line": 402,
            "column": 27
          },
          "endPosition": {
            "line": 439
          }
        },
        "contents": "# Atomic Data Manager Select All Operator\nclass ATOMIC_OT_select_all(bpy.types.Operator):\n    \"\"\"Select all categories\"\"\"\n    bl_idname = \"atomic.select_all\"\n    bl_label = \"Select All\"\n\n    def execute(self, context):\n        bpy.context.scene.atomic.collections = True\n        bpy.context.scene.atomic.images = True\n        bpy.context.scene.atomic.lights = True\n        bpy.context.scene.atomic.materials = True\n        bpy.context.scene.atomic.node_groups = True\n        bpy.context.scene.atomic.particles = True\n        bpy.context.scene.atomic.textures = True\n        bpy.context.scene.atomic.worlds = True\n        return {'FINISHED'}\n\n\n# Atomic Data Manager Deselect All Operator\nclass ATOMIC_OT_deselect_all(bpy.types.Operator):\n    \"\"\"Deselect all categories\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Select All Operator",
            "lineNumber": 406
          },
          {
            "text": "class ATOMIC_OT_select_all(bpy.types.Operator):",
            "lineNumber": 407,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Select all categories\"\"\"",
            "lineNumber": 408
          },
          {
            "text": "    bl_idname = \"atomic.select_all\"",
            "lineNumber": 409
          },
          {
            "text": "    bl_label = \"Select All\"",
            "lineNumber": 410
          },
          {
            "lineNumber": 411
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 412
          },
          {
            "text": "        bpy.context.scene.atomic.collections = True",
            "lineNumber": 413
          },
          {
            "text": "        bpy.context.scene.atomic.images = True",
            "lineNumber": 414
          },
          {
            "text": "        bpy.context.scene.atomic.lights = True",
            "lineNumber": 415
          },
          {
            "text": "        bpy.context.scene.atomic.materials = True",
            "lineNumber": 416
          },
          {
            "text": "        bpy.context.scene.atomic.node_groups = True",
            "lineNumber": 417
          },
          {
            "text": "        bpy.context.scene.atomic.particles = True",
            "lineNumber": 418
          },
          {
            "text": "        bpy.context.scene.atomic.textures = True",
            "lineNumber": 419
          },
          {
            "text": "        bpy.context.scene.atomic.worlds = True",
            "lineNumber": 420
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 421,
            "isSignature": true
          },
          {
            "lineNumber": 422
          },
          {
            "lineNumber": 423
          },
          {
            "text": "# Atomic Data Manager Deselect All Operator",
            "lineNumber": 424
          },
          {
            "text": "class ATOMIC_OT_deselect_all(bpy.types.Operator):",
            "lineNumber": 425,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Deselect all categories\"\"\"",
            "lineNumber": 426
          }
        ]
      },
      "score": 0.09944190084934235
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 628,
            "column": 43
          },
          "endPosition": {
            "line": 692
          }
        },
        "contents": "# Atomic Data Manager Clean Node Groups Operator\nclass ATOMIC_OT_clean_node_groups(bpy.types.Operator):\n    \"\"\"Remove all unused node groups from this project\"\"\"\n    bl_idname = \"atomic.clean_node_groups\"\n    bl_label = \"Clean Node Groups\"\n\n    unused_node_groups = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_node_groups,\n            icon=\"NODETREE\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.node_groups()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_node_groups = unused.node_groups_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Particles Operator\nclass ATOMIC_OT_clean_particles(bpy.types.Operator):\n    \"\"\"Remove all unused particle systems from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Node Groups Operator",
            "lineNumber": 632
          },
          {
            "text": "class ATOMIC_OT_clean_node_groups(bpy.types.Operator):",
            "lineNumber": 633,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused node groups from this project\"\"\"",
            "lineNumber": 634
          },
          {
            "text": "    bl_idname = \"atomic.clean_node_groups\"",
            "lineNumber": 635
          },
          {
            "text": "    bl_label = \"Clean Node Groups\"",
            "lineNumber": 636
          },
          {
            "lineNumber": 637
          },
          {
            "text": "    unused_node_groups = []",
            "lineNumber": 638
          },
          {
            "lineNumber": 639
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 640
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 641
          },
          {
            "lineNumber": 642
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 643
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 644
          },
          {
            "lineNumber": 645
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 646
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 647
          },
          {
            "text": "            items=self.unused_node_groups,",
            "lineNumber": 648
          },
          {
            "text": "            icon=\"NODETREE\"",
            "lineNumber": 649
          },
          {
            "text": "        )",
            "lineNumber": 650
          },
          {
            "lineNumber": 651
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 652
          },
          {
            "lineNumber": 653
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 654
          },
          {
            "text": "        clean.node_groups()",
            "lineNumber": 655
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 656
          },
          {
            "lineNumber": 657
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 658
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 659
          },
          {
            "text": "        self.unused_node_groups = unused.node_groups_deep()",
            "lineNumber": 660
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 661,
            "isSignature": true
          },
          {
            "lineNumber": 662
          },
          {
            "lineNumber": 663
          },
          {
            "text": "# Atomic Data Manager Clean Particles Operator",
            "lineNumber": 664
          },
          {
            "text": "class ATOMIC_OT_clean_particles(bpy.types.Operator):",
            "lineNumber": 665,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused particle systems from this project\"\"\"",
            "lineNumber": 666
          }
        ]
      },
      "score": 0.09779520332813263
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {
            "line": 420,
            "column": 27
          },
          "endPosition": {
            "line": 445,
            "column": 19
          }
        },
        "contents": "# Atomic Data Manager Deselect All Operator\nclass ATOMIC_OT_deselect_all(bpy.types.Operator):\n    \"\"\"Deselect all categories\"\"\"\n    bl_idname = \"atomic.deselect_all\"\n    bl_label = \"Deselect All\"\n\n    def execute(self, context):\n        bpy.context.scene.atomic.collections = False\n        bpy.context.scene.atomic.images = False\n        bpy.context.scene.atomic.lights = False\n        bpy.context.scene.atomic.materials = False\n        bpy.context.scene.atomic.node_groups = False\n        bpy.context.scene.atomic.particles = False\n        bpy.context.scene.atomic.textures = False\n        bpy.context.scene.atomic.worlds = False\n\n        return {'FINISHED'}\n\n\nreg_list = [\n    ATOMIC_OT_nuke,\n    ATOMIC_OT_clean,\n    ATOMIC_OT_undo,",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Deselect All Operator",
            "lineNumber": 424
          },
          {
            "text": "class ATOMIC_OT_deselect_all(bpy.types.Operator):",
            "lineNumber": 425,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Deselect all categories\"\"\"",
            "lineNumber": 426
          },
          {
            "text": "    bl_idname = \"atomic.deselect_all\"",
            "lineNumber": 427
          },
          {
            "text": "    bl_label = \"Deselect All\"",
            "lineNumber": 428
          },
          {
            "lineNumber": 429
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 430
          },
          {
            "text": "        bpy.context.scene.atomic.collections = False",
            "lineNumber": 431
          },
          {
            "text": "        bpy.context.scene.atomic.images = False",
            "lineNumber": 432
          },
          {
            "text": "        bpy.context.scene.atomic.lights = False",
            "lineNumber": 433
          },
          {
            "text": "        bpy.context.scene.atomic.materials = False",
            "lineNumber": 434
          },
          {
            "text": "        bpy.context.scene.atomic.node_groups = False",
            "lineNumber": 435
          },
          {
            "text": "        bpy.context.scene.atomic.particles = False",
            "lineNumber": 436
          },
          {
            "text": "        bpy.context.scene.atomic.textures = False",
            "lineNumber": 437
          },
          {
            "text": "        bpy.context.scene.atomic.worlds = False",
            "lineNumber": 438
          },
          {
            "lineNumber": 439
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 440,
            "isSignature": true
          },
          {
            "lineNumber": 441
          },
          {
            "lineNumber": 442
          },
          {
            "text": "reg_list = [",
            "lineNumber": 443
          },
          {
            "text": "    ATOMIC_OT_nuke,",
            "lineNumber": 444
          },
          {
            "text": "    ATOMIC_OT_clean,",
            "lineNumber": 445
          },
          {
            "text": "    ATOMIC_OT_undo,",
            "lineNumber": 446
          }
        ]
      },
      "score": 0.09519655257463455
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\missing_file_ops.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 102
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains operations for missing file handling. This includes\nthe option to reload, remove, replace, and search for these missing files.\n\nIt also contains the post-reload report dialog that appears after\nattempting to reload missing project files.\n\n# TODO: implement missing file replace and search once Blender fixes the\n# TODO: bugs with the file chooser not opening from a dialog\n\n\"\"\"\n\nimport bpy\nfrom bpy.utils import register_class\nfrom ..utils import compat\nfrom ..stats import missing\nfrom ..ui.utils import ui_layouts\n\n\n# Atomic Data Manager Reload Missing Files Operator\nclass ATOMIC_OT_reload_missing(bpy.types.Operator):\n    \"\"\"Reload missing files\"\"\"\n    bl_idname = \"atomic.reload_missing\"\n    bl_label = \"Reload Missing Files\"\n\n    def execute(self, context):\n        # reload images\n        for image in bpy.data.images:\n            image.reload()\n\n        # reload libraries\n        for library in bpy.data.libraries:\n            library.reload()\n\n        # call reload report\n        bpy.ops.atomic.reload_report('INVOKE_DEFAULT')\n        return {'FINISHED'}\n\n\n# Atomic Data Manager Reload Missing Files Report Operator\nclass ATOMIC_OT_reload_report(bpy.types.Operator):\n    \"\"\"Reload report for missing files\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains operations for missing file handling. This includes",
            "lineNumber": 21
          },
          {
            "text": "the option to reload, remove, replace, and search for these missing files.",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "It also contains the post-reload report dialog that appears after",
            "lineNumber": 24
          },
          {
            "text": "attempting to reload missing project files.",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "# TODO: implement missing file replace and search once Blender fixes the",
            "lineNumber": 27
          },
          {
            "text": "# TODO: bugs with the file chooser not opening from a dialog",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "text": "\"\"\"",
            "lineNumber": 30
          },
          {
            "lineNumber": 31
          },
          {
            "text": "import bpy",
            "lineNumber": 32
          },
          {
            "text": "from bpy.utils import register_class",
            "lineNumber": 33
          },
          {
            "text": "from ..utils import compat",
            "lineNumber": 34
          },
          {
            "text": "from ..stats import missing",
            "lineNumber": 35
          },
          {
            "text": "from ..ui.utils import ui_layouts",
            "lineNumber": 36
          },
          {
            "lineNumber": 37
          },
          {
            "lineNumber": 38
          },
          {
            "text": "# Atomic Data Manager Reload Missing Files Operator",
            "lineNumber": 39
          },
          {
            "text": "class ATOMIC_OT_reload_missing(bpy.types.Operator):",
            "lineNumber": 40,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Reload missing files\"\"\"",
            "lineNumber": 41
          },
          {
            "text": "    bl_idname = \"atomic.reload_missing\"",
            "lineNumber": 42
          },
          {
            "text": "    bl_label = \"Reload Missing Files\"",
            "lineNumber": 43
          },
          {
            "lineNumber": 44
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 45
          },
          {
            "text": "        # reload images",
            "lineNumber": 46
          },
          {
            "text": "        for image in bpy.data.images:",
            "lineNumber": 47
          },
          {
            "text": "            image.reload()",
            "lineNumber": 48
          },
          {
            "lineNumber": 49
          },
          {
            "text": "        # reload libraries",
            "lineNumber": 50
          },
          {
            "text": "        for library in bpy.data.libraries:",
            "lineNumber": 51
          },
          {
            "text": "            library.reload()",
            "lineNumber": 52
          },
          {
            "lineNumber": 53
          },
          {
            "text": "        # call reload report",
            "lineNumber": 54
          },
          {
            "text": "        bpy.ops.atomic.reload_report('INVOKE_DEFAULT')",
            "lineNumber": 55
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 56,
            "isSignature": true
          },
          {
            "lineNumber": 57
          },
          {
            "lineNumber": 58
          },
          {
            "text": "# Atomic Data Manager Reload Missing Files Report Operator",
            "lineNumber": 59
          },
          {
            "text": "class ATOMIC_OT_reload_report(bpy.types.Operator):",
            "lineNumber": 60,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Reload report for missing files\"\"\"",
            "lineNumber": 61
          }
        ]
      },
      "score": 0.0941087007522583
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\inspect_ops.py",
        "range": {
          "startPosition": {
            "line": 140
          },
          "endPosition": {
            "line": 294
          }
        },
        "contents": "class ATOMIC_OT_inspection_replace(bpy.types.Operator):\ndef draw(self, context):\n\n            )\n\n    def execute(self, context):\n        atom = bpy.context.scene.atomic\n        inspection = atom.active_inspection\n\n        if inspection == 'IMAGES' and \\\n                atom.replace_field in bpy.data.images.keys():\n            image = bpy.data.images[atom.images_field]\n            error = _check_library_or_override(image)\n            if error:\n                self.report({'ERROR'}, error)\n                return {'CANCELLED'}\n            image.user_remap(bpy.data.images[atom.replace_field])\n            atom.images_field = atom.replace_field\n\n        if inspection == 'LIGHTS' and \\\n                atom.replace_field in bpy.data.lights.keys():\n            light = bpy.data.lights[atom.lights_field]\n            error = _check_library_or_override(light)\n            if error:\n                self.report({'ERROR'}, error)\n                return {'CANCELLED'}\n            light.user_remap(bpy.data.lights[atom.replace_field])\n            atom.lights_field = atom.replace_field\n\n        if inspection == 'MATERIALS' and \\\n                atom.replace_field in bpy.data.materials.keys():\n            material = bpy.data.materials[atom.materials_field]\n            error = _check_library_or_override(material)\n            if error:\n                self.report({'ERROR'}, error)\n                return {'CANCELLED'}\n            material.user_remap(bpy.data.materials[atom.replace_field])\n            atom.materials_field = atom.replace_field\n\n        if inspection == 'NODE_GROUPS' and \\\n                atom.replace_field in bpy.data.node_groups.keys():\n            node_group = bpy.data.node_groups[atom.node_groups_field]\n            error = _check_library_or_override(node_group)\n            if error:\n                self.report({'ERROR'}, error)\n                return {'CANCELLED'}\n            node_group.user_remap(bpy.data.node_groups[atom.replace_field])\n            atom.node_groups_field = atom.replace_field\n\n        if inspection == 'PARTICLES' and \\",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 141,
                "column": 1
              },
              "endPosition": {
                "line": 142,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_OT_inspection_replace(bpy.types.Operator):",
            "lineNumber": 141,
            "isSignature": true
          },
          {
            "text": "def draw(self, context):",
            "lineNumber": 146
          },
          {
            "lineNumber": 213
          },
          {
            "text": "            )",
            "lineNumber": 214
          },
          {
            "lineNumber": 215
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 216
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 217
          },
          {
            "text": "        inspection = atom.active_inspection",
            "lineNumber": 218
          },
          {
            "lineNumber": 219
          },
          {
            "text": "        if inspection == 'IMAGES' and \\",
            "lineNumber": 220
          },
          {
            "text": "                atom.replace_field in bpy.data.images.keys():",
            "lineNumber": 221
          },
          {
            "text": "            image = bpy.data.images[atom.images_field]",
            "lineNumber": 222
          },
          {
            "text": "            error = _check_library_or_override(image)",
            "lineNumber": 223
          },
          {
            "text": "            if error:",
            "lineNumber": 224
          },
          {
            "text": "                self.report({'ERROR'}, error)",
            "lineNumber": 225
          },
          {
            "text": "                return {'CANCELLED'}",
            "lineNumber": 226
          },
          {
            "text": "            image.user_remap(bpy.data.images[atom.replace_field])",
            "lineNumber": 227
          },
          {
            "text": "            atom.images_field = atom.replace_field",
            "lineNumber": 228
          },
          {
            "lineNumber": 229
          },
          {
            "text": "        if inspection == 'LIGHTS' and \\",
            "lineNumber": 230
          },
          {
            "text": "                atom.replace_field in bpy.data.lights.keys():",
            "lineNumber": 231
          },
          {
            "text": "            light = bpy.data.lights[atom.lights_field]",
            "lineNumber": 232
          },
          {
            "text": "            error = _check_library_or_override(light)",
            "lineNumber": 233
          },
          {
            "text": "            if error:",
            "lineNumber": 234
          },
          {
            "text": "                self.report({'ERROR'}, error)",
            "lineNumber": 235
          },
          {
            "text": "                return {'CANCELLED'}",
            "lineNumber": 236
          },
          {
            "text": "            light.user_remap(bpy.data.lights[atom.replace_field])",
            "lineNumber": 237
          },
          {
            "text": "            atom.lights_field = atom.replace_field",
            "lineNumber": 238
          },
          {
            "lineNumber": 239
          },
          {
            "text": "        if inspection == 'MATERIALS' and \\",
            "lineNumber": 240
          },
          {
            "text": "                atom.replace_field in bpy.data.materials.keys():",
            "lineNumber": 241
          },
          {
            "text": "            material = bpy.data.materials[atom.materials_field]",
            "lineNumber": 242
          },
          {
            "text": "            error = _check_library_or_override(material)",
            "lineNumber": 243
          },
          {
            "text": "            if error:",
            "lineNumber": 244
          },
          {
            "text": "                self.report({'ERROR'}, error)",
            "lineNumber": 245
          },
          {
            "text": "                return {'CANCELLED'}",
            "lineNumber": 246
          },
          {
            "text": "            material.user_remap(bpy.data.materials[atom.replace_field])",
            "lineNumber": 247
          },
          {
            "text": "            atom.materials_field = atom.replace_field",
            "lineNumber": 248
          },
          {
            "lineNumber": 249
          },
          {
            "text": "        if inspection == 'NODE_GROUPS' and \\",
            "lineNumber": 250
          },
          {
            "text": "                atom.replace_field in bpy.data.node_groups.keys():",
            "lineNumber": 251
          },
          {
            "text": "            node_group = bpy.data.node_groups[atom.node_groups_field]",
            "lineNumber": 252
          },
          {
            "text": "            error = _check_library_or_override(node_group)",
            "lineNumber": 253
          },
          {
            "text": "            if error:",
            "lineNumber": 254
          },
          {
            "text": "                self.report({'ERROR'}, error)",
            "lineNumber": 255
          },
          {
            "text": "                return {'CANCELLED'}",
            "lineNumber": 256
          },
          {
            "text": "            node_group.user_remap(bpy.data.node_groups[atom.replace_field])",
            "lineNumber": 257
          },
          {
            "text": "            atom.node_groups_field = atom.replace_field",
            "lineNumber": 258
          },
          {
            "lineNumber": 259
          },
          {
            "text": "        if inspection == 'PARTICLES' and \\",
            "lineNumber": 260
          }
        ]
      },
      "score": 0.09080380201339722
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ui\\pie_menu_ui.py",
        "range": {
          "startPosition": {
            "line": 27,
            "column": 26
          },
          "endPosition": {
            "line": 113
          }
        },
        "contents": "# Atomic Data Manager Main Pie Menu\nclass ATOMIC_MT_main_pie(bpy.types.Menu):\n    bl_idname = \"ATOMIC_MT_main_pie\"\n    bl_label = \"Atomic Data Manager\"\n\n    def draw(self, context):\n        layout = self.layout\n        pie = layout.menu_pie()\n\n        # nuke all operator\n        pie.operator(\n            \"atomic.nuke_all\",\n            text=\"Nuke All\",\n            icon=\"GHOST_ENABLED\"\n        )\n\n        # clean all operator\n        pie.operator(\n            \"atomic.clean_all\",\n            text=\"Clean All\",\n            icon=\"PARTICLEMODE\"\n        )\n\n        # undo operator\n        pie.operator(\n            \"atomic.detect_missing\",\n            text=\"Detect Missing Files\",\n            icon=\"SHADERFX\"\n        )\n\n        # inspect category operator\n        pie.operator(\n            \"wm.call_menu_pie\",\n            text=\"Inspect\",\n            icon=\"VIEWZOOM\"\n        ).name = \"ATOMIC_MT_inspect_pie\"\n\n        # nuke category operator\n        pie.operator(\n            \"wm.call_menu_pie\",\n            text=\"Nuke\",\n            icon=\"GHOST_ENABLED\"\n        ).name = \"ATOMIC_MT_nuke_pie\"\n\n        # clean category operator\n        pie.operator(\n            \"wm.call_menu_pie\",\n            text=\"Clean\",\n            icon=\"PARTICLEMODE\"\n        ).name = \"ATOMIC_MT_clean_pie\"\n\n\n# Atomic Data Manager Nuke Pie Menu\nclass ATOMIC_MT_nuke_pie(bpy.types.Menu):\n    bl_idname = \"ATOMIC_MT_nuke_pie\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Main Pie Menu",
            "lineNumber": 31
          },
          {
            "text": "class ATOMIC_MT_main_pie(bpy.types.Menu):",
            "lineNumber": 32,
            "isSignature": true
          },
          {
            "text": "    bl_idname = \"ATOMIC_MT_main_pie\"",
            "lineNumber": 33
          },
          {
            "text": "    bl_label = \"Atomic Data Manager\"",
            "lineNumber": 34
          },
          {
            "lineNumber": 35
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 36
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 37
          },
          {
            "text": "        pie = layout.menu_pie()",
            "lineNumber": 38
          },
          {
            "lineNumber": 39
          },
          {
            "text": "        # nuke all operator",
            "lineNumber": 40
          },
          {
            "text": "        pie.operator(",
            "lineNumber": 41
          },
          {
            "text": "            \"atomic.nuke_all\",",
            "lineNumber": 42
          },
          {
            "text": "            text=\"Nuke All\",",
            "lineNumber": 43
          },
          {
            "text": "            icon=\"GHOST_ENABLED\"",
            "lineNumber": 44
          },
          {
            "text": "        )",
            "lineNumber": 45
          },
          {
            "lineNumber": 46
          },
          {
            "text": "        # clean all operator",
            "lineNumber": 47
          },
          {
            "text": "        pie.operator(",
            "lineNumber": 48
          },
          {
            "text": "            \"atomic.clean_all\",",
            "lineNumber": 49
          },
          {
            "text": "            text=\"Clean All\",",
            "lineNumber": 50
          },
          {
            "text": "            icon=\"PARTICLEMODE\"",
            "lineNumber": 51
          },
          {
            "text": "        )",
            "lineNumber": 52
          },
          {
            "lineNumber": 53
          },
          {
            "text": "        # undo operator",
            "lineNumber": 54
          },
          {
            "text": "        pie.operator(",
            "lineNumber": 55
          },
          {
            "text": "            \"atomic.detect_missing\",",
            "lineNumber": 56
          },
          {
            "text": "            text=\"Detect Missing Files\",",
            "lineNumber": 57
          },
          {
            "text": "            icon=\"SHADERFX\"",
            "lineNumber": 58
          },
          {
            "text": "        )",
            "lineNumber": 59
          },
          {
            "lineNumber": 60
          },
          {
            "text": "        # inspect category operator",
            "lineNumber": 61
          },
          {
            "text": "        pie.operator(",
            "lineNumber": 62
          },
          {
            "text": "            \"wm.call_menu_pie\",",
            "lineNumber": 63
          },
          {
            "text": "            text=\"Inspect\",",
            "lineNumber": 64
          },
          {
            "text": "            icon=\"VIEWZOOM\"",
            "lineNumber": 65
          },
          {
            "text": "        ).name = \"ATOMIC_MT_inspect_pie\"",
            "lineNumber": 66
          },
          {
            "lineNumber": 67
          },
          {
            "text": "        # nuke category operator",
            "lineNumber": 68
          },
          {
            "text": "        pie.operator(",
            "lineNumber": 69
          },
          {
            "text": "            \"wm.call_menu_pie\",",
            "lineNumber": 70
          },
          {
            "text": "            text=\"Nuke\",",
            "lineNumber": 71
          },
          {
            "text": "            icon=\"GHOST_ENABLED\"",
            "lineNumber": 72
          },
          {
            "text": "        ).name = \"ATOMIC_MT_nuke_pie\"",
            "lineNumber": 73
          },
          {
            "lineNumber": 74
          },
          {
            "text": "        # clean category operator",
            "lineNumber": 75
          },
          {
            "text": "        pie.operator(",
            "lineNumber": 76
          },
          {
            "text": "            \"wm.call_menu_pie\",",
            "lineNumber": 77
          },
          {
            "text": "            text=\"Clean\",",
            "lineNumber": 78
          },
          {
            "text": "            icon=\"PARTICLEMODE\"",
            "lineNumber": 79
          },
          {
            "text": "        ).name = \"ATOMIC_MT_clean_pie\"",
            "lineNumber": 80,
            "isSignature": true
          },
          {
            "lineNumber": 81
          },
          {
            "lineNumber": 82
          },
          {
            "text": "# Atomic Data Manager Nuke Pie Menu",
            "lineNumber": 83
          },
          {
            "text": "class ATOMIC_MT_nuke_pie(bpy.types.Menu):",
            "lineNumber": 84,
            "isSignature": true
          },
          {
            "text": "    bl_idname = \"ATOMIC_MT_nuke_pie\"",
            "lineNumber": 85
          }
        ]
      },
      "score": 0.0898595005273819
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "smart.*select|clean",
  "caseInsensitive": true
}
```
Result:

```json
{
  "success": {
    "pattern": "smart.*select|clean",
    "outputMode": "content",
    "workspaceResults": {
      "E:\\atomic_data_manager": {
        "content": {
          "matches": [
            {
              "file": "ops/main_ops.py",
              "matches": [
                {
                  "lineNumber": 22,
                  "content": "Atomic Data Manager interface. This includes nuke, clean, undo, and the"
                },
                {
                  "lineNumber": 31,
                  "content": "from .utils import clean"
                },
                {
                  "lineNumber": 192,
                  "content": "# Atomic Data Manager Clean Operator"
                },
                {
                  "lineNumber": 193,
                  "content": "class ATOMIC_OT_clean(bpy.types.Operator):"
                },
                {
                  "lineNumber": 195,
                  "content": "    bl_idname = \"atomic.clean\""
                },
                {
                  "lineNumber": 196,
                  "content": "    bl_label = \"Clean\""
                },
                {
                  "lineNumber": 302,
                  "content": "            clean.collections()"
                },
                {
                  "lineNumber": 305,
                  "content": "            clean.images()"
                },
                {
                  "lineNumber": 308,
                  "content": "            clean.lights()"
                },
                {
                  "lineNumber": 311,
                  "content": "            clean.materials()"
                },
                {
                  "lineNumber": 314,
                  "content": "            clean.node_groups()"
                },
                {
                  "lineNumber": 317,
                  "content": "            clean.particles()"
                },
                {
                  "lineNumber": 320,
                  "content": "            clean.textures()"
                },
                {
                  "lineNumber": 323,
                  "content": "            clean.worlds()"
                },
                {
                  "lineNumber": 371,
                  "content": "# Atomic Data Manager Smart Select Operator"
                },
                {
                  "lineNumber": 372,
                  "content": "class ATOMIC_OT_smart_select(bpy.types.Operator):"
                },
                {
                  "lineNumber": 374,
                  "content": "    bl_idname = \"atomic.smart_select\""
                },
                {
                  "lineNumber": 375,
                  "content": "    bl_label = \"Smart Select\""
                },
                {
                  "lineNumber": 445,
                  "content": "    ATOMIC_OT_clean,"
                },
                {
                  "lineNumber": 447,
                  "content": "    ATOMIC_OT_smart_select,"
                }
              ]
            },
            {
              "file": "ops/direct_use_ops.py",
              "matches": [
                {
                  "lineNumber": 26,
                  "content": "ops.utils.clean.py into operators so they can be easily called by other"
                },
                {
                  "lineNumber": 37,
                  "content": "from .utils import clean"
                },
                {
                  "lineNumber": 149,
                  "content": "# Atomic Data Manager Clean All Operator"
                },
                {
                  "lineNumber": 150,
                  "content": "class ATOMIC_OT_clean_all(bpy.types.Operator):"
                },
                {
                  "lineNumber": 152,
                  "content": "    bl_idname = \"atomic.clean_all\""
                },
                {
                  "lineNumber": 153,
                  "content": "    bl_label = \"Clean All\""
                },
                {
                  "lineNumber": 238,
                  "content": "        clean.collections()"
                },
                {
                  "lineNumber": 239,
                  "content": "        clean.images()"
                },
                {
                  "lineNumber": 240,
                  "content": "        clean.lights()"
                },
                {
                  "lineNumber": 241,
                  "content": "        clean.materials()"
                },
                {
                  "lineNumber": 242,
                  "content": "        clean.node_groups()"
                },
                {
                  "lineNumber": 243,
                  "content": "        clean.particles()"
                },
                {
                  "lineNumber": 244,
                  "content": "        clean.textures()"
                },
                {
                  "lineNumber": 245,
                  "content": "        clean.worlds()"
                },
                {
                  "lineNumber": 504,
                  "content": "# Atomic Data Manager Clean Collections Operator"
                },
                {
                  "lineNumber": 505,
                  "content": "class ATOMIC_OT_clean_collections(bpy.types.Operator):"
                },
                {
                  "lineNumber": 507,
                  "content": "    bl_idname = \"atomic.clean_collections\""
                },
                {
                  "lineNumber": 508,
                  "content": "    bl_label = \"Clean Collections\""
                },
                {
                  "lineNumber": 527,
                  "content": "        clean.collections()"
                },
                {
                  "lineNumber": 536,
                  "content": "# Atomic Data Manager Clean Images Operator"
                },
                {
                  "lineNumber": 537,
                  "content": "class ATOMIC_OT_clean_images(bpy.types.Operator):"
                },
                {
                  "lineNumber": 539,
                  "content": "    bl_idname = \"atomic.clean_images\""
                },
                {
                  "lineNumber": 540,
                  "content": "    bl_label = \"Clean Images\""
                },
                {
                  "lineNumber": 559,
                  "content": "        clean.images()"
                },
                {
                  "lineNumber": 568,
                  "content": "# Atomic Data Manager Clean Lights Operator"
                },
                {
                  "lineNumber": 569,
                  "content": "class ATOMIC_OT_clean_lights(bpy.types.Operator):"
                },
                {
                  "lineNumber": 571,
                  "content": "    bl_idname = \"atomic.clean_lights\""
                },
                {
                  "lineNumber": 572,
                  "content": "    bl_label = \"Clean Lights\""
                },
                {
                  "lineNumber": 591,
                  "content": "        clean.lights()"
                },
                {
                  "lineNumber": 600,
                  "content": "# Atomic Data Manager Clean Materials Operator"
                },
                {
                  "lineNumber": 601,
                  "content": "class ATOMIC_OT_clean_materials(bpy.types.Operator):"
                },
                {
                  "lineNumber": 603,
                  "content": "    bl_idname = \"atomic.clean_materials\""
                },
                {
                  "lineNumber": 604,
                  "content": "    bl_label = \"Clean Materials\""
                },
                {
                  "lineNumber": 623,
                  "content": "        clean.materials()"
                },
                {
                  "lineNumber": 632,
                  "content": "# Atomic Data Manager Clean Node Groups Operator"
                },
                {
                  "lineNumber": 633,
                  "content": "class ATOMIC_OT_clean_node_groups(bpy.types.Operator):"
                },
                {
                  "lineNumber": 635,
                  "content": "    bl_idname = \"atomic.clean_node_groups\""
                },
                {
                  "lineNumber": 636,
                  "content": "    bl_label = \"Clean Node Groups\""
                },
                {
                  "lineNumber": 655,
                  "content": "        clean.node_groups()"
                },
                {
                  "lineNumber": 664,
                  "content": "# Atomic Data Manager Clean Particles Operator"
                },
                {
                  "lineNumber": 665,
                  "content": "class ATOMIC_OT_clean_particles(bpy.types.Operator):"
                },
                {
                  "lineNumber": 667,
                  "content": "    bl_idname = \"atomic.clean_particles\""
                },
                {
                  "lineNumber": 668,
                  "content": "    bl_label = \"Clean Particles\""
                },
                {
                  "lineNumber": 687,
                  "content": "        clean.particles()"
                },
                {
                  "lineNumber": 696,
                  "content": "# Atomic Data Manager Clean Textures Operator"
                },
                {
                  "lineNumber": 697,
                  "content": "class ATOMIC_OT_clean_textures(bpy.types.Operator):"
                },
                {
                  "lineNumber": 699,
                  "content": "    bl_idname = \"atomic.clean_textures\""
                },
                {
                  "lineNumber": 700,
                  "content": "    bl_label = \"Clean Textures\""
                },
                {
                  "lineNumber": 719,
                  "content": "        clean.textures()"
                },
                {
                  "lineNumber": 728,
                  "content": "# Atomic Data Manager Clean Worlds Operator"
                },
                {
                  "lineNumber": 729,
                  "content": "class ATOMIC_OT_clean_worlds(bpy.types.Operator):"
                },
                {
                  "lineNumber": 731,
                  "content": "    bl_idname = \"atomic.clean_worlds\""
                },
                {
                  "lineNumber": 732,
                  "content": "    bl_label = \"Clean Worlds\""
                },
                {
                  "lineNumber": 751,
                  "content": "        clean.worlds()"
                },
                {
                  "lineNumber": 764,
                  "content": "    ATOMIC_OT_clean_all,"
                },
                {
                  "lineNumber": 775,
                  "content": "    ATOMIC_OT_clean_collections,"
                },
                {
                  "lineNumber": 776,
                  "content": "    ATOMIC_OT_clean_images,"
                },
                {
                  "lineNumber": 777,
                  "content": "    ATOMIC_OT_clean_lights,"
                },
                {
                  "lineNumber": 778,
                  "content": "    ATOMIC_OT_clean_materials,"
                },
                {
                  "lineNumber": 779,
                  "content": "    ATOMIC_OT_clean_node_groups,"
                },
                {
                  "lineNumber": 780,
                  "content": "    ATOMIC_OT_clean_particles,"
                },
                {
                  "lineNumber": 781,
                  "content": "    ATOMIC_OT_clean_textures,"
                },
                {
                  "lineNumber": 782,
                  "content": "    ATOMIC_OT_clean_worlds"
                }
              ]
            },
            {
              "file": "ops/utils/clean.py",
              "matches": [
                {
                  "lineNumber": 21,
                  "content": "This file contains functions for cleaning out specific data categories."
                }
              ]
            },
            {
              "file": ".specstory/history/2025-12-16_23-24Z-blender-library-packed-files-error.md",
              "matches": [
                {
                  "lineNumber": 66,
                  "content": "ℹ️  blenderkit: No temporarily enabled addons to clean up [16:23:09.996, download.py:391]"
                },
                {
                  "lineNumber": 111,
                  "content": "ℹ️  blenderkit: No temporarily enabled addons to clean up [16:23:13.817, download.py:391]"
                },
                {
                  "lineNumber": 2768,
                  "content": "        \"contents\": \"schema_version = \\\"1.0.0\\\"\\n\\nid = \\\"atomic_data_manager\\\"\\nname = \\\"Atomic Data Manager\\\"\\nversion = \\\"2.0.0\\\"\\ntype = \\\"add-on\\\"\\nauthor = \\\"RaincloudTheDragon\\\"\\nmaintainer = \\\"RaincloudTheDragon\\\"\\nblender_version_min = \\\"4.2.0\\\"\\nlicense = [\\\"GPL-3.0-or-later\\\"]\\ndescription = \\\"An Intelligent Data Manager for Blender.\\\"\\nhomepage = \\\"https://github.com/grantwilk/atomic-data-manager\\\"\\ntagline = \\\"Smart cleanup and inspection of Blender data-blocks\\\"\\n\\ntags = [\\\"utility\\\", \\\"management\\\", \\\"cleanup\\\"]\\n\\n# Python modules to load for this add-on\\nmodules = [\\\"atomic_data_manager\\\"]\","
                },
                {
                  "lineNumber": 2819,
                  "content": "            \"text\": \"tagline = \\\"Smart cleanup and inspection of Blender data-blocks\\\"\","
                },
                {
                  "lineNumber": 2826,
                  "content": "            \"text\": \"tags = [\\\"utility\\\", \\\"management\\\", \\\"cleanup\\\"]\","
                },
                {
                  "lineNumber": 6993,
                  "content": "The addon should now unregister cleanly in Blender 4.5 without errors. The &#96;safe_unregister_class&#96; function handles edge cases where classes may not be registered or were already unregistered."
                },
                {
                  "lineNumber": 7122,
                  "content": "              \"file\": \"ops/utils/clean.py\""
                },
                {
                  "lineNumber": 7704,
                  "content": "        \"contents\": \"schema_version = \\\"1.0.0\\\"\\n\\nid = \\\"atomic_data_manager\\\"\\nname = \\\"Atomic Data Manager\\\"\\nversion = \\\"2.0.1\\\"\\ntype = \\\"add-on\\\"\\nauthor = \\\"RaincloudTheDragon\\\"\\nmaintainer = \\\"RaincloudTheDragon\\\"\\nblender_version_min = \\\"4.2.0\\\"\\nlicense = [\\\"GPL-3.0-or-later\\\"]\\ndescription = \\\"An Intelligent Data Manager for Blender.\\\"\\nhomepage = \\\"https://github.com/grantwilk/atomic-data-manager\\\"\\ntagline = \\\"Smart cleanup and inspection of Blender data-blocks\\\"\\n\\ntags = [\\\"utility\\\", \\\"management\\\", \\\"cleanup\\\"]\\n\\n# Python modules to load for this add-on\\nmodules = [\\\"atomic_data_manager\\\"]\","
                },
                {
                  "lineNumber": 7755,
                  "content": "            \"text\": \"tagline = \\\"Smart cleanup and inspection of Blender data-blocks\\\"\","
                },
                {
                  "lineNumber": 7762,
                  "content": "            \"text\": \"tags = [\\\"utility\\\", \\\"management\\\", \\\"cleanup\\\"]\","
                },
                {
                  "lineNumber": 13035,
                  "content": "        \"contents\": \"class ATOMIC_OT_nuke(bpy.types.Operator):\\n\\n\\n    def execute(self, context):\\n        atom = bpy.context.scene.atomic\\n\\n        if atom.collections:\\n            nuke.collections()\\n\\n        if atom.images:\\n            nuke.images()\\n\\n        if atom.lights:\\n            nuke.lights()\\n\\n        if atom.materials:\\n            nuke.materials()\\n\\n        if atom.node_groups:\\n            nuke.node_groups()\\n\\n        if atom.particles:\\n            nuke.particles()\\n\\n        if atom.textures:\\n            nuke.textures()\\n\\n        if atom.worlds:\\n            nuke.worlds()\\n\\n        bpy.ops.atomic.deselect_all()\\n\\n        return {'FINISHED'}\\n\\n    def invoke(self, context, event):\\n        wm = context.window_manager\\n        return wm.invoke_props_dialog(self)\\n\\n\\n# Atomic Data Manager Clean Operator\\nclass ATOMIC_OT_clean(bpy.types.Operator):\\n    \\\"\\\"\\\"Remove all unused data-blocks from the selected categories\\\"\\\"\\\"\","
                },
                {
                  "lineNumber": 13195,
                  "content": "            \"text\": \"# Atomic Data Manager Clean Operator\","
                },
                {
                  "lineNumber": 13199,
                  "content": "            \"text\": \"class ATOMIC_OT_clean(bpy.types.Operator):\","
                },
                {
                  "lineNumber": 13223,
                  "content": "        \"contents\": \"# Atomic Data Manager Main Panel\\nclass ATOMIC_PT_main_panel(bpy.types.Panel):\\n    \\\"\\\"\\\"The main Atomic Data Manager panel\\\"\\\"\\\"\\n    bl_label = \\\"Atomic Data Manager\\\"\\n    bl_space_type = \\\"PROPERTIES\\\"\\n    bl_region_type = \\\"WINDOW\\\"\\n    bl_context = \\\"scene\\\"\\n\\n    def draw(self, context):\\n        layout = self.layout\\n        atom = bpy.context.scene.atomic\\n        category_props = [\\n            atom.collections,\\n            atom.images,\\n            atom.lights,\\n            atom.materials,\\n            atom.node_groups,\\n            atom.particles,\\n            atom.textures,\\n            atom.worlds\\n        ]\\n\\n        # nuke and clean buttons\\n        row = layout.row(align=True)\\n        row.scale_y = 2.0\\n        row.operator(\\\"atomic.nuke\\\", text=\\\"Nuke\\\", icon=\\\"GHOST_ENABLED\\\")\\n        row.operator(\\\"atomic.clean\\\", text=\\\"Clean\\\", icon=\\\"PARTICLEMODE\\\")\\n        row.operator(\\\"atomic.undo\\\", text=\\\"Undo\\\", icon=\\\"LOOP_BACK\\\")\\n\\n        r"
                },
                {
                  "lineNumber": 13314,
                  "content": "            \"text\": \"        # nuke and clean buttons\","
                },
                {
                  "lineNumber": 13330,
                  "content": "            \"text\": \"        row.operator(\\\"atomic.clean\\\", text=\\\"Clean\\\", icon=\\\"PARTICLEMODE\\\")\","
                },
                {
                  "lineNumber": 13835,
                  "content": "        \"contents\": \"class ATOMIC_OT_nuke_all(bpy.types.Operator):\\ndef draw(self, context):\\n\\n        ui_layouts.box_list(\\n            layout=layout,\\n            title=\\\"Worlds\\\",\\n            items=worlds,\\n            icon=\\\"WORLD\\\"\\n        )\\n\\n        row = layout.row()  # extra spacing\\n\\n    def execute(self, context):\\n\\n        nuke.collections()\\n        nuke.images()\\n        nuke.lights()\\n        nuke.materials()\\n        nuke.node_groups()\\n        nuke.particles()\\n        nuke.textures()\\n        nuke.worlds()\\n\\n        return {'FINISHED'}\\n\\n    def invoke(self, context, event):\\n        wm = context.window_manager\\n        return wm.invoke_props_dialog(self)\\n\\n\\n# Atomic Data Manager Clean All Operator\\nclass ATOMIC_OT_clean_all(bpy.types.Operator):\\n    \\\"\\\"\\\"Remove all unused data-blocks from the selected categories\\\"\\\"\\\"\","
                },
                {
                  "lineNumber": 13976,
                  "content": "            \"text\": \"# Atomic Data Manager Clean All Operator\","
                },
                {
                  "lineNumber": 13980,
                  "content": "            \"text\": \"class ATOMIC_OT_clean_all(bpy.types.Operator):\","
                },
                {
                  "lineNumber": 14503,
                  "content": "        \"contents\": \"class ATOMIC_OT_clean(bpy.types.Operator):\\n\\n\\n    def execute(self, context):\\n        atom = bpy.context.scene.atomic\\n\\n        if atom.collections:\\n            clean.collections()\\n\\n        if atom.images:\\n            clean.images()\\n\\n        if atom.lights:\\n            clean.lights()\\n\\n        if atom.materials:\\n            clean.materials()\\n\\n        if atom.node_groups:\\n            clean.node_groups()\\n\\n        if atom.particles:\\n            clean.particles()\\n\\n        if atom.textures:\\n            clean.textures()\\n\\n        if atom.worlds:\\n            clean.worlds()\\n\\n        bpy.ops.atomic.deselect_all()\\n\\n        return {'FINISHED'}\\n\\n    def invoke(self, context, event):\\n        wm = context.window_manager\\n        atom = bpy.context.scene.atomic\\n\\n        if atom.collections:\\n            self.unused_collections = unused.collections_deep()\\n\\n        if atom.images:\\n            self.unused_images = unused.images_deep()\\n\\n        i"
                },
                {
                  "lineNumber": 14520,
                  "content": "            \"text\": \"class ATOMIC_OT_clean(bpy.types.Operator):\","
                },
                {
                  "lineNumber": 14546,
                  "content": "            \"text\": \"            clean.collections()\","
                },
                {
                  "lineNumber": 14557,
                  "content": "            \"text\": \"            clean.images()\","
                },
                {
                  "lineNumber": 14568,
                  "content": "            \"text\": \"            clean.lights()\","
                },
                {
                  "lineNumber": 14579,
                  "content": "            \"text\": \"            clean.materials()\","
                },
                {
                  "lineNumber": 14590,
                  "content": "            \"text\": \"            clean.node_groups()\","
                },
                {
                  "lineNumber": 14601,
                  "content": "            \"text\": \"            clean.particles()\","
                },
                {
                  "lineNumber": 14612,
                  "content": "            \"text\": \"            clean.textures()\","
                },
                {
                  "lineNumber": 14623,
                  "content": "            \"text\": \"            clean.worlds()\","
                },
                {
                  "lineNumber": 14786,
                  "content": "        \"contents\": \"# Atomic Data Manager Clean Operator\\nclass ATOMIC_OT_clean(bpy.types.Operator):\\n    \\\"\\\"\\\"Remove all unused data-blocks from the selected categories\\\"\\\"\\\"\\n    bl_idname = \\\"atomic.clean\\\"\\n    bl_label = \\\"Clean\\\"\\n\\n    unused_collections = []\\n    unused_images = []\\n    unused_lights = []\\n    unused_materials = []\\n    unused_node_groups = []\\n    unused_particles = []\\n    unused_textures = []\\n    unused_worlds = []\\n\\n    def draw(self, context):\\n        atom = bpy.context.scene.atomic\\n        layout = self.layout\\n\\n        col = layout.column()\\n        col.label(text=\\\"Remove the following data-blocks?\\\")\\n\\n        # display if no main panel properties are toggled\\n        if not (atom.collections or atom.images or atom.lights or\\n                atom.materials or atom.node_groups or atom.particles\\n                or atom.textures or atom.worlds):\\n\\n            ui_layouts.box_list(\\n                layout=layout,\\n            )\\n\\n        # displa"
                },
                {
                  "lineNumber": 14790,
                  "content": "            \"text\": \"# Atomic Data Manager Clean Operator\","
                },
                {
                  "lineNumber": 14794,
                  "content": "            \"text\": \"class ATOMIC_OT_clean(bpy.types.Operator):\","
                },
                {
                  "lineNumber": 14803,
                  "content": "            \"text\": \"    bl_idname = \\\"atomic.clean\\\"\","
                },
                {
                  "lineNumber": 14807,
                  "content": "            \"text\": \"    bl_label = \\\"Clean\\\"\","
                },
                {
                  "lineNumber": 15498,
                  "content": "        \"contents\": \"# Atomic Data Manager Smart Select Operator\\nclass ATOMIC_OT_smart_select(bpy.types.Operator):\\n    \\\"\\\"\\\"Auto-select categories with unused data\\\"\\\"\\\"\\n    bl_idname = \\\"atomic.smart_select\\\"\\n    bl_label = \\\"Smart Select\\\"\\n\\n    def execute(self, context):\\n\\n        bpy.context.scene.atomic.collections = \\\\\\n            any(unused.collections_deep())\\n\\n        bpy.context.scene.atomic.images = \\\\\\n            any(unused.images_deep())\\n\\n        bpy.context.scene.atomic.lights = \\\\\\n            any(unused.lights_deep())\\n\\n        bpy.context.scene.atomic.materials = \\\\\\n            any(unused.materials_deep())\\n\\n        bpy.context.scene.atomic.node_groups = \\\\\\n            any(unused.node_groups_deep())\\n\\n        bpy.context.scene.atomic.particles = \\\\\\n            any(unused.particles_deep())\\n\\n        bpy.context.scene.atomic.textures = \\\\\\n            any(unused.textures_deep())\\n\\n        bpy.context.scene.atomic.worlds = \\\\\\n            any(unused.w"
                },
                {
                  "lineNumber": 15502,
                  "content": "            \"text\": \"# Atomic Data Manager Smart Select Operator\","
                },
                {
                  "lineNumber": 15506,
                  "content": "            \"text\": \"class ATOMIC_OT_smart_select(bpy.types.Operator):\","
                },
                {
                  "lineNumber": 15515,
                  "content": "            \"text\": \"    bl_idname = \\\"atomic.smart_select\\\"\","
                },
                {
                  "lineNumber": 15519,
                  "content": "            \"text\": \"    bl_label = \\\"Smart Select\\\"\","
                },
                {
                  "lineNumber": 15660,
                  "content": "        \"contents\": \"# Atomic Data Manager Clean All Operator\\nclass ATOMIC_OT_clean_all(bpy.types.Operator):\\n    \\\"\\\"\\\"Remove all unused data-blocks from the selected categories\\\"\\\"\\\"\\n    bl_idname = \\\"atomic.clean_all\\\"\\n    bl_label = \\\"Clean All\\\"\\n\\n    unused_collections = []\\n    unused_images = []\\n    unused_lights = []\\n    unused_materials = []\\n    unused_node_groups = []\\n    unused_particles = []\\n    unused_textures = []\\n    unused_worlds = []\\n\\n    def draw(self, context):\\n        layout = self.layout\\n\\n        col = layout.column()\\n        col.label(text=\\\"Remove the following data-blocks?\\\")\\n\\n        collections = sorted(unused.collections_deep())\\n        ui_layouts.box_list(\\n            layout=layout,\\n            title=\\\"Collections\\\",\\n            items=collections,\\n            icon=\\\"OUTLINER_OB_GROUP_INSTANCE\\\"\\n        )\\n\\n        images = sorted(unused.images_deep())\\n        ui_layouts.box_list(\\n            layout=layout,\\n            title=\\\"Ima"
                },
                {
                  "lineNumber": 15664,
                  "content": "            \"text\": \"# Atomic Data Manager Clean All Operator\","
                },
                {
                  "lineNumber": 15668,
                  "content": "            \"text\": \"class ATOMIC_OT_clean_all(bpy.types.Operator):\","
                },
                {
                  "lineNumber": 15677,
                  "content": "            \"text\": \"    bl_idname = \\\"atomic.clean_all\\\"\","
                },
                {
                  "lineNumber": 15681,
                  "content": "            \"text\": \"    bl_label = \\\"Clean All\\\"\","
                },
                {
                  "lineNumber": 17664,
                  "content": "        \"contents\": \"class ATOMIC_OT_clean_all(bpy.types.Operator):\\ndef draw(self, context):\\n\\n        ui_layouts.box_list(\\n            layout=layout,\\n            title=\\\"Textures\\\",\\n            items=textures,\\n            icon=\\\"TEXTURE\\\"\\n        )\\n\\n        worlds = sorted(unused.worlds())\\n        ui_layouts.box_list(\\n            layout=layout,\\n            title=\\\"Worlds\\\",\\n            items=worlds,\\n            icon=\\\"WORLD\\\"\\n        )\\n\\n        row = layout.row()  # extra spacing\\n\\n    def execute(self, context):\\n\\n        clean.collections()\\n        clean.images()\\n        clean.lights()\\n        clean.materials()\\n        clean.node_groups()\\n        clean.particles()\\n        clean.textures()\\n        clean.worlds()\\n\\n        return {'FINISHED'}\\n\\n    def invoke(self, context, event):\\n        wm = context.window_manager\\n\\n        self.unused_collections = unused.collections_deep()\\n        self.unused_images = unused.images_deep()\\n        self.unused_lights"
                },
                {
                  "lineNumber": 17691,
                  "content": "            \"text\": \"class ATOMIC_OT_clean_all(bpy.types.Operator):\","
                },
                {
                  "lineNumber": 17775,
                  "content": "            \"text\": \"        clean.collections()\","
                },
                {
                  "lineNumber": 17779,
                  "content": "            \"text\": \"        clean.images()\","
                },
                {
                  "lineNumber": 17783,
                  "content": "            \"text\": \"        clean.lights()\","
                },
                {
                  "lineNumber": 17787,
                  "content": "            \"text\": \"        clean.materials()\","
                },
                {
                  "lineNumber": 17791,
                  "content": "            \"text\": \"        clean.node_groups()\","
                },
                {
                  "lineNumber": 17795,
                  "content": "            \"text\": \"        clean.particles()\","
                },
                {
                  "lineNumber": 17799,
                  "content": "            \"text\": \"        clean.textures()\","
                },
                {
                  "lineNumber": 17803,
                  "content": "            \"text\": \"        clean.worlds()\","
                },
                {
                  "lineNumber": 18839,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **read_file_v2** • Read file: E:\\atomic_data_manager\\ops\\utils\\clean.py&lt;/summary&gt;"
                },
                {
                  "lineNumber": 18923,
                  "content": "- [ ] Add library/override filtering to ops/utils/clean.py"
                },
                {
                  "lineNumber": 20435,
                  "content": "- [x] Add library/override filtering to ops/utils/clean.py"
                },
                {
                  "lineNumber": 20567,
                  "content": "   - &#96;ops/utils/clean.py&#96; - Clean operations already use unused functions (which now filter)"
                },
                {
                  "lineNumber": 20650,
                  "content": "The output looks clean now. I see:"
                },
                {
                  "lineNumber": 20652,
                  "content": "1. No more \"has been registered before\" messages for atomic_data_manager classes — registration is clean."
                },
                {
                  "lineNumber": 20665,
                  "content": "The addon is now loading cleanly in Blender 5.0 without registration conflicts. The library/override filtering changes are active and working."
                },
                {
                  "lineNumber": 20881,
                  "content": "                  \"content\": \"        description=\\\"Enable the Atomic pie menu UI, so you can clean \\\"\""
                },
                {
                  "lineNumber": 21067,
                  "content": "                  \"content\": \"        ).name = \\\"ATOMIC_MT_clean_pie\\\"\""
                },
                {
                  "lineNumber": 21119,
                  "content": "                  \"content\": \"# Atomic Data Manager Clean Pie Menu\""
                },
                {
                  "lineNumber": 21123,
                  "content": "                  \"content\": \"class ATOMIC_MT_clean_pie(bpy.types.Menu):\""
                },
                {
                  "lineNumber": 21127,
                  "content": "                  \"content\": \"    bl_idname = \\\"ATOMIC_MT_clean_pie\\\"\""
                },
                {
                  "lineNumber": 21135,
                  "content": "                  \"content\": \"        pie.operator(\\\"atomic.clean_node_groups\\\", icon=\\\"NODETREE\\\")\""
                },
                {
                  "lineNumber": 21139,
                  "content": "                  \"content\": \"        pie.operator(\\\"atomic.clean_materials\\\", icon=\\\"MATERIAL\\\")\""
                },
                {
                  "lineNumber": 21143,
                  "content": "                  \"content\": \"        pie.operator(\\\"atomic.clean_worlds\\\", icon=\\\"WORLD\\\")\""
                },
                {
                  "lineNumber": 21147,
                  "content": "                  \"content\": \"        pie.operator(\\\"atomic.clean_collections\\\", icon=\\\"GROUP\\\")\""
                },
                {
                  "lineNumber": 21151,
                  "content": "                  \"content\": \"        pie.operator(\\\"atomic.clean_lights\\\", icon=\\\"LIGHT\\\")\""
                },
                {
                  "lineNumber": 21155,
                  "content": "                  \"content\": \"        pie.operator(\\\"atomic.clean_images\\\", icon=\\\"IMAGE_DATA\\\")\""
                },
                {
                  "lineNumber": 21159,
                  "content": "                  \"content\": \"        pie.operator(\\\"atomic.clean_textures\\\", icon=\\\"TEXTURE\\\")\""
                },
                {
                  "lineNumber": 21163,
                  "content": "                  \"content\": \"        pie.operator(\\\"atomic.clean_particles\\\", icon=\\\"PARTICLES\\\")\""
                },
                {
                  "lineNumber": 21223,
                  "content": "                  \"content\": \"    ATOMIC_MT_clean_pie,\""
                },
                {
                  "lineNumber": 21275,
                  "content": "2. Pie menu warnings — the nuke, clean, and inspect pie menus each have 8 items. The warning says \"more than 8 items are currently unsupported\", so 8 should be fine, but Blender 5.0 may have changed the limit or the warning is overly strict. These are warnings, not errors; the menus should still work."
                },
                {
                  "lineNumber": 21277,
                  "content": "3. \"Info: Deleted 117 data-block(s)\" — normal if you ran a nuke/clean operation. The library/override filtering should have excluded library datablocks."
                },
                {
                  "lineNumber": 22389,
                  "content": "&lt;details&gt;&lt;summary&gt;Tool use: **read_file_v2** • Read file: E:\\atomic_data_manager\\ops\\utils\\clean.py&lt;/summary&gt;"
                },
                {
                  "lineNumber": 22407,
                  "content": "&#96;ops/utils/clean.py&#96; doesn't need &#96;compat&#96; because it uses the &#96;unused&#96; functions, which already filter library/override datablocks."
                }
              ]
            },
            {
              "file": "blender_manifest.toml",
              "matches": [
                {
                  "lineNumber": 13,
                  "content": "tagline = \"Smart cleanup and inspection of Blender data-blocks\""
                },
                {
                  "lineNumber": 15,
                  "content": "tags = [\"utility\", \"management\", \"cleanup\"]"
                }
              ]
            },
            {
              "file": "README.md",
              "matches": [
                {
                  "lineNumber": 6,
                  "content": "## ENJOY A CLEANER PROJECT"
                },
                {
                  "lineNumber": 7,
                  "content": "Atomic Data Manager offers Blender artists an intelligent data management solution. This feature-packed add-on provides artists with every tool they need to keep unwanted and unused data out of their Blender files. Even better, Atomic's real-time data analysis and automated data removal tools allow its users to clean their projects in a flash."
                },
                {
                  "lineNumber": 14,
                  "content": "| Rapid Cleaning | Missing File Detection |"
                },
                {
                  "lineNumber": 16,
                  "content": "| With Atomic, you can clean your project files in a snap. Simply select a category and click the clean button. | Stop those pink textures! Atomic helps you restore missing project files before you even realize they're gone. |"
                },
                {
                  "lineNumber": 33,
                  "content": "| Keep Your Projects Clean | Reduce File Sizes | Optimize for Render Farms |"
                },
                {
                  "lineNumber": 35,
                  "content": "| Everyone appreciates a clean project. Use Atomic's intelligent toolset to keep your projects looking spiffy. | Atomic reduces file sizes by removing unused data from your projects. That way, there's more space for other stuff! | Render farms prioritize smaller projects. Atomic can optimize your files so they render sooner! |"
                }
              ]
            },
            {
              "file": "ui/main_panel_ui.py",
              "matches": [
                {
                  "lineNumber": 24,
                  "content": "This panel contains the Nuke/Clean/Undo buttons as well as the data"
                },
                {
                  "lineNumber": 58,
                  "content": "        # nuke and clean buttons"
                },
                {
                  "lineNumber": 62,
                  "content": "        row.operator(\"atomic.clean\", text=\"Clean\", icon=\"PARTICLEMODE\")"
                },
                {
                  "lineNumber": 215,
                  "content": "            \"atomic.smart_select\","
                },
                {
                  "lineNumber": 216,
                  "content": "            text='Smart Select',"
                }
              ]
            },
            {
              "file": "ui/pie_menu_ui.py",
              "matches": [
                {
                  "lineNumber": 47,
                  "content": "        # clean all operator"
                },
                {
                  "lineNumber": 49,
                  "content": "            \"atomic.clean_all\","
                },
                {
                  "lineNumber": 50,
                  "content": "            text=\"Clean All\","
                },
                {
                  "lineNumber": 75,
                  "content": "        # clean category operator"
                },
                {
                  "lineNumber": 78,
                  "content": "            text=\"Clean\","
                },
                {
                  "lineNumber": 80,
                  "content": "        ).name = \"ATOMIC_MT_clean_pie\""
                },
                {
                  "lineNumber": 117,
                  "content": "# Atomic Data Manager Clean Pie Menu"
                },
                {
                  "lineNumber": 118,
                  "content": "class ATOMIC_MT_clean_pie(bpy.types.Menu):"
                },
                {
                  "lineNumber": 119,
                  "content": "    bl_idname = \"ATOMIC_MT_clean_pie\""
                },
                {
                  "lineNumber": 120,
                  "content": "    bl_label = \"Atomic Clean\""
                },
                {
                  "lineNumber": 126,
                  "content": "        # clean node groups operator"
                },
                {
                  "lineNumber": 127,
                  "content": "        pie.operator(\"atomic.clean_node_groups\", icon=\"NODETREE\")"
                },
                {
                  "lineNumber": 129,
                  "content": "        # clean materials operator"
                },
                {
                  "lineNumber": 130,
                  "content": "        pie.operator(\"atomic.clean_materials\", icon=\"MATERIAL\")"
                },
                {
                  "lineNumber": 132,
                  "content": "        # clean worlds operator"
                },
                {
                  "lineNumber": 133,
                  "content": "        pie.operator(\"atomic.clean_worlds\", icon=\"WORLD\")"
                },
                {
                  "lineNumber": 135,
                  "content": "        # clean collections operator"
                },
                {
                  "lineNumber": 136,
                  "content": "        pie.operator(\"atomic.clean_collections\", icon=\"GROUP\")"
                },
                {
                  "lineNumber": 138,
                  "content": "        # clean lights operator"
                },
                {
                  "lineNumber": 139,
                  "content": "        pie.operator(\"atomic.clean_lights\", icon=\"LIGHT\")"
                },
                {
                  "lineNumber": 141,
                  "content": "        # clean images operator"
                },
                {
                  "lineNumber": 142,
                  "content": "        pie.operator(\"atomic.clean_images\", icon=\"IMAGE_DATA\")"
                },
                {
                  "lineNumber": 144,
                  "content": "        # clean textures operator"
                },
                {
                  "lineNumber": 145,
                  "content": "        pie.operator(\"atomic.clean_textures\", icon=\"TEXTURE\")"
                },
                {
                  "lineNumber": 147,
                  "content": "        # clean materials operator"
                },
                {
                  "lineNumber": 148,
                  "content": "        pie.operator(\"atomic.clean_particles\", icon=\"PARTICLES\")"
                },
                {
                  "lineNumber": 188,
                  "content": "    ATOMIC_MT_clean_pie,"
                }
              ]
            },
            {
              "file": "ui/preferences_ui.py",
              "matches": [
                {
                  "lineNumber": 211,
                  "content": "        description=\"Enable the Atomic pie menu UI, so you can clean \""
                }
              ]
            }
          ],
          "totalLines": 204,
          "totalMatchedLines": 204
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

Reviewing the Smart Select and Clean implementations to understand the threading issue.


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\ops\main_ops.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\unused.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\ops\utils\clean.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\.specstory\history\2025-12-16_23-24Z-blender-library-packed-files-error.md</summary>

</details>
</tool-use>

---

Checking the `users` module to understand the performance bottleneck:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "How does threading or multiprocessing work in this codebase?",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\rainys_repo_bootstrap.py",
        "range": {
          "startPosition": {
            "line": 11,
            "column": 46
          },
          "endPosition": {
            "line": 162
          }
        },
        "contents": "def ensure_rainys_extensions_repo(_deferred: bool = False) -&gt; None:\n    \"\"\"\n    Ensure the Rainy's Extensions repository is registered in Blender.\n\n    Safe to import and call from multiple add-ons; the helper guards against doing the\n    work more than once per Blender session.\n    \"\"\"\n    global _BOOTSTRAP_DONE\n\n    if _BOOTSTRAP_DONE:\n        return\n\n    _log(\"starting repository verification\")\n\n    context_class_name = type(bpy.context).__name__\n    if context_class_name == \"_RestrictContext\":\n        if _deferred:\n            _log(\"context still restricted after deferral; aborting repo check\")\n            return\n\n        _log(\"context restricted; scheduling repo check retry\")\n\n        def _retry():\n            ensure_rainys_extensions_repo(_deferred=True)\n            return None\n\n        bpy.app.timers.register(_retry, first_interval=0.5)\n        return\n\n    prefs = getattr(bpy.context, \"preferences\", None)\n    if prefs is None:\n        _log(\"no preferences available on context; skipping\")\n        return\n\n    preferences_changed = False\n    addon_prefs = None\n    addon_entry = None\n    if hasattr(getattr(prefs, \"addons\", None), \"get\"):\n        addon_entry = prefs.addons.get(__name__)\n    elif hasattr(prefs, \"addons\"):\n        try:\n            addon_entry = prefs.addons[__name__]\n        except Exception:\n            addon_entry = None\n    if addon_entry:\n        addon_prefs = getattr(addon_entry, \"preferences\", None)\n    addon_repo_initialized = bool(\n        addon_prefs and getattr(addon_prefs, \"repo_initialized\", False)\n    )\n\n    experimental = getattr(prefs, \"experimental\", None)\n    if experimental and hasattr(experimental, \"use_extension_platform\"):\n        if not experimental.use_extension_platform:\n            experimental.use_extension_platform = True\n            preferences_changed = True\n            _log(\"enabled experimental extension platform\")\n\n    repositories = None\n    extensions_obj = getattr(prefs, \"extensions\", None)\n    if extensions_obj:\n        if hasattr(extensions_obj, \"repos\"):",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def ensure_rainys_extensions_repo(_deferred: bool = False) -&gt; None:",
            "lineNumber": 15,
            "isSignature": true
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 16
          },
          {
            "text": "    Ensure the Rainy's Extensions repository is registered in Blender.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "    Safe to import and call from multiple add-ons; the helper guards against doing the",
            "lineNumber": 19
          },
          {
            "text": "    work more than once per Blender session.",
            "lineNumber": 20
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 21
          },
          {
            "text": "    global _BOOTSTRAP_DONE",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "    if _BOOTSTRAP_DONE:",
            "lineNumber": 24
          },
          {
            "text": "        return",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "    _log(\"starting repository verification\")",
            "lineNumber": 27
          },
          {
            "lineNumber": 28
          },
          {
            "text": "    context_class_name = type(bpy.context).__name__",
            "lineNumber": 29
          },
          {
            "text": "    if context_class_name == \"_RestrictContext\":",
            "lineNumber": 30
          },
          {
            "text": "        if _deferred:",
            "lineNumber": 31
          },
          {
            "text": "            _log(\"context still restricted after deferral; aborting repo check\")",
            "lineNumber": 32
          },
          {
            "text": "            return",
            "lineNumber": 33
          },
          {
            "lineNumber": 34
          },
          {
            "text": "        _log(\"context restricted; scheduling repo check retry\")",
            "lineNumber": 35
          },
          {
            "lineNumber": 36
          },
          {
            "text": "        def _retry():",
            "lineNumber": 37
          },
          {
            "text": "            ensure_rainys_extensions_repo(_deferred=True)",
            "lineNumber": 38
          },
          {
            "text": "            return None",
            "lineNumber": 39
          },
          {
            "lineNumber": 40
          },
          {
            "text": "        bpy.app.timers.register(_retry, first_interval=0.5)",
            "lineNumber": 41
          },
          {
            "text": "        return",
            "lineNumber": 42
          },
          {
            "lineNumber": 43
          },
          {
            "text": "    prefs = getattr(bpy.context, \"preferences\", None)",
            "lineNumber": 44
          },
          {
            "text": "    if prefs is None:",
            "lineNumber": 45
          },
          {
            "text": "        _log(\"no preferences available on context; skipping\")",
            "lineNumber": 46
          },
          {
            "text": "        return",
            "lineNumber": 47
          },
          {
            "lineNumber": 48
          },
          {
            "text": "    preferences_changed = False",
            "lineNumber": 49
          },
          {
            "text": "    addon_prefs = None",
            "lineNumber": 50
          },
          {
            "text": "    addon_entry = None",
            "lineNumber": 51
          },
          {
            "text": "    if hasattr(getattr(prefs, \"addons\", None), \"get\"):",
            "lineNumber": 52
          },
          {
            "text": "        addon_entry = prefs.addons.get(__name__)",
            "lineNumber": 53
          },
          {
            "text": "    elif hasattr(prefs, \"addons\"):",
            "lineNumber": 54
          },
          {
            "text": "        try:",
            "lineNumber": 55
          },
          {
            "text": "            addon_entry = prefs.addons[__name__]",
            "lineNumber": 56
          },
          {
            "text": "        except Exception:",
            "lineNumber": 57
          },
          {
            "text": "            addon_entry = None",
            "lineNumber": 58
          },
          {
            "text": "    if addon_entry:",
            "lineNumber": 59
          },
          {
            "text": "        addon_prefs = getattr(addon_entry, \"preferences\", None)",
            "lineNumber": 60
          },
          {
            "text": "    addon_repo_initialized = bool(",
            "lineNumber": 61
          },
          {
            "text": "        addon_prefs and getattr(addon_prefs, \"repo_initialized\", False)",
            "lineNumber": 62
          },
          {
            "text": "    )",
            "lineNumber": 63
          },
          {
            "lineNumber": 64
          },
          {
            "text": "    experimental = getattr(prefs, \"experimental\", None)",
            "lineNumber": 65
          },
          {
            "text": "    if experimental and hasattr(experimental, \"use_extension_platform\"):",
            "lineNumber": 66
          },
          {
            "text": "        if not experimental.use_extension_platform:",
            "lineNumber": 67
          },
          {
            "text": "            experimental.use_extension_platform = True",
            "lineNumber": 68
          },
          {
            "text": "            preferences_changed = True",
            "lineNumber": 69
          },
          {
            "text": "            _log(\"enabled experimental extension platform\")",
            "lineNumber": 70
          },
          {
            "lineNumber": 71
          },
          {
            "text": "    repositories = None",
            "lineNumber": 72
          },
          {
            "text": "    extensions_obj = getattr(prefs, \"extensions\", None)",
            "lineNumber": 73
          },
          {
            "text": "    if extensions_obj:",
            "lineNumber": 74
          },
          {
            "text": "        if hasattr(extensions_obj, \"repos\"):",
            "lineNumber": 75
          }
        ]
      },
      "score": 0.08709924668073654
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {
            "line": 36
          },
          "endPosition": {
            "line": 356
          }
        },
        "contents": "class ATOMIC_OT_nuke(bpy.types.Operator):\ndef draw(self, context):\n\n\n        # display when the main panel textures property is toggled\n        if atom.textures:\n            from ..utils import compat\n            textures = sorted([t.name for t in bpy.data.textures \n                              if not compat.is_library_or_override(t)])\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Textures\",\n                items=textures,\n                icon=\"TEXTURE\"\n            )\n\n        # display when the main panel worlds property is toggled\n        if atom.worlds:\n            from ..utils import compat\n            worlds = sorted([w.name for w in bpy.data.worlds \n                           if not compat.is_library_or_override(w)])\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Worlds\",\n                items=worlds,\n                icon=\"WORLD\"\n            )\n\n        row = layout.row()  # extra spacing\n\n    def execute(self, context):\n        atom = bpy.context.scene.atomic\n\n        if atom.collections:\n            nuke.collections()\n\n        if atom.images:\n            nuke.images()\n\n        if atom.lights:\n            nuke.lights()\n\n        if atom.materials:\n            nuke.materials()\n\n        if atom.node_groups:\n            nuke.node_groups()\n\n        if atom.particles:\n            nuke.particles()\n\n        if atom.textures:\n            nuke.textures()\n\n        if atom.worlds:\n            nuke.worlds()\n\n        bpy.ops.atomic.deselect_all()\n\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Operator\nclass ATOMIC_OT_clean(bpy.types.Operator):\n    \"\"\"Remove all unused data-blocks from the selected categories\"\"\"",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 37,
                "column": 1
              },
              "endPosition": {
                "line": 38,
                "column": 5
              }
            },
            {
              "startPosition": {
                "line": 42,
                "column": 5
              },
              "endPosition": {
                "line": 43,
                "column": 9
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_OT_nuke(bpy.types.Operator):",
            "lineNumber": 37,
            "isSignature": true
          },
          {
            "text": "def draw(self, context):",
            "lineNumber": 42
          },
          {
            "lineNumber": 128
          },
          {
            "lineNumber": 129
          },
          {
            "text": "        # display when the main panel textures property is toggled",
            "lineNumber": 130
          },
          {
            "text": "        if atom.textures:",
            "lineNumber": 131
          },
          {
            "text": "            from ..utils import compat",
            "lineNumber": 132
          },
          {
            "text": "            textures = sorted([t.name for t in bpy.data.textures ",
            "lineNumber": 133
          },
          {
            "text": "                              if not compat.is_library_or_override(t)])",
            "lineNumber": 134
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 135
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 136
          },
          {
            "text": "                title=\"Textures\",",
            "lineNumber": 137
          },
          {
            "text": "                items=textures,",
            "lineNumber": 138
          },
          {
            "text": "                icon=\"TEXTURE\"",
            "lineNumber": 139
          },
          {
            "text": "            )",
            "lineNumber": 140
          },
          {
            "lineNumber": 141
          },
          {
            "text": "        # display when the main panel worlds property is toggled",
            "lineNumber": 142
          },
          {
            "text": "        if atom.worlds:",
            "lineNumber": 143
          },
          {
            "text": "            from ..utils import compat",
            "lineNumber": 144
          },
          {
            "text": "            worlds = sorted([w.name for w in bpy.data.worlds ",
            "lineNumber": 145
          },
          {
            "text": "                           if not compat.is_library_or_override(w)])",
            "lineNumber": 146
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 147
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 148
          },
          {
            "text": "                title=\"Worlds\",",
            "lineNumber": 149
          },
          {
            "text": "                items=worlds,",
            "lineNumber": 150
          },
          {
            "text": "                icon=\"WORLD\"",
            "lineNumber": 151
          },
          {
            "text": "            )",
            "lineNumber": 152
          },
          {
            "lineNumber": 153
          },
          {
            "text": "        row = layout.row()  # extra spacing",
            "lineNumber": 154
          },
          {
            "lineNumber": 155
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 156
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 157
          },
          {
            "lineNumber": 158
          },
          {
            "text": "        if atom.collections:",
            "lineNumber": 159
          },
          {
            "text": "            nuke.collections()",
            "lineNumber": 160
          },
          {
            "lineNumber": 161
          },
          {
            "text": "        if atom.images:",
            "lineNumber": 162
          },
          {
            "text": "            nuke.images()",
            "lineNumber": 163
          },
          {
            "lineNumber": 164
          },
          {
            "text": "        if atom.lights:",
            "lineNumber": 165
          },
          {
            "text": "            nuke.lights()",
            "lineNumber": 166
          },
          {
            "lineNumber": 167
          },
          {
            "text": "        if atom.materials:",
            "lineNumber": 168
          },
          {
            "text": "            nuke.materials()",
            "lineNumber": 169
          },
          {
            "lineNumber": 170
          },
          {
            "text": "        if atom.node_groups:",
            "lineNumber": 171
          },
          {
            "text": "            nuke.node_groups()",
            "lineNumber": 172
          },
          {
            "lineNumber": 173
          },
          {
            "text": "        if atom.particles:",
            "lineNumber": 174
          },
          {
            "text": "            nuke.particles()",
            "lineNumber": 175
          },
          {
            "lineNumber": 176
          },
          {
            "text": "        if atom.textures:",
            "lineNumber": 177
          },
          {
            "text": "            nuke.textures()",
            "lineNumber": 178
          },
          {
            "lineNumber": 179
          },
          {
            "text": "        if atom.worlds:",
            "lineNumber": 180
          },
          {
            "text": "            nuke.worlds()",
            "lineNumber": 181
          },
          {
            "lineNumber": 182
          },
          {
            "text": "        bpy.ops.atomic.deselect_all()",
            "lineNumber": 183
          },
          {
            "lineNumber": 184
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 185
          },
          {
            "lineNumber": 186
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 187
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 188
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 189,
            "isSignature": true
          },
          {
            "lineNumber": 190
          },
          {
            "lineNumber": 191
          },
          {
            "text": "# Atomic Data Manager Clean Operator",
            "lineNumber": 192
          },
          {
            "text": "class ATOMIC_OT_clean(bpy.types.Operator):",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused data-blocks from the selected categories\"\"\"",
            "lineNumber": 194
          }
        ]
      },
      "score": 0.085726797580719
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\CHANGELOG.md",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 31,
            "column": 39
          }
        },
        "contents": "## [v2.0.3] - 2025-12-17\n\n### Fixes\n- Fixed missing import error in missing file detection\n\n## [v2.0.2] - 2025-12-17\n\n### Fixes\n- Atomic now completely ignores all library-linked and override datablocks across all operations, as originally intended.\n\n## [v2.0.1] - 2025-12-16\n\n### Fixes\n- Blender 5.0 compatibility: Fixed &#96;AttributeError&#96; when detecting missing library files (Library objects use &#96;packed_file&#96; singular, Image objects use &#96;packed_files&#96; plural in 5.0)\n- Fixed unregistration errors in Blender 4.5 by using safe unregister functions throughout the codebase\n\n## [v2.0.0] - Raincloud's first re-release\n\n### Feature\n- Multi-version Blender support (4.2 LTS, 4.5 LTS, and 5.0)\n    - Version detection utilities in &#96;utils/version.py&#96;\n    - API compatibility layer in &#96;utils/compat.py&#96; for handling version differences\n\n### Fixes\n- Blender 5.0 compatibility: Fixed &#96;AttributeError&#96; when accessing scene compositor node tree (changed from &#96;scene.node_tree&#96; to &#96;scene.compositing_node_tree&#96;)\n- Collections assigned to &#96;rigidbody_world.collection&#96; are now correctly detected as used\n\n### Internal\n- GitHub Actions release workflow\n- Integrated &#96;rainys_repo_bootstrap&#96; into &#96;__init__.py&#96; so the Rainy's Extensions repository is registered on add-on enable and the bootstrap guard resets on disable.\n- Removed \"Support Remington Creative\" popup and all related functionality\n    - Removed Support popup preferences",
        "signatures": {},
        "detailedLines": [
          {
            "text": "## [v2.0.3] - 2025-12-17",
            "lineNumber": 1
          },
          {
            "lineNumber": 2
          },
          {
            "text": "### Fixes",
            "lineNumber": 3
          },
          {
            "text": "- Fixed missing import error in missing file detection",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "## [v2.0.2] - 2025-12-17",
            "lineNumber": 6
          },
          {
            "lineNumber": 7
          },
          {
            "text": "### Fixes",
            "lineNumber": 8
          },
          {
            "text": "- Atomic now completely ignores all library-linked and override datablocks across all operations, as originally intended.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "## [v2.0.1] - 2025-12-16",
            "lineNumber": 11
          },
          {
            "lineNumber": 12
          },
          {
            "text": "### Fixes",
            "lineNumber": 13
          },
          {
            "text": "- Blender 5.0 compatibility: Fixed &#96;AttributeError&#96; when detecting missing library files (Library objects use &#96;packed_file&#96; singular, Image objects use &#96;packed_files&#96; plural in 5.0)",
            "lineNumber": 14
          },
          {
            "text": "- Fixed unregistration errors in Blender 4.5 by using safe unregister functions throughout the codebase",
            "lineNumber": 15
          },
          {
            "lineNumber": 16
          },
          {
            "text": "## [v2.0.0] - Raincloud's first re-release",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "### Feature",
            "lineNumber": 19
          },
          {
            "text": "- Multi-version Blender support (4.2 LTS, 4.5 LTS, and 5.0)",
            "lineNumber": 20
          },
          {
            "text": "    - Version detection utilities in &#96;utils/version.py&#96;",
            "lineNumber": 21
          },
          {
            "text": "    - API compatibility layer in &#96;utils/compat.py&#96; for handling version differences",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "### Fixes",
            "lineNumber": 24
          },
          {
            "text": "- Blender 5.0 compatibility: Fixed &#96;AttributeError&#96; when accessing scene compositor node tree (changed from &#96;scene.node_tree&#96; to &#96;scene.compositing_node_tree&#96;)",
            "lineNumber": 25
          },
          {
            "text": "- Collections assigned to &#96;rigidbody_world.collection&#96; are now correctly detected as used",
            "lineNumber": 26
          },
          {
            "lineNumber": 27
          },
          {
            "text": "### Internal",
            "lineNumber": 28
          },
          {
            "text": "- GitHub Actions release workflow",
            "lineNumber": 29
          },
          {
            "text": "- Integrated &#96;rainys_repo_bootstrap&#96; into &#96;__init__.py&#96; so the Rainy's Extensions repository is registered on add-on enable and the bootstrap guard resets on disable.",
            "lineNumber": 30
          },
          {
            "text": "- Removed \"Support Remington Creative\" popup and all related functionality",
            "lineNumber": 31
          },
          {
            "text": "    - Removed Support popup preferences",
            "lineNumber": 32
          }
        ]
      },
      "score": 0.08388704061508179
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 687,
            "column": 20
          },
          "endPosition": {
            "line": 755
          }
        },
        "contents": "def node_group_has_node_group(search_group_key, node_group_key):\n    # returns true if a node group contains this node group\n\n    has_node_group = False\n    search_group = bpy.data.node_groups[search_group_key]\n    node_group = bpy.data.node_groups[node_group_key]\n\n    # for each node in our search group\n    for node in search_group.nodes:\n\n        # if node is a node group and has a valid node tree\n        if hasattr(node, 'node_tree') and node.node_tree:\n\n            if node.node_tree.name == \"RG_MetallicMap\":\n                print(node.node_tree.name)\n                print(node_group.name)\n\n            # base case\n            # if node group is our node group\n            if node.node_tree.name == node_group.name:\n                has_node_group = True\n\n            # recurse case\n            # if node group is any other node group\n            else:\n                has_node_group = node_group_has_node_group(\n                    node.node_tree.name, node_group.name)\n\n        # break the loop if the node group is found\n        if has_node_group:\n            break\n\n    return has_node_group\n\n\ndef node_group_has_texture(node_group_key, texture_key):\n    # returns true if a node group contains this image\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_group_has_node_group(search_group_key, node_group_key):",
            "lineNumber": 691,
            "isSignature": true
          },
          {
            "text": "    # returns true if a node group contains this node group",
            "lineNumber": 692,
            "isSignature": true
          },
          {
            "lineNumber": 693
          },
          {
            "text": "    has_node_group = False",
            "lineNumber": 694
          },
          {
            "text": "    search_group = bpy.data.node_groups[search_group_key]",
            "lineNumber": 695
          },
          {
            "text": "    node_group = bpy.data.node_groups[node_group_key]",
            "lineNumber": 696
          },
          {
            "lineNumber": 697
          },
          {
            "text": "    # for each node in our search group",
            "lineNumber": 698
          },
          {
            "text": "    for node in search_group.nodes:",
            "lineNumber": 699
          },
          {
            "lineNumber": 700
          },
          {
            "text": "        # if node is a node group and has a valid node tree",
            "lineNumber": 701
          },
          {
            "text": "        if hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 702
          },
          {
            "lineNumber": 703
          },
          {
            "text": "            if node.node_tree.name == \"RG_MetallicMap\":",
            "lineNumber": 704
          },
          {
            "text": "                print(node.node_tree.name)",
            "lineNumber": 705
          },
          {
            "text": "                print(node_group.name)",
            "lineNumber": 706
          },
          {
            "lineNumber": 707
          },
          {
            "text": "            # base case",
            "lineNumber": 708
          },
          {
            "text": "            # if node group is our node group",
            "lineNumber": 709
          },
          {
            "text": "            if node.node_tree.name == node_group.name:",
            "lineNumber": 710
          },
          {
            "text": "                has_node_group = True",
            "lineNumber": 711
          },
          {
            "lineNumber": 712
          },
          {
            "text": "            # recurse case",
            "lineNumber": 713
          },
          {
            "text": "            # if node group is any other node group",
            "lineNumber": 714
          },
          {
            "text": "            else:",
            "lineNumber": 715
          },
          {
            "text": "                has_node_group = node_group_has_node_group(",
            "lineNumber": 716
          },
          {
            "text": "                    node.node_tree.name, node_group.name)",
            "lineNumber": 717
          },
          {
            "lineNumber": 718
          },
          {
            "text": "        # break the loop if the node group is found",
            "lineNumber": 719
          },
          {
            "text": "        if has_node_group:",
            "lineNumber": 720
          },
          {
            "text": "            break",
            "lineNumber": 721
          },
          {
            "lineNumber": 722
          },
          {
            "text": "    return has_node_group",
            "lineNumber": 723,
            "isSignature": true
          },
          {
            "lineNumber": 724
          },
          {
            "lineNumber": 725
          },
          {
            "text": "def node_group_has_texture(node_group_key, texture_key):",
            "lineNumber": 726,
            "isSignature": true
          },
          {
            "text": "    # returns true if a node group contains this image",
            "lineNumber": 727,
            "isSignature": true
          },
          {
            "lineNumber": 728
          },
          {
            "text": "    ",
            "lineNumber": 729
          }
        ]
      },
      "score": 0.08102519810199738
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\.github\\workflows\\release.yml",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 63,
            "column": 10
          }
        },
        "contents": "name: Create Release\n\non:\n  workflow_dispatch:\n    inputs:\n      release_tag:\n        description: 'Release tag (e.g., v2.0.0)'\n        required: true\n        type: string\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Get Version\n        id: get_version\n        run: |\n          python - &lt;&lt;'PY'\n          import os\n          import tomllib\n          from pathlib import Path\n\n          data = tomllib.loads(Path(\"blender_manifest.toml\").read_text(encoding=\"utf-8\"))\n          version = data[\"version\"]\n\n          with open(os.environ[\"GITHUB_OUTPUT\"], \"a\", encoding=\"utf-8\") as fh:\n              fh.write(f\"version={version}\\n\")\n              fh.write(f\"zip_name=Atomic_Data_Manager.v{version}.zip\\n\")\n          PY\n\n      - name: Create ZIP\n        run: |\n          ADDON_DIR=addon_files/atomic_data_manager\n          mkdir -p \"$ADDON_DIR\"\n\n          # Copy top-level files if they exist\n          for file in __init__.py rainys_repo_bootstrap.py blender_manifest.toml README.md CHANGELOG.md LICENSE.txt config.py; do\n            if [ -f \"$file\" ]; then\n              cp \"$file\" \"$ADDON_DIR\"/\n            else\n              echo \"Skipping missing file: $file\"\n            fi\n          done\n\n          # Copy packages\n          for dir in ops ui stats utils; do\n            if [ -d \"$dir\" ]; then\n              cp -r \"$dir\" \"$ADDON_DIR\"/\n            else\n              echo \"Skipping missing directory: $dir\"\n            fi\n          done\n\n          # Create the zip from the temporary directory\n          cd addon_files\n          zip -r \"../${{ steps.get_version.outputs.zip_name }}\" ./*\n\n      - name: Upload Release Asset\n        env:\n          ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "name: Create Release",
            "lineNumber": 1
          },
          {
            "lineNumber": 2
          },
          {
            "text": "on:",
            "lineNumber": 3
          },
          {
            "text": "  workflow_dispatch:",
            "lineNumber": 4
          },
          {
            "text": "    inputs:",
            "lineNumber": 5
          },
          {
            "text": "      release_tag:",
            "lineNumber": 6
          },
          {
            "text": "        description: 'Release tag (e.g., v2.0.0)'",
            "lineNumber": 7
          },
          {
            "text": "        required: true",
            "lineNumber": 8
          },
          {
            "text": "        type: string",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "jobs:",
            "lineNumber": 11
          },
          {
            "text": "  build:",
            "lineNumber": 12
          },
          {
            "text": "    runs-on: ubuntu-latest",
            "lineNumber": 13
          },
          {
            "text": "    permissions:",
            "lineNumber": 14
          },
          {
            "text": "      contents: write",
            "lineNumber": 15
          },
          {
            "text": "    steps:",
            "lineNumber": 16
          },
          {
            "text": "      - uses: actions/checkout@v4",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "      - name: Get Version",
            "lineNumber": 19
          },
          {
            "text": "        id: get_version",
            "lineNumber": 20
          },
          {
            "text": "        run: |",
            "lineNumber": 21
          },
          {
            "text": "          python - &lt;&lt;'PY'",
            "lineNumber": 22
          },
          {
            "text": "          import os",
            "lineNumber": 23
          },
          {
            "text": "          import tomllib",
            "lineNumber": 24
          },
          {
            "text": "          from pathlib import Path",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "          data = tomllib.loads(Path(\"blender_manifest.toml\").read_text(encoding=\"utf-8\"))",
            "lineNumber": 27
          },
          {
            "text": "          version = data[\"version\"]",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "text": "          with open(os.environ[\"GITHUB_OUTPUT\"], \"a\", encoding=\"utf-8\") as fh:",
            "lineNumber": 30
          },
          {
            "text": "              fh.write(f\"version={version}\\n\")",
            "lineNumber": 31
          },
          {
            "text": "              fh.write(f\"zip_name=Atomic_Data_Manager.v{version}.zip\\n\")",
            "lineNumber": 32
          },
          {
            "text": "          PY",
            "lineNumber": 33
          },
          {
            "lineNumber": 34
          },
          {
            "text": "      - name: Create ZIP",
            "lineNumber": 35
          },
          {
            "text": "        run: |",
            "lineNumber": 36
          },
          {
            "text": "          ADDON_DIR=addon_files/atomic_data_manager",
            "lineNumber": 37
          },
          {
            "text": "          mkdir -p \"$ADDON_DIR\"",
            "lineNumber": 38
          },
          {
            "lineNumber": 39
          },
          {
            "text": "          # Copy top-level files if they exist",
            "lineNumber": 40
          },
          {
            "text": "          for file in __init__.py rainys_repo_bootstrap.py blender_manifest.toml README.md CHANGELOG.md LICENSE.txt config.py; do",
            "lineNumber": 41
          },
          {
            "text": "            if [ -f \"$file\" ]; then",
            "lineNumber": 42
          },
          {
            "text": "              cp \"$file\" \"$ADDON_DIR\"/",
            "lineNumber": 43
          },
          {
            "text": "            else",
            "lineNumber": 44
          },
          {
            "text": "              echo \"Skipping missing file: $file\"",
            "lineNumber": 45
          },
          {
            "text": "            fi",
            "lineNumber": 46
          },
          {
            "text": "          done",
            "lineNumber": 47
          },
          {
            "lineNumber": 48
          },
          {
            "text": "          # Copy packages",
            "lineNumber": 49
          },
          {
            "text": "          for dir in ops ui stats utils; do",
            "lineNumber": 50
          },
          {
            "text": "            if [ -d \"$dir\" ]; then",
            "lineNumber": 51
          },
          {
            "text": "              cp -r \"$dir\" \"$ADDON_DIR\"/",
            "lineNumber": 52
          },
          {
            "text": "            else",
            "lineNumber": 53
          },
          {
            "text": "              echo \"Skipping missing directory: $dir\"",
            "lineNumber": 54
          },
          {
            "text": "            fi",
            "lineNumber": 55
          },
          {
            "text": "          done",
            "lineNumber": 56
          },
          {
            "lineNumber": 57
          },
          {
            "text": "          # Create the zip from the temporary directory",
            "lineNumber": 58
          },
          {
            "text": "          cd addon_files",
            "lineNumber": 59
          },
          {
            "text": "          zip -r \"../${{ steps.get_version.outputs.zip_name }}\" ./*",
            "lineNumber": 60
          },
          {
            "lineNumber": 61
          },
          {
            "text": "      - name: Upload Release Asset",
            "lineNumber": 62
          },
          {
            "text": "        env:",
            "lineNumber": 63
          },
          {
            "text": "          ",
            "lineNumber": 64
          }
        ]
      },
      "score": 0.07211816310882568
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\inspect_ops.py",
        "range": {
          "startPosition": {
            "line": 367
          },
          "endPosition": {
            "line": 480
          }
        },
        "contents": "class ATOMIC_OT_inspection_duplicate(bpy.types.Operator):\ndef execute(self, context):\n\n\n        elif inspection == 'MATERIALS':\n            key = atom.materials_field\n            materials = bpy.data.materials\n\n            if key in materials.keys():\n                material = materials[key]\n                error = _check_library_or_override(material)\n                if error:\n                    self.report({'ERROR'}, error)\n                    return {'CANCELLED'}\n                copy_key = duplicate.material(key)\n                atom.materials_field = copy_key\n\n        elif inspection == 'NODE_GROUPS':\n            key = atom.node_groups_field\n            node_groups = bpy.data.node_groups\n\n            if key in node_groups.keys():\n                node_group = node_groups[key]\n                error = _check_library_or_override(node_group)\n                if error:\n                    self.report({'ERROR'}, error)\n                    return {'CANCELLED'}\n                copy_key = duplicate.node_group(key)\n                atom.node_groups_field = copy_key\n\n        elif inspection == 'PARTICLES':\n            key = atom.particles_field\n            particles = bpy.data.particles\n\n            if key in particles.keys():\n                particle = particles[key]\n                error = _check_library_or_override(particle)\n                if error:\n                    self.report({'ERROR'}, error)\n                    return {'CANCELLED'}\n                copy_key = duplicate.particle(key)\n                atom.particles_field = copy_key\n\n        elif inspection == 'TEXTURES':\n            key = atom.textures_field\n            textures = bpy.data.textures\n\n            if key in textures.keys():\n                texture = textures[key]\n                error = _check_library_or_override(texture)\n                if error:\n                    self.report({'ERROR'}, error)\n                    return {'CANCELLED'}\n                copy_key = duplicate.texture(key)\n                atom.textures_field = copy_key\n\n        elif inspection == 'WORLDS':\n            key = atom.worlds_field",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 368,
                "column": 1
              },
              "endPosition": {
                "line": 369,
                "column": 5
              }
            },
            {
              "startPosition": {
                "line": 373,
                "column": 5
              },
              "endPosition": {
                "line": 374,
                "column": 9
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_OT_inspection_duplicate(bpy.types.Operator):",
            "lineNumber": 368,
            "isSignature": true
          },
          {
            "text": "def execute(self, context):",
            "lineNumber": 373
          },
          {
            "lineNumber": 414
          },
          {
            "lineNumber": 415
          },
          {
            "text": "        elif inspection == 'MATERIALS':",
            "lineNumber": 416
          },
          {
            "text": "            key = atom.materials_field",
            "lineNumber": 417
          },
          {
            "text": "            materials = bpy.data.materials",
            "lineNumber": 418
          },
          {
            "lineNumber": 419
          },
          {
            "text": "            if key in materials.keys():",
            "lineNumber": 420
          },
          {
            "text": "                material = materials[key]",
            "lineNumber": 421
          },
          {
            "text": "                error = _check_library_or_override(material)",
            "lineNumber": 422
          },
          {
            "text": "                if error:",
            "lineNumber": 423
          },
          {
            "text": "                    self.report({'ERROR'}, error)",
            "lineNumber": 424
          },
          {
            "text": "                    return {'CANCELLED'}",
            "lineNumber": 425
          },
          {
            "text": "                copy_key = duplicate.material(key)",
            "lineNumber": 426
          },
          {
            "text": "                atom.materials_field = copy_key",
            "lineNumber": 427
          },
          {
            "lineNumber": 428
          },
          {
            "text": "        elif inspection == 'NODE_GROUPS':",
            "lineNumber": 429
          },
          {
            "text": "            key = atom.node_groups_field",
            "lineNumber": 430
          },
          {
            "text": "            node_groups = bpy.data.node_groups",
            "lineNumber": 431
          },
          {
            "lineNumber": 432
          },
          {
            "text": "            if key in node_groups.keys():",
            "lineNumber": 433
          },
          {
            "text": "                node_group = node_groups[key]",
            "lineNumber": 434
          },
          {
            "text": "                error = _check_library_or_override(node_group)",
            "lineNumber": 435
          },
          {
            "text": "                if error:",
            "lineNumber": 436
          },
          {
            "text": "                    self.report({'ERROR'}, error)",
            "lineNumber": 437
          },
          {
            "text": "                    return {'CANCELLED'}",
            "lineNumber": 438
          },
          {
            "text": "                copy_key = duplicate.node_group(key)",
            "lineNumber": 439
          },
          {
            "text": "                atom.node_groups_field = copy_key",
            "lineNumber": 440
          },
          {
            "lineNumber": 441
          },
          {
            "text": "        elif inspection == 'PARTICLES':",
            "lineNumber": 442
          },
          {
            "text": "            key = atom.particles_field",
            "lineNumber": 443
          },
          {
            "text": "            particles = bpy.data.particles",
            "lineNumber": 444
          },
          {
            "lineNumber": 445
          },
          {
            "text": "            if key in particles.keys():",
            "lineNumber": 446
          },
          {
            "text": "                particle = particles[key]",
            "lineNumber": 447
          },
          {
            "text": "                error = _check_library_or_override(particle)",
            "lineNumber": 448
          },
          {
            "text": "                if error:",
            "lineNumber": 449
          },
          {
            "text": "                    self.report({'ERROR'}, error)",
            "lineNumber": 450
          },
          {
            "text": "                    return {'CANCELLED'}",
            "lineNumber": 451
          },
          {
            "text": "                copy_key = duplicate.particle(key)",
            "lineNumber": 452
          },
          {
            "text": "                atom.particles_field = copy_key",
            "lineNumber": 453
          },
          {
            "lineNumber": 454
          },
          {
            "text": "        elif inspection == 'TEXTURES':",
            "lineNumber": 455
          },
          {
            "text": "            key = atom.textures_field",
            "lineNumber": 456
          },
          {
            "text": "            textures = bpy.data.textures",
            "lineNumber": 457
          },
          {
            "lineNumber": 458
          },
          {
            "text": "            if key in textures.keys():",
            "lineNumber": 459
          },
          {
            "text": "                texture = textures[key]",
            "lineNumber": 460
          },
          {
            "text": "                error = _check_library_or_override(texture)",
            "lineNumber": 461
          },
          {
            "text": "                if error:",
            "lineNumber": 462
          },
          {
            "text": "                    self.report({'ERROR'}, error)",
            "lineNumber": 463
          },
          {
            "text": "                    return {'CANCELLED'}",
            "lineNumber": 464
          },
          {
            "text": "                copy_key = duplicate.texture(key)",
            "lineNumber": 465
          },
          {
            "text": "                atom.textures_field = copy_key",
            "lineNumber": 466
          },
          {
            "lineNumber": 467
          },
          {
            "text": "        elif inspection == 'WORLDS':",
            "lineNumber": 468
          },
          {
            "text": "            key = atom.worlds_field",
            "lineNumber": 469
          }
        ]
      },
      "score": 0.07208690047264099
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 145
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains the direct use operators, intended to be used with\nAtomic's pie menu interface. However, they can be implemented anywhere\nif they need to be.\n\nThese operators basically wrap the functions from ops.utils.nuke.py and\nops.utils.clean.py into operators so they can be easily called by other\nintefaces in Blender.\n\n\"\"\"\n\nimport bpy\nfrom bpy.utils import register_class\nfrom ..utils import compat\nfrom .. import config\nfrom ..stats import unused\nfrom .utils import nuke\nfrom .utils import clean\nfrom ..ui.utils import ui_layouts\n\n\nclass ATOMIC_OT_invoke_pie_menu_ui(bpy.types.Operator):\n    \"\"\"Invokes Atomic's pie menu UI if the \\\"Enable Pie Menu UI\\\"\n    preference is enabled in Atomic's preferences panel\"\"\"\n    bl_idname = \"atomic.invoke_pie_menu_ui\"\n    bl_label = \"Invoke Pie Menu UI\"\n\n    def execute(self, context):\n        if config.enable_pie_menu_ui:\n            bpy.ops.wm.call_menu_pie(name=\"ATOMIC_MT_main_pie\")\n        return {'FINISHED'}\n\n\n# Atomic Data Manager Nuke All Operator\nclass ATOMIC_OT_nuke_all(bpy.types.Operator):\n    \"\"\"Remove all data-blocks from the selected categories\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains the direct use operators, intended to be used with",
            "lineNumber": 21
          },
          {
            "text": "Atomic's pie menu interface. However, they can be implemented anywhere",
            "lineNumber": 22
          },
          {
            "text": "if they need to be.",
            "lineNumber": 23
          },
          {
            "lineNumber": 24
          },
          {
            "text": "These operators basically wrap the functions from ops.utils.nuke.py and",
            "lineNumber": 25
          },
          {
            "text": "ops.utils.clean.py into operators so they can be easily called by other",
            "lineNumber": 26
          },
          {
            "text": "intefaces in Blender.",
            "lineNumber": 27
          },
          {
            "lineNumber": 28
          },
          {
            "text": "\"\"\"",
            "lineNumber": 29
          },
          {
            "lineNumber": 30
          },
          {
            "text": "import bpy",
            "lineNumber": 31
          },
          {
            "text": "from bpy.utils import register_class",
            "lineNumber": 32
          },
          {
            "text": "from ..utils import compat",
            "lineNumber": 33
          },
          {
            "text": "from .. import config",
            "lineNumber": 34
          },
          {
            "text": "from ..stats import unused",
            "lineNumber": 35
          },
          {
            "text": "from .utils import nuke",
            "lineNumber": 36
          },
          {
            "text": "from .utils import clean",
            "lineNumber": 37
          },
          {
            "text": "from ..ui.utils import ui_layouts",
            "lineNumber": 38
          },
          {
            "lineNumber": 39
          },
          {
            "lineNumber": 40
          },
          {
            "text": "class ATOMIC_OT_invoke_pie_menu_ui(bpy.types.Operator):",
            "lineNumber": 41,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Invokes Atomic's pie menu UI if the \\\"Enable Pie Menu UI\\\"",
            "lineNumber": 42
          },
          {
            "text": "    preference is enabled in Atomic's preferences panel\"\"\"",
            "lineNumber": 43
          },
          {
            "text": "    bl_idname = \"atomic.invoke_pie_menu_ui\"",
            "lineNumber": 44
          },
          {
            "text": "    bl_label = \"Invoke Pie Menu UI\"",
            "lineNumber": 45
          },
          {
            "lineNumber": 46
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 47
          },
          {
            "text": "        if config.enable_pie_menu_ui:",
            "lineNumber": 48
          },
          {
            "text": "            bpy.ops.wm.call_menu_pie(name=\"ATOMIC_MT_main_pie\")",
            "lineNumber": 49
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 50,
            "isSignature": true
          },
          {
            "lineNumber": 51
          },
          {
            "lineNumber": 52
          },
          {
            "text": "# Atomic Data Manager Nuke All Operator",
            "lineNumber": 53
          },
          {
            "text": "class ATOMIC_OT_nuke_all(bpy.types.Operator):",
            "lineNumber": 54,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all data-blocks from the selected categories\"\"\"",
            "lineNumber": 55
          }
        ]
      },
      "score": 0.07099766284227371
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\inspect_ops.py",
        "range": {
          "startPosition": {
            "line": 140
          },
          "endPosition": {
            "line": 294
          }
        },
        "contents": "class ATOMIC_OT_inspection_replace(bpy.types.Operator):\ndef draw(self, context):\n\n            )\n\n    def execute(self, context):\n        atom = bpy.context.scene.atomic\n        inspection = atom.active_inspection\n\n        if inspection == 'IMAGES' and \\\n                atom.replace_field in bpy.data.images.keys():\n            image = bpy.data.images[atom.images_field]\n            error = _check_library_or_override(image)\n            if error:\n                self.report({'ERROR'}, error)\n                return {'CANCELLED'}\n            image.user_remap(bpy.data.images[atom.replace_field])\n            atom.images_field = atom.replace_field\n\n        if inspection == 'LIGHTS' and \\\n                atom.replace_field in bpy.data.lights.keys():\n            light = bpy.data.lights[atom.lights_field]\n            error = _check_library_or_override(light)\n            if error:\n                self.report({'ERROR'}, error)\n                return {'CANCELLED'}\n            light.user_remap(bpy.data.lights[atom.replace_field])\n            atom.lights_field = atom.replace_field\n\n        if inspection == 'MATERIALS' and \\\n                atom.replace_field in bpy.data.materials.keys():\n            material = bpy.data.materials[atom.materials_field]\n            error = _check_library_or_override(material)\n            if error:\n                self.report({'ERROR'}, error)\n                return {'CANCELLED'}\n            material.user_remap(bpy.data.materials[atom.replace_field])\n            atom.materials_field = atom.replace_field\n\n        if inspection == 'NODE_GROUPS' and \\\n                atom.replace_field in bpy.data.node_groups.keys():\n            node_group = bpy.data.node_groups[atom.node_groups_field]\n            error = _check_library_or_override(node_group)\n            if error:\n                self.report({'ERROR'}, error)\n                return {'CANCELLED'}\n            node_group.user_remap(bpy.data.node_groups[atom.replace_field])\n            atom.node_groups_field = atom.replace_field\n\n        if inspection == 'PARTICLES' and \\",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 141,
                "column": 1
              },
              "endPosition": {
                "line": 142,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_OT_inspection_replace(bpy.types.Operator):",
            "lineNumber": 141,
            "isSignature": true
          },
          {
            "text": "def draw(self, context):",
            "lineNumber": 146
          },
          {
            "lineNumber": 213
          },
          {
            "text": "            )",
            "lineNumber": 214
          },
          {
            "lineNumber": 215
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 216
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 217
          },
          {
            "text": "        inspection = atom.active_inspection",
            "lineNumber": 218
          },
          {
            "lineNumber": 219
          },
          {
            "text": "        if inspection == 'IMAGES' and \\",
            "lineNumber": 220
          },
          {
            "text": "                atom.replace_field in bpy.data.images.keys():",
            "lineNumber": 221
          },
          {
            "text": "            image = bpy.data.images[atom.images_field]",
            "lineNumber": 222
          },
          {
            "text": "            error = _check_library_or_override(image)",
            "lineNumber": 223
          },
          {
            "text": "            if error:",
            "lineNumber": 224
          },
          {
            "text": "                self.report({'ERROR'}, error)",
            "lineNumber": 225
          },
          {
            "text": "                return {'CANCELLED'}",
            "lineNumber": 226
          },
          {
            "text": "            image.user_remap(bpy.data.images[atom.replace_field])",
            "lineNumber": 227
          },
          {
            "text": "            atom.images_field = atom.replace_field",
            "lineNumber": 228
          },
          {
            "lineNumber": 229
          },
          {
            "text": "        if inspection == 'LIGHTS' and \\",
            "lineNumber": 230
          },
          {
            "text": "                atom.replace_field in bpy.data.lights.keys():",
            "lineNumber": 231
          },
          {
            "text": "            light = bpy.data.lights[atom.lights_field]",
            "lineNumber": 232
          },
          {
            "text": "            error = _check_library_or_override(light)",
            "lineNumber": 233
          },
          {
            "text": "            if error:",
            "lineNumber": 234
          },
          {
            "text": "                self.report({'ERROR'}, error)",
            "lineNumber": 235
          },
          {
            "text": "                return {'CANCELLED'}",
            "lineNumber": 236
          },
          {
            "text": "            light.user_remap(bpy.data.lights[atom.replace_field])",
            "lineNumber": 237
          },
          {
            "text": "            atom.lights_field = atom.replace_field",
            "lineNumber": 238
          },
          {
            "lineNumber": 239
          },
          {
            "text": "        if inspection == 'MATERIALS' and \\",
            "lineNumber": 240
          },
          {
            "text": "                atom.replace_field in bpy.data.materials.keys():",
            "lineNumber": 241
          },
          {
            "text": "            material = bpy.data.materials[atom.materials_field]",
            "lineNumber": 242
          },
          {
            "text": "            error = _check_library_or_override(material)",
            "lineNumber": 243
          },
          {
            "text": "            if error:",
            "lineNumber": 244
          },
          {
            "text": "                self.report({'ERROR'}, error)",
            "lineNumber": 245
          },
          {
            "text": "                return {'CANCELLED'}",
            "lineNumber": 246
          },
          {
            "text": "            material.user_remap(bpy.data.materials[atom.replace_field])",
            "lineNumber": 247
          },
          {
            "text": "            atom.materials_field = atom.replace_field",
            "lineNumber": 248
          },
          {
            "lineNumber": 249
          },
          {
            "text": "        if inspection == 'NODE_GROUPS' and \\",
            "lineNumber": 250
          },
          {
            "text": "                atom.replace_field in bpy.data.node_groups.keys():",
            "lineNumber": 251
          },
          {
            "text": "            node_group = bpy.data.node_groups[atom.node_groups_field]",
            "lineNumber": 252
          },
          {
            "text": "            error = _check_library_or_override(node_group)",
            "lineNumber": 253
          },
          {
            "text": "            if error:",
            "lineNumber": 254
          },
          {
            "text": "                self.report({'ERROR'}, error)",
            "lineNumber": 255
          },
          {
            "text": "                return {'CANCELLED'}",
            "lineNumber": 256
          },
          {
            "text": "            node_group.user_remap(bpy.data.node_groups[atom.replace_field])",
            "lineNumber": 257
          },
          {
            "text": "            atom.node_groups_field = atom.replace_field",
            "lineNumber": 258
          },
          {
            "lineNumber": 259
          },
          {
            "text": "        if inspection == 'PARTICLES' and \\",
            "lineNumber": 260
          }
        ]
      },
      "score": 0.06705590337514877
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\missing_file_ops.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 102
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains operations for missing file handling. This includes\nthe option to reload, remove, replace, and search for these missing files.\n\nIt also contains the post-reload report dialog that appears after\nattempting to reload missing project files.\n\n# TODO: implement missing file replace and search once Blender fixes the\n# TODO: bugs with the file chooser not opening from a dialog\n\n\"\"\"\n\nimport bpy\nfrom bpy.utils import register_class\nfrom ..utils import compat\nfrom ..stats import missing\nfrom ..ui.utils import ui_layouts\n\n\n# Atomic Data Manager Reload Missing Files Operator\nclass ATOMIC_OT_reload_missing(bpy.types.Operator):\n    \"\"\"Reload missing files\"\"\"\n    bl_idname = \"atomic.reload_missing\"\n    bl_label = \"Reload Missing Files\"\n\n    def execute(self, context):\n        # reload images\n        for image in bpy.data.images:\n            image.reload()\n\n        # reload libraries\n        for library in bpy.data.libraries:\n            library.reload()\n\n        # call reload report\n        bpy.ops.atomic.reload_report('INVOKE_DEFAULT')\n        return {'FINISHED'}\n\n\n# Atomic Data Manager Reload Missing Files Report Operator\nclass ATOMIC_OT_reload_report(bpy.types.Operator):\n    \"\"\"Reload report for missing files\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains operations for missing file handling. This includes",
            "lineNumber": 21
          },
          {
            "text": "the option to reload, remove, replace, and search for these missing files.",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "It also contains the post-reload report dialog that appears after",
            "lineNumber": 24
          },
          {
            "text": "attempting to reload missing project files.",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "# TODO: implement missing file replace and search once Blender fixes the",
            "lineNumber": 27
          },
          {
            "text": "# TODO: bugs with the file chooser not opening from a dialog",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "text": "\"\"\"",
            "lineNumber": 30
          },
          {
            "lineNumber": 31
          },
          {
            "text": "import bpy",
            "lineNumber": 32
          },
          {
            "text": "from bpy.utils import register_class",
            "lineNumber": 33
          },
          {
            "text": "from ..utils import compat",
            "lineNumber": 34
          },
          {
            "text": "from ..stats import missing",
            "lineNumber": 35
          },
          {
            "text": "from ..ui.utils import ui_layouts",
            "lineNumber": 36
          },
          {
            "lineNumber": 37
          },
          {
            "lineNumber": 38
          },
          {
            "text": "# Atomic Data Manager Reload Missing Files Operator",
            "lineNumber": 39
          },
          {
            "text": "class ATOMIC_OT_reload_missing(bpy.types.Operator):",
            "lineNumber": 40,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Reload missing files\"\"\"",
            "lineNumber": 41
          },
          {
            "text": "    bl_idname = \"atomic.reload_missing\"",
            "lineNumber": 42
          },
          {
            "text": "    bl_label = \"Reload Missing Files\"",
            "lineNumber": 43
          },
          {
            "lineNumber": 44
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 45
          },
          {
            "text": "        # reload images",
            "lineNumber": 46
          },
          {
            "text": "        for image in bpy.data.images:",
            "lineNumber": 47
          },
          {
            "text": "            image.reload()",
            "lineNumber": 48
          },
          {
            "lineNumber": 49
          },
          {
            "text": "        # reload libraries",
            "lineNumber": 50
          },
          {
            "text": "        for library in bpy.data.libraries:",
            "lineNumber": 51
          },
          {
            "text": "            library.reload()",
            "lineNumber": 52
          },
          {
            "lineNumber": 53
          },
          {
            "text": "        # call reload report",
            "lineNumber": 54
          },
          {
            "text": "        bpy.ops.atomic.reload_report('INVOKE_DEFAULT')",
            "lineNumber": 55
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 56,
            "isSignature": true
          },
          {
            "lineNumber": 57
          },
          {
            "lineNumber": 58
          },
          {
            "text": "# Atomic Data Manager Reload Missing Files Report Operator",
            "lineNumber": 59
          },
          {
            "text": "class ATOMIC_OT_reload_report(bpy.types.Operator):",
            "lineNumber": 60,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Reload report for missing files\"\"\"",
            "lineNumber": 61
          }
        ]
      },
      "score": 0.06660830229520798
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\__init__.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 41
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file handles the registration of the atomic_data_manager.ops package\n\n\"\"\"\n\nfrom . import main_ops\nfrom . import inspect_ops\nfrom . import direct_use_ops\nfrom . import missing_file_ops\n\n\ndef register():\n    main_ops.register()\n    inspect_ops.register()\n    direct_use_ops.register()\n    missing_file_ops.register()\n\n\ndef unregister():\n    main_ops.unregister()\n    inspect_ops.unregister()",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file handles the registration of the atomic_data_manager.ops package",
            "lineNumber": 21
          },
          {
            "lineNumber": 22
          },
          {
            "text": "\"\"\"",
            "lineNumber": 23
          },
          {
            "lineNumber": 24
          },
          {
            "text": "from . import main_ops",
            "lineNumber": 25
          },
          {
            "text": "from . import inspect_ops",
            "lineNumber": 26
          },
          {
            "text": "from . import direct_use_ops",
            "lineNumber": 27
          },
          {
            "text": "from . import missing_file_ops",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "lineNumber": 30
          },
          {
            "text": "def register():",
            "lineNumber": 31,
            "isSignature": true
          },
          {
            "text": "    main_ops.register()",
            "lineNumber": 32
          },
          {
            "text": "    inspect_ops.register()",
            "lineNumber": 33
          },
          {
            "text": "    direct_use_ops.register()",
            "lineNumber": 34
          },
          {
            "text": "    missing_file_ops.register()",
            "lineNumber": 35,
            "isSignature": true
          },
          {
            "lineNumber": 36
          },
          {
            "lineNumber": 37
          },
          {
            "text": "def unregister():",
            "lineNumber": 38,
            "isSignature": true
          },
          {
            "text": "    main_ops.unregister()",
            "lineNumber": 39
          },
          {
            "text": "    inspect_ops.unregister()",
            "lineNumber": 40
          }
        ]
      },
      "score": 0.0663793683052063
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {
            "line": 192
          },
          "endPosition": {
            "line": 367
          }
        },
        "contents": "class ATOMIC_OT_clean(bpy.types.Operator):\n\n\n    def execute(self, context):\n        atom = bpy.context.scene.atomic\n\n        if atom.collections:\n            clean.collections()\n\n        if atom.images:\n            clean.images()\n\n        if atom.lights:\n            clean.lights()\n\n        if atom.materials:\n            clean.materials()\n\n        if atom.node_groups:\n            clean.node_groups()\n\n        if atom.particles:\n            clean.particles()\n\n        if atom.textures:\n            clean.textures()\n\n        if atom.worlds:\n            clean.worlds()\n\n        bpy.ops.atomic.deselect_all()\n\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        atom = bpy.context.scene.atomic\n\n        if atom.collections:\n            self.unused_collections = unused.collections_deep()\n\n        if atom.images:\n            self.unused_images = unused.images_deep()\n\n        if atom.lights:\n            self.unused_lights = unused.lights_deep()\n\n        if atom.materials:\n            self.unused_materials = unused.materials_deep()\n\n        if atom.node_groups:\n            self.unused_node_groups = unused.node_groups_deep()\n\n        if atom.particles:\n            self.unused_particles = unused.particles_deep()\n\n        if atom.textures:\n            self.unused_textures = unused.textures_deep()\n\n        if atom.worlds:\n            self.unused_worlds = unused.worlds()\n\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Undo Operator\nclass ATOMIC_OT_undo(bpy.types.Operator):\n    \"\"\"Undo the previous action\"\"\"",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 193,
                "column": 1
              },
              "endPosition": {
                "line": 194,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_OT_clean(bpy.types.Operator):",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "lineNumber": 296
          },
          {
            "lineNumber": 297
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 298
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 299
          },
          {
            "lineNumber": 300
          },
          {
            "text": "        if atom.collections:",
            "lineNumber": 301
          },
          {
            "text": "            clean.collections()",
            "lineNumber": 302
          },
          {
            "lineNumber": 303
          },
          {
            "text": "        if atom.images:",
            "lineNumber": 304
          },
          {
            "text": "            clean.images()",
            "lineNumber": 305
          },
          {
            "lineNumber": 306
          },
          {
            "text": "        if atom.lights:",
            "lineNumber": 307
          },
          {
            "text": "            clean.lights()",
            "lineNumber": 308
          },
          {
            "lineNumber": 309
          },
          {
            "text": "        if atom.materials:",
            "lineNumber": 310
          },
          {
            "text": "            clean.materials()",
            "lineNumber": 311
          },
          {
            "lineNumber": 312
          },
          {
            "text": "        if atom.node_groups:",
            "lineNumber": 313
          },
          {
            "text": "            clean.node_groups()",
            "lineNumber": 314
          },
          {
            "lineNumber": 315
          },
          {
            "text": "        if atom.particles:",
            "lineNumber": 316
          },
          {
            "text": "            clean.particles()",
            "lineNumber": 317
          },
          {
            "lineNumber": 318
          },
          {
            "text": "        if atom.textures:",
            "lineNumber": 319
          },
          {
            "text": "            clean.textures()",
            "lineNumber": 320
          },
          {
            "lineNumber": 321
          },
          {
            "text": "        if atom.worlds:",
            "lineNumber": 322
          },
          {
            "text": "            clean.worlds()",
            "lineNumber": 323
          },
          {
            "lineNumber": 324
          },
          {
            "text": "        bpy.ops.atomic.deselect_all()",
            "lineNumber": 325
          },
          {
            "lineNumber": 326
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 327
          },
          {
            "lineNumber": 328
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 329
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 330
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 331
          },
          {
            "lineNumber": 332
          },
          {
            "text": "        if atom.collections:",
            "lineNumber": 333
          },
          {
            "text": "            self.unused_collections = unused.collections_deep()",
            "lineNumber": 334
          },
          {
            "lineNumber": 335
          },
          {
            "text": "        if atom.images:",
            "lineNumber": 336
          },
          {
            "text": "            self.unused_images = unused.images_deep()",
            "lineNumber": 337
          },
          {
            "lineNumber": 338
          },
          {
            "text": "        if atom.lights:",
            "lineNumber": 339
          },
          {
            "text": "            self.unused_lights = unused.lights_deep()",
            "lineNumber": 340
          },
          {
            "lineNumber": 341
          },
          {
            "text": "        if atom.materials:",
            "lineNumber": 342
          },
          {
            "text": "            self.unused_materials = unused.materials_deep()",
            "lineNumber": 343
          },
          {
            "lineNumber": 344
          },
          {
            "text": "        if atom.node_groups:",
            "lineNumber": 345
          },
          {
            "text": "            self.unused_node_groups = unused.node_groups_deep()",
            "lineNumber": 346
          },
          {
            "lineNumber": 347
          },
          {
            "text": "        if atom.particles:",
            "lineNumber": 348
          },
          {
            "text": "            self.unused_particles = unused.particles_deep()",
            "lineNumber": 349
          },
          {
            "lineNumber": 350
          },
          {
            "text": "        if atom.textures:",
            "lineNumber": 351
          },
          {
            "text": "            self.unused_textures = unused.textures_deep()",
            "lineNumber": 352
          },
          {
            "lineNumber": 353
          },
          {
            "text": "        if atom.worlds:",
            "lineNumber": 354
          },
          {
            "text": "            self.unused_worlds = unused.worlds()",
            "lineNumber": 355
          },
          {
            "lineNumber": 356
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 357,
            "isSignature": true
          },
          {
            "lineNumber": 358
          },
          {
            "lineNumber": 359
          },
          {
            "text": "# Atomic Data Manager Undo Operator",
            "lineNumber": 360
          },
          {
            "text": "class ATOMIC_OT_undo(bpy.types.Operator):",
            "lineNumber": 361,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Undo the previous action\"\"\"",
            "lineNumber": 362
          }
        ]
      },
      "score": 0.06034350022673607
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 188
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains the main operators found in the main panel of the\nAtomic Data Manager interface. This includes nuke, clean, undo, and the\nvarious selection operations.\n\n\"\"\"\n\nimport bpy\nfrom bpy.utils import register_class\nfrom ..utils import compat\nfrom ..stats import unused\nfrom .utils import clean\nfrom .utils import nuke\nfrom ..ui.utils import ui_layouts\n\n\n# Atomic Data Manager Nuke Operator\nclass ATOMIC_OT_nuke(bpy.types.Operator):\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains the main operators found in the main panel of the",
            "lineNumber": 21
          },
          {
            "text": "Atomic Data Manager interface. This includes nuke, clean, undo, and the",
            "lineNumber": 22
          },
          {
            "text": "various selection operations.",
            "lineNumber": 23
          },
          {
            "lineNumber": 24
          },
          {
            "text": "\"\"\"",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "import bpy",
            "lineNumber": 27
          },
          {
            "text": "from bpy.utils import register_class",
            "lineNumber": 28
          },
          {
            "text": "from ..utils import compat",
            "lineNumber": 29
          },
          {
            "text": "from ..stats import unused",
            "lineNumber": 30
          },
          {
            "text": "from .utils import clean",
            "lineNumber": 31
          },
          {
            "text": "from .utils import nuke",
            "lineNumber": 32
          },
          {
            "text": "from ..ui.utils import ui_layouts",
            "lineNumber": 33
          },
          {
            "lineNumber": 34
          },
          {
            "lineNumber": 35
          },
          {
            "text": "# Atomic Data Manager Nuke Operator",
            "lineNumber": 36
          },
          {
            "text": "class ATOMIC_OT_nuke(bpy.types.Operator):",
            "lineNumber": 37,
            "isSignature": true
          },
          {
            "text": "    ",
            "lineNumber": 38
          }
        ]
      },
      "score": 0.058144450187683105
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\__init__.py",
        "range": {
          "startPosition": {
            "line": 30,
            "column": 26
          },
          "endPosition": {
            "line": 199
          }
        },
        "contents": "from . import rainys_repo_bootstrap\n\n\n# Atomic Data Manager Properties\nclass ATOMIC_PG_main(bpy.types.PropertyGroup):\n    # main panel toggle buttons\n    collections: bpy.props.BoolProperty(default=False)\n    images: bpy.props.BoolProperty(default=False)\n    lights: bpy.props.BoolProperty(default=False)\n    materials: bpy.props.BoolProperty(default=False)\n    node_groups: bpy.props.BoolProperty(default=False)\n    particles: bpy.props.BoolProperty(default=False)\n    textures: bpy.props.BoolProperty(default=False)\n    worlds: bpy.props.BoolProperty(default=False)\n\n    # inspect data-block search fields\n    collections_field: bpy.props.StringProperty(\n        update=inspect_ui.update_inspection)\n\n    images_field: bpy.props.StringProperty(\n        update=inspect_ui.update_inspection)\n\n    lights_field: bpy.props.StringProperty(\n        update=inspect_ui.update_inspection)\n\n    materials_field: bpy.props.StringProperty(\n        update=inspect_ui.update_inspection)\n\n    node_groups_field: bpy.props.StringProperty(\n        update=inspect_ui.update_inspection)\n\n    particles_field: bpy.props.StringProperty(\n        update=inspect_ui.update_inspection)\n\n    textures_field: bpy.props.StringProperty(\n        update=inspect_ui.update_inspection)\n\n    worlds_field: bpy.props.StringProperty(\n        update=inspect_ui.update_inspection)\n\n    # enum for the inspection mode that is currently active",
        "signatures": {},
        "detailedLines": [
          {
            "text": "from . import rainys_repo_bootstrap",
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "lineNumber": 34
          },
          {
            "text": "# Atomic Data Manager Properties",
            "lineNumber": 35
          },
          {
            "text": "class ATOMIC_PG_main(bpy.types.PropertyGroup):",
            "lineNumber": 36,
            "isSignature": true
          },
          {
            "text": "    # main panel toggle buttons",
            "lineNumber": 37,
            "isSignature": true
          },
          {
            "text": "    collections: bpy.props.BoolProperty(default=False)",
            "lineNumber": 38
          },
          {
            "text": "    images: bpy.props.BoolProperty(default=False)",
            "lineNumber": 39
          },
          {
            "text": "    lights: bpy.props.BoolProperty(default=False)",
            "lineNumber": 40
          },
          {
            "text": "    materials: bpy.props.BoolProperty(default=False)",
            "lineNumber": 41
          },
          {
            "text": "    node_groups: bpy.props.BoolProperty(default=False)",
            "lineNumber": 42
          },
          {
            "text": "    particles: bpy.props.BoolProperty(default=False)",
            "lineNumber": 43
          },
          {
            "text": "    textures: bpy.props.BoolProperty(default=False)",
            "lineNumber": 44
          },
          {
            "text": "    worlds: bpy.props.BoolProperty(default=False)",
            "lineNumber": 45
          },
          {
            "lineNumber": 46
          },
          {
            "text": "    # inspect data-block search fields",
            "lineNumber": 47
          },
          {
            "text": "    collections_field: bpy.props.StringProperty(",
            "lineNumber": 48
          },
          {
            "text": "        update=inspect_ui.update_inspection)",
            "lineNumber": 49
          },
          {
            "lineNumber": 50
          },
          {
            "text": "    images_field: bpy.props.StringProperty(",
            "lineNumber": 51
          },
          {
            "text": "        update=inspect_ui.update_inspection)",
            "lineNumber": 52
          },
          {
            "lineNumber": 53
          },
          {
            "text": "    lights_field: bpy.props.StringProperty(",
            "lineNumber": 54
          },
          {
            "text": "        update=inspect_ui.update_inspection)",
            "lineNumber": 55
          },
          {
            "lineNumber": 56
          },
          {
            "text": "    materials_field: bpy.props.StringProperty(",
            "lineNumber": 57
          },
          {
            "text": "        update=inspect_ui.update_inspection)",
            "lineNumber": 58
          },
          {
            "lineNumber": 59
          },
          {
            "text": "    node_groups_field: bpy.props.StringProperty(",
            "lineNumber": 60
          },
          {
            "text": "        update=inspect_ui.update_inspection)",
            "lineNumber": 61
          },
          {
            "lineNumber": 62
          },
          {
            "text": "    particles_field: bpy.props.StringProperty(",
            "lineNumber": 63
          },
          {
            "text": "        update=inspect_ui.update_inspection)",
            "lineNumber": 64
          },
          {
            "lineNumber": 65
          },
          {
            "text": "    textures_field: bpy.props.StringProperty(",
            "lineNumber": 66
          },
          {
            "text": "        update=inspect_ui.update_inspection)",
            "lineNumber": 67
          },
          {
            "lineNumber": 68
          },
          {
            "text": "    worlds_field: bpy.props.StringProperty(",
            "lineNumber": 69
          },
          {
            "text": "        update=inspect_ui.update_inspection)",
            "lineNumber": 70
          },
          {
            "lineNumber": 71
          },
          {
            "text": "    # enum for the inspection mode that is currently active",
            "lineNumber": 72
          }
        ]
      },
      "score": 0.05758463963866234
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ui\\__init__.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 51
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file handles the registration of the atomic_data_manager.ui package\n\n\"\"\"\n\nfrom . import main_panel_ui\nfrom . import stats_panel_ui\nfrom . import inspect_ui\nfrom . import missing_file_ui\nfrom . import missing_file_ui\nfrom . import pie_menu_ui\nfrom . import preferences_ui\n\n\ndef register():\n    # register preferences first so we can access variables in config.py\n    preferences_ui.register()\n\n    # register everything else\n    main_panel_ui.register()\n    stats_panel_ui.register()\n    inspect_ui.register()\n    missing_file_ui.register()\n    pie_menu_ui.register()\n\n\ndef unregister():\n    main_panel_ui.unregister()\n    stats_panel_ui.unregister()",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file handles the registration of the atomic_data_manager.ui package",
            "lineNumber": 21
          },
          {
            "lineNumber": 22
          },
          {
            "text": "\"\"\"",
            "lineNumber": 23
          },
          {
            "lineNumber": 24
          },
          {
            "text": "from . import main_panel_ui",
            "lineNumber": 25
          },
          {
            "text": "from . import stats_panel_ui",
            "lineNumber": 26
          },
          {
            "text": "from . import inspect_ui",
            "lineNumber": 27
          },
          {
            "text": "from . import missing_file_ui",
            "lineNumber": 28
          },
          {
            "text": "from . import missing_file_ui",
            "lineNumber": 29
          },
          {
            "text": "from . import pie_menu_ui",
            "lineNumber": 30
          },
          {
            "text": "from . import preferences_ui",
            "lineNumber": 31
          },
          {
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "text": "def register():",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "    # register preferences first so we can access variables in config.py",
            "lineNumber": 35,
            "isSignature": true
          },
          {
            "text": "    preferences_ui.register()",
            "lineNumber": 36
          },
          {
            "lineNumber": 37
          },
          {
            "text": "    # register everything else",
            "lineNumber": 38
          },
          {
            "text": "    main_panel_ui.register()",
            "lineNumber": 39
          },
          {
            "text": "    stats_panel_ui.register()",
            "lineNumber": 40
          },
          {
            "text": "    inspect_ui.register()",
            "lineNumber": 41
          },
          {
            "text": "    missing_file_ui.register()",
            "lineNumber": 42
          },
          {
            "text": "    pie_menu_ui.register()",
            "lineNumber": 43,
            "isSignature": true
          },
          {
            "lineNumber": 44
          },
          {
            "lineNumber": 45
          },
          {
            "text": "def unregister():",
            "lineNumber": 46,
            "isSignature": true
          },
          {
            "text": "    main_panel_ui.unregister()",
            "lineNumber": 47
          },
          {
            "text": "    stats_panel_ui.unregister()",
            "lineNumber": 48
          }
        ]
      },
      "score": 0.0571785606443882
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ui\\main_panel_ui.py",
        "range": {
          "startPosition": {
            "line": 32,
            "column": 29
          },
          "endPosition": {
            "line": 231
          }
        },
        "contents": "# Atomic Data Manager Main Panel\nclass ATOMIC_PT_main_panel(bpy.types.Panel):\n    \"\"\"The main Atomic Data Manager panel\"\"\"\n    bl_label = \"Atomic Data Manager\"\n    bl_space_type = \"PROPERTIES\"\n    bl_region_type = \"WINDOW\"\n    bl_context = \"scene\"\n\n    def draw(self, context):\n        layout = self.layout\n        atom = bpy.context.scene.atomic\n        category_props = [\n            atom.collections,\n            atom.images,\n            atom.lights,\n            atom.materials,\n            atom.node_groups,\n            atom.particles,\n            atom.textures,\n            atom.worlds\n        ]\n\n        # nuke and clean buttons\n        row = layout.row(align=True)\n        row.scale_y = 2.0\n        row.operator(\"atomic.nuke\", text=\"Nuke\", icon=\"GHOST_ENABLED\")\n        row.operator(\"atomic.clean\", text=\"Clean\", icon=\"PARTICLEMODE\")\n        row.operator(\"atomic.undo\", text=\"Undo\", icon=\"LOOP_BACK\")\n\n        row = layout.row()\n\n        # category toggles\n        split = layout.split(align=False)\n\n        # left column\n        col = split.column(align=True)\n\n        # collections buttons\n        splitcol = col.split(factor=0.8, align=True)\n\n        splitcol.prop(\n            atom,\n            \"collections\",\n            text=\"Collections\",\n            icon='GROUP',\n            toggle=True\n        )\n\n        splitcol.operator(\n            \"atomic.inspect_collections\",\n            icon='VIEWZOOM',\n            text=\"\"\n        )\n\n        # lights buttons\n        splitcol = col.split(factor=0.8, align=True)\n\n        splitcol.prop(\n            atom,\n            \"lights\",\n            text=\"Lights\",\n            icon='LIGHT',\n            toggle=True\n        )\n\n        splitcol.operator(\n            \"atomic.inspect_lights\",\n            icon='VIEWZOOM',\n            text=\"\"\n        )\n\n        # node groups buttons\n        splitcol = col.split(factor=0.8, align=True)\n\n        splitcol.prop(\n            atom,\n            \"node_groups\",",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Main Panel",
            "lineNumber": 36
          },
          {
            "text": "class ATOMIC_PT_main_panel(bpy.types.Panel):",
            "lineNumber": 37,
            "isSignature": true
          },
          {
            "text": "    \"\"\"The main Atomic Data Manager panel\"\"\"",
            "lineNumber": 38
          },
          {
            "text": "    bl_label = \"Atomic Data Manager\"",
            "lineNumber": 39
          },
          {
            "text": "    bl_space_type = \"PROPERTIES\"",
            "lineNumber": 40
          },
          {
            "text": "    bl_region_type = \"WINDOW\"",
            "lineNumber": 41
          },
          {
            "text": "    bl_context = \"scene\"",
            "lineNumber": 42
          },
          {
            "lineNumber": 43
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 44
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 45
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 46
          },
          {
            "text": "        category_props = [",
            "lineNumber": 47
          },
          {
            "text": "            atom.collections,",
            "lineNumber": 48
          },
          {
            "text": "            atom.images,",
            "lineNumber": 49
          },
          {
            "text": "            atom.lights,",
            "lineNumber": 50
          },
          {
            "text": "            atom.materials,",
            "lineNumber": 51
          },
          {
            "text": "            atom.node_groups,",
            "lineNumber": 52
          },
          {
            "text": "            atom.particles,",
            "lineNumber": 53
          },
          {
            "text": "            atom.textures,",
            "lineNumber": 54
          },
          {
            "text": "            atom.worlds",
            "lineNumber": 55
          },
          {
            "text": "        ]",
            "lineNumber": 56
          },
          {
            "lineNumber": 57
          },
          {
            "text": "        # nuke and clean buttons",
            "lineNumber": 58
          },
          {
            "text": "        row = layout.row(align=True)",
            "lineNumber": 59
          },
          {
            "text": "        row.scale_y = 2.0",
            "lineNumber": 60
          },
          {
            "text": "        row.operator(\"atomic.nuke\", text=\"Nuke\", icon=\"GHOST_ENABLED\")",
            "lineNumber": 61
          },
          {
            "text": "        row.operator(\"atomic.clean\", text=\"Clean\", icon=\"PARTICLEMODE\")",
            "lineNumber": 62
          },
          {
            "text": "        row.operator(\"atomic.undo\", text=\"Undo\", icon=\"LOOP_BACK\")",
            "lineNumber": 63
          },
          {
            "lineNumber": 64
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 65
          },
          {
            "lineNumber": 66
          },
          {
            "text": "        # category toggles",
            "lineNumber": 67
          },
          {
            "text": "        split = layout.split(align=False)",
            "lineNumber": 68
          },
          {
            "lineNumber": 69
          },
          {
            "text": "        # left column",
            "lineNumber": 70
          },
          {
            "text": "        col = split.column(align=True)",
            "lineNumber": 71
          },
          {
            "lineNumber": 72
          },
          {
            "text": "        # collections buttons",
            "lineNumber": 73
          },
          {
            "text": "        splitcol = col.split(factor=0.8, align=True)",
            "lineNumber": 74
          },
          {
            "lineNumber": 75
          },
          {
            "text": "        splitcol.prop(",
            "lineNumber": 76
          },
          {
            "text": "            atom,",
            "lineNumber": 77
          },
          {
            "text": "            \"collections\",",
            "lineNumber": 78
          },
          {
            "text": "            text=\"Collections\",",
            "lineNumber": 79
          },
          {
            "text": "            icon='GROUP',",
            "lineNumber": 80
          },
          {
            "text": "            toggle=True",
            "lineNumber": 81
          },
          {
            "text": "        )",
            "lineNumber": 82
          },
          {
            "lineNumber": 83
          },
          {
            "text": "        splitcol.operator(",
            "lineNumber": 84
          },
          {
            "text": "            \"atomic.inspect_collections\",",
            "lineNumber": 85
          },
          {
            "text": "            icon='VIEWZOOM',",
            "lineNumber": 86
          },
          {
            "text": "            text=\"\"",
            "lineNumber": 87
          },
          {
            "text": "        )",
            "lineNumber": 88
          },
          {
            "lineNumber": 89
          },
          {
            "text": "        # lights buttons",
            "lineNumber": 90
          },
          {
            "text": "        splitcol = col.split(factor=0.8, align=True)",
            "lineNumber": 91
          },
          {
            "lineNumber": 92
          },
          {
            "text": "        splitcol.prop(",
            "lineNumber": 93
          },
          {
            "text": "            atom,",
            "lineNumber": 94
          },
          {
            "text": "            \"lights\",",
            "lineNumber": 95
          },
          {
            "text": "            text=\"Lights\",",
            "lineNumber": 96
          },
          {
            "text": "            icon='LIGHT',",
            "lineNumber": 97
          },
          {
            "text": "            toggle=True",
            "lineNumber": 98
          },
          {
            "text": "        )",
            "lineNumber": 99
          },
          {
            "lineNumber": 100
          },
          {
            "text": "        splitcol.operator(",
            "lineNumber": 101
          },
          {
            "text": "            \"atomic.inspect_lights\",",
            "lineNumber": 102
          },
          {
            "text": "            icon='VIEWZOOM',",
            "lineNumber": 103
          },
          {
            "text": "            text=\"\"",
            "lineNumber": 104
          },
          {
            "text": "        )",
            "lineNumber": 105
          },
          {
            "lineNumber": 106
          },
          {
            "text": "        # node groups buttons",
            "lineNumber": 107
          },
          {
            "text": "        splitcol = col.split(factor=0.8, align=True)",
            "lineNumber": 108
          },
          {
            "lineNumber": 109
          },
          {
            "text": "        splitcol.prop(",
            "lineNumber": 110
          },
          {
            "text": "            atom,",
            "lineNumber": 111
          },
          {
            "text": "            \"node_groups\",",
            "lineNumber": 112
          }
        ]
      },
      "score": 0.057176198810338974
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 346,
            "column": 26
          },
          "endPosition": {
            "line": 403
          }
        },
        "contents": "def image_geometry_nodes(image_key):\n    # returns a list of object keys that use the image through Geometry Nodes\n\n    users = []\n    image = bpy.data.images[image_key]\n\n    # list of node groups that use this image\n    node_group_users = image_node_groups(image_key)\n\n    # Import compat module for version-safe geometry nodes access\n    from ..utils import compat\n\n    for obj in bpy.data.objects:\n        # check Geometry Nodes modifiers\n        if hasattr(obj, 'modifiers'):\n            for modifier in obj.modifiers:\n                if compat.is_geometry_nodes_modifier(modifier):\n                    ng = compat.get_geometry_nodes_modifier_node_group(modifier)\n                    if ng:\n                        # direct usage in the modifier's tree\n                        if node_group_has_image(ng.name, image.name):\n                            users.append(obj.name)\n                        # usage via nested node groups\n                        elif ng.name in node_group_users:\n                            users.append(obj.name)\n\n    return distinct(users)\n\n\ndef image_worlds(image_key):\n    # returns a list of world keys that use the image\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def image_geometry_nodes(image_key):",
            "lineNumber": 350,
            "isSignature": true
          },
          {
            "text": "    # returns a list of object keys that use the image through Geometry Nodes",
            "lineNumber": 351,
            "isSignature": true
          },
          {
            "lineNumber": 352
          },
          {
            "text": "    users = []",
            "lineNumber": 353
          },
          {
            "text": "    image = bpy.data.images[image_key]",
            "lineNumber": 354
          },
          {
            "lineNumber": 355
          },
          {
            "text": "    # list of node groups that use this image",
            "lineNumber": 356
          },
          {
            "text": "    node_group_users = image_node_groups(image_key)",
            "lineNumber": 357
          },
          {
            "lineNumber": 358
          },
          {
            "text": "    # Import compat module for version-safe geometry nodes access",
            "lineNumber": 359
          },
          {
            "text": "    from ..utils import compat",
            "lineNumber": 360
          },
          {
            "lineNumber": 361
          },
          {
            "text": "    for obj in bpy.data.objects:",
            "lineNumber": 362
          },
          {
            "text": "        # check Geometry Nodes modifiers",
            "lineNumber": 363
          },
          {
            "text": "        if hasattr(obj, 'modifiers'):",
            "lineNumber": 364
          },
          {
            "text": "            for modifier in obj.modifiers:",
            "lineNumber": 365
          },
          {
            "text": "                if compat.is_geometry_nodes_modifier(modifier):",
            "lineNumber": 366
          },
          {
            "text": "                    ng = compat.get_geometry_nodes_modifier_node_group(modifier)",
            "lineNumber": 367
          },
          {
            "text": "                    if ng:",
            "lineNumber": 368
          },
          {
            "text": "                        # direct usage in the modifier's tree",
            "lineNumber": 369
          },
          {
            "text": "                        if node_group_has_image(ng.name, image.name):",
            "lineNumber": 370
          },
          {
            "text": "                            users.append(obj.name)",
            "lineNumber": 371
          },
          {
            "text": "                        # usage via nested node groups",
            "lineNumber": 372
          },
          {
            "text": "                        elif ng.name in node_group_users:",
            "lineNumber": 373
          },
          {
            "text": "                            users.append(obj.name)",
            "lineNumber": 374
          },
          {
            "lineNumber": 375
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 376,
            "isSignature": true
          },
          {
            "lineNumber": 377
          },
          {
            "lineNumber": 378
          },
          {
            "text": "def image_worlds(image_key):",
            "lineNumber": 379,
            "isSignature": true
          },
          {
            "text": "    # returns a list of world keys that use the image",
            "lineNumber": 380,
            "isSignature": true
          },
          {
            "lineNumber": 381
          },
          {
            "text": "    ",
            "lineNumber": 382
          }
        ]
      },
      "score": 0.05591220036149025
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\__init__.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 199
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains Atomic's global properties and handles the\nregistration for all packages within the add-on.\n\n\"\"\"\n\nimport bpy\nfrom bpy.utils import register_class\nfrom .utils import compat\nfrom . import ops\nfrom . import ui\nfrom .ui import inspect_ui\nfrom . import rainys_repo_bootstrap\n\n\n# Atomic Data Manager Properties\nclass ATOMIC_PG_main(bpy.types.PropertyGroup):\n    # main panel toggle buttons\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains Atomic's global properties and handles the",
            "lineNumber": 21
          },
          {
            "text": "registration for all packages within the add-on.",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "\"\"\"",
            "lineNumber": 24
          },
          {
            "lineNumber": 25
          },
          {
            "text": "import bpy",
            "lineNumber": 26
          },
          {
            "text": "from bpy.utils import register_class",
            "lineNumber": 27
          },
          {
            "text": "from .utils import compat",
            "lineNumber": 28
          },
          {
            "text": "from . import ops",
            "lineNumber": 29
          },
          {
            "text": "from . import ui",
            "lineNumber": 30
          },
          {
            "text": "from .ui import inspect_ui",
            "lineNumber": 31
          },
          {
            "text": "from . import rainys_repo_bootstrap",
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "lineNumber": 34
          },
          {
            "text": "# Atomic Data Manager Properties",
            "lineNumber": 35
          },
          {
            "text": "class ATOMIC_PG_main(bpy.types.PropertyGroup):",
            "lineNumber": 36,
            "isSignature": true
          },
          {
            "text": "    # main panel toggle buttons",
            "lineNumber": 37,
            "isSignature": true
          },
          {
            "text": "    ",
            "lineNumber": 38
          }
        ]
      },
      "score": 0.055021461099386215
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 755,
            "column": 22
          },
          "endPosition": {
            "line": 786,
            "column": 4
          }
        },
        "contents": "def node_group_has_material(node_group_key, material_key):\n    # returns true if a node group contains this material (directly or nested)\n\n    has_material = False\n    node_group = bpy.data.node_groups[node_group_key]\n    material = bpy.data.materials[material_key]\n\n    for node in node_group.nodes:\n        # base case: nodes with a material property (e.g., Set Material)\n        if hasattr(node, 'material') and node.material:\n            if node.material.name == material.name:\n                has_material = True\n\n        # recurse case: nested node groups\n        elif hasattr(node, 'node_tree') and node.node_tree:\n            has_material = node_group_has_material(\n                node.node_tree.name, material.name)\n\n        if has_material:\n            break\n\n    return has_material\n\n\ndef particle_all(particle_key):\n    # returns a list of keys of every data-block that uses this particle\n    # system\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_group_has_material(node_group_key, material_key):",
            "lineNumber": 759,
            "isSignature": true
          },
          {
            "text": "    # returns true if a node group contains this material (directly or nested)",
            "lineNumber": 760,
            "isSignature": true
          },
          {
            "lineNumber": 761
          },
          {
            "text": "    has_material = False",
            "lineNumber": 762
          },
          {
            "text": "    node_group = bpy.data.node_groups[node_group_key]",
            "lineNumber": 763
          },
          {
            "text": "    material = bpy.data.materials[material_key]",
            "lineNumber": 764
          },
          {
            "lineNumber": 765
          },
          {
            "text": "    for node in node_group.nodes:",
            "lineNumber": 766
          },
          {
            "text": "        # base case: nodes with a material property (e.g., Set Material)",
            "lineNumber": 767
          },
          {
            "text": "        if hasattr(node, 'material') and node.material:",
            "lineNumber": 768
          },
          {
            "text": "            if node.material.name == material.name:",
            "lineNumber": 769
          },
          {
            "text": "                has_material = True",
            "lineNumber": 770
          },
          {
            "lineNumber": 771
          },
          {
            "text": "        # recurse case: nested node groups",
            "lineNumber": 772
          },
          {
            "text": "        elif hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 773
          },
          {
            "text": "            has_material = node_group_has_material(",
            "lineNumber": 774
          },
          {
            "text": "                node.node_tree.name, material.name)",
            "lineNumber": 775
          },
          {
            "lineNumber": 776
          },
          {
            "text": "        if has_material:",
            "lineNumber": 777
          },
          {
            "text": "            break",
            "lineNumber": 778
          },
          {
            "lineNumber": 779
          },
          {
            "text": "    return has_material",
            "lineNumber": 780,
            "isSignature": true
          },
          {
            "lineNumber": 781
          },
          {
            "lineNumber": 782
          },
          {
            "text": "def particle_all(particle_key):",
            "lineNumber": 783,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of every data-block that uses this particle",
            "lineNumber": 784,
            "isSignature": true
          },
          {
            "text": "    # system",
            "lineNumber": 785,
            "isSignature": true
          },
          {
            "lineNumber": 786
          },
          {
            "text": "    ",
            "lineNumber": 787,
            "isSignature": true
          }
        ]
      },
      "score": 0.0527414008975029
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\inspect_ops.py",
        "range": {
          "startPosition": {
            "line": 140
          },
          "endPosition": {
            "line": 363
          }
        },
        "contents": "class ATOMIC_OT_inspection_replace(bpy.types.Operator):\ndef execute(self, context):\n\n\n        if inspection == 'PARTICLES' and \\\n                atom.replace_field in bpy.data.particles.keys():\n            particle = bpy.data.particles[atom.particles_field]\n            error = _check_library_or_override(particle)\n            if error:\n                self.report({'ERROR'}, error)\n                return {'CANCELLED'}\n            particle.user_remap(bpy.data.particles[atom.replace_field])\n            atom.particles_field = atom.replace_field\n\n        if inspection == 'TEXTURES' and \\\n                atom.replace_field in bpy.data.textures.keys():\n            texture = bpy.data.textures[atom.textures_field]\n            error = _check_library_or_override(texture)\n            if error:\n                self.report({'ERROR'}, error)\n                return {'CANCELLED'}\n            texture.user_remap(bpy.data.textures[atom.replace_field])\n            atom.textures_field = atom.replace_field\n\n        if inspection == 'WORLDS' and \\\n                atom.replace_field in bpy.data.worlds.keys():\n            world = bpy.data.worlds[atom.worlds_field]\n            error = _check_library_or_override(world)\n            if error:\n                self.report({'ERROR'}, error)\n                return {'CANCELLED'}\n            world.user_remap(bpy.data.worlds[atom.replace_field])\n            atom.worlds_field = atom.replace_field\n\n        atom.replace_field = \"\"\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        return wm.invoke_props_dialog(self, width=200)\n\n\n# Atomic Data Manager Inspection Toggle Fake User Operator\nclass ATOMIC_OT_inspection_toggle_fake_user(bpy.types.Operator):\n    \"\"\"Save this data-block even if it has no users\"\"\"",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 141,
                "column": 1
              },
              "endPosition": {
                "line": 142,
                "column": 5
              }
            },
            {
              "startPosition": {
                "line": 216,
                "column": 5
              },
              "endPosition": {
                "line": 217,
                "column": 9
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_OT_inspection_replace(bpy.types.Operator):",
            "lineNumber": 141,
            "isSignature": true
          },
          {
            "text": "def execute(self, context):",
            "lineNumber": 216
          },
          {
            "lineNumber": 258
          },
          {
            "lineNumber": 259
          },
          {
            "text": "        if inspection == 'PARTICLES' and \\",
            "lineNumber": 260
          },
          {
            "text": "                atom.replace_field in bpy.data.particles.keys():",
            "lineNumber": 261
          },
          {
            "text": "            particle = bpy.data.particles[atom.particles_field]",
            "lineNumber": 262
          },
          {
            "text": "            error = _check_library_or_override(particle)",
            "lineNumber": 263
          },
          {
            "text": "            if error:",
            "lineNumber": 264
          },
          {
            "text": "                self.report({'ERROR'}, error)",
            "lineNumber": 265
          },
          {
            "text": "                return {'CANCELLED'}",
            "lineNumber": 266
          },
          {
            "text": "            particle.user_remap(bpy.data.particles[atom.replace_field])",
            "lineNumber": 267
          },
          {
            "text": "            atom.particles_field = atom.replace_field",
            "lineNumber": 268
          },
          {
            "lineNumber": 269
          },
          {
            "text": "        if inspection == 'TEXTURES' and \\",
            "lineNumber": 270
          },
          {
            "text": "                atom.replace_field in bpy.data.textures.keys():",
            "lineNumber": 271
          },
          {
            "text": "            texture = bpy.data.textures[atom.textures_field]",
            "lineNumber": 272
          },
          {
            "text": "            error = _check_library_or_override(texture)",
            "lineNumber": 273
          },
          {
            "text": "            if error:",
            "lineNumber": 274
          },
          {
            "text": "                self.report({'ERROR'}, error)",
            "lineNumber": 275
          },
          {
            "text": "                return {'CANCELLED'}",
            "lineNumber": 276
          },
          {
            "text": "            texture.user_remap(bpy.data.textures[atom.replace_field])",
            "lineNumber": 277
          },
          {
            "text": "            atom.textures_field = atom.replace_field",
            "lineNumber": 278
          },
          {
            "lineNumber": 279
          },
          {
            "text": "        if inspection == 'WORLDS' and \\",
            "lineNumber": 280
          },
          {
            "text": "                atom.replace_field in bpy.data.worlds.keys():",
            "lineNumber": 281
          },
          {
            "text": "            world = bpy.data.worlds[atom.worlds_field]",
            "lineNumber": 282
          },
          {
            "text": "            error = _check_library_or_override(world)",
            "lineNumber": 283
          },
          {
            "text": "            if error:",
            "lineNumber": 284
          },
          {
            "text": "                self.report({'ERROR'}, error)",
            "lineNumber": 285
          },
          {
            "text": "                return {'CANCELLED'}",
            "lineNumber": 286
          },
          {
            "text": "            world.user_remap(bpy.data.worlds[atom.replace_field])",
            "lineNumber": 287
          },
          {
            "text": "            atom.worlds_field = atom.replace_field",
            "lineNumber": 288
          },
          {
            "lineNumber": 289
          },
          {
            "text": "        atom.replace_field = \"\"",
            "lineNumber": 290
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 291
          },
          {
            "lineNumber": 292
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 293
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 294
          },
          {
            "text": "        return wm.invoke_props_dialog(self, width=200)",
            "lineNumber": 295,
            "isSignature": true
          },
          {
            "lineNumber": 296
          },
          {
            "lineNumber": 297
          },
          {
            "text": "# Atomic Data Manager Inspection Toggle Fake User Operator",
            "lineNumber": 298
          },
          {
            "text": "class ATOMIC_OT_inspection_toggle_fake_user(bpy.types.Operator):",
            "lineNumber": 299,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Save this data-block even if it has no users\"\"\"",
            "lineNumber": 300
          }
        ]
      },
      "score": 0.05209499970078468
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\config.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 41,
            "column": 22
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains global copies of Atomic's preferences so that they\ncan be easily access throughout the add-on.\n\nNOTE:\nChanging the values of these variables will NOT change the values in the\nAtomic's preferences. If you want to change a setting, change it in\nBlender, not in here.\n\n\"\"\"\n\n# visible atomic preferences\nenable_missing_file_warning = True\ninclude_fake_users = False\nenable_pie_menu_ui = True\n\n# hidden atomic preferences\npie_menu_type = \"D\"\npie_menu_alt = False\npie_menu_any = False\npie_menu_ctrl = False\npie_menu_oskey = False\npie_menu_shift = False",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains global copies of Atomic's preferences so that they",
            "lineNumber": 21
          },
          {
            "text": "can be easily access throughout the add-on.",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "NOTE:",
            "lineNumber": 24
          },
          {
            "text": "Changing the values of these variables will NOT change the values in the",
            "lineNumber": 25
          },
          {
            "text": "Atomic's preferences. If you want to change a setting, change it in",
            "lineNumber": 26
          },
          {
            "text": "Blender, not in here.",
            "lineNumber": 27
          },
          {
            "lineNumber": 28
          },
          {
            "text": "\"\"\"",
            "lineNumber": 29
          },
          {
            "lineNumber": 30
          },
          {
            "text": "# visible atomic preferences",
            "lineNumber": 31
          },
          {
            "text": "enable_missing_file_warning = True",
            "lineNumber": 32
          },
          {
            "text": "include_fake_users = False",
            "lineNumber": 33
          },
          {
            "text": "enable_pie_menu_ui = True",
            "lineNumber": 34
          },
          {
            "lineNumber": 35
          },
          {
            "text": "# hidden atomic preferences",
            "lineNumber": 36
          },
          {
            "text": "pie_menu_type = \"D\"",
            "lineNumber": 37
          },
          {
            "text": "pie_menu_alt = False",
            "lineNumber": 38
          },
          {
            "text": "pie_menu_any = False",
            "lineNumber": 39
          },
          {
            "text": "pie_menu_ctrl = False",
            "lineNumber": 40
          },
          {
            "text": "pie_menu_oskey = False",
            "lineNumber": 41
          },
          {
            "text": "pie_menu_shift = False",
            "lineNumber": 42
          }
        ]
      },
      "score": 0.051850300282239914
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 213,
            "column": 42
          },
          "endPosition": {
            "line": 286
          }
        },
        "contents": "def image_compositors(image_key):\n    # returns a list containing \"Compositor\" if the image is used in\n    # the scene's compositor\n\n    users = []\n    image = bpy.data.images[image_key]\n\n    # a list of node groups that use our image\n    node_group_users = image_node_groups(image_key)\n\n    # Import compat module for version-safe compositor access\n    from ..utils import compat\n\n    # if our compositor uses nodes and has a valid node tree\n    scene = bpy.context.scene\n    if scene.use_nodes:\n        node_tree = compat.get_scene_compositor_node_tree(scene)\n        if node_tree:\n            # check each node in the compositor\n            for node in node_tree.nodes:\n\n                # if the node is an image node with a valid image\n                if hasattr(node, 'image') and node.image:\n\n                    # if the node's image is our image\n                    if node.image.name == image.name:\n                        users.append(\"Compositor\")\n\n                # if the node is a group node with a valid node tree\n                elif hasattr(node, 'node_tree') and node.node_tree:\n\n                    # if the node tree's name is in our list of node group\n                    # users\n                    if node.node_tree.name in node_group_users:\n                        users.append(\"Compositor\")\n\n    return distinct(users)\n\n\ndef image_materials(image_key):\n    # returns a list of material keys that use the image\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def image_compositors(image_key):",
            "lineNumber": 217,
            "isSignature": true
          },
          {
            "text": "    # returns a list containing \"Compositor\" if the image is used in",
            "lineNumber": 218,
            "isSignature": true
          },
          {
            "text": "    # the scene's compositor",
            "lineNumber": 219,
            "isSignature": true
          },
          {
            "lineNumber": 220
          },
          {
            "text": "    users = []",
            "lineNumber": 221
          },
          {
            "text": "    image = bpy.data.images[image_key]",
            "lineNumber": 222
          },
          {
            "lineNumber": 223
          },
          {
            "text": "    # a list of node groups that use our image",
            "lineNumber": 224
          },
          {
            "text": "    node_group_users = image_node_groups(image_key)",
            "lineNumber": 225
          },
          {
            "lineNumber": 226
          },
          {
            "text": "    # Import compat module for version-safe compositor access",
            "lineNumber": 227
          },
          {
            "text": "    from ..utils import compat",
            "lineNumber": 228
          },
          {
            "lineNumber": 229
          },
          {
            "text": "    # if our compositor uses nodes and has a valid node tree",
            "lineNumber": 230
          },
          {
            "text": "    scene = bpy.context.scene",
            "lineNumber": 231
          },
          {
            "text": "    if scene.use_nodes:",
            "lineNumber": 232
          },
          {
            "text": "        node_tree = compat.get_scene_compositor_node_tree(scene)",
            "lineNumber": 233
          },
          {
            "text": "        if node_tree:",
            "lineNumber": 234
          },
          {
            "text": "            # check each node in the compositor",
            "lineNumber": 235
          },
          {
            "text": "            for node in node_tree.nodes:",
            "lineNumber": 236
          },
          {
            "lineNumber": 237
          },
          {
            "text": "                # if the node is an image node with a valid image",
            "lineNumber": 238
          },
          {
            "text": "                if hasattr(node, 'image') and node.image:",
            "lineNumber": 239
          },
          {
            "lineNumber": 240
          },
          {
            "text": "                    # if the node's image is our image",
            "lineNumber": 241
          },
          {
            "text": "                    if node.image.name == image.name:",
            "lineNumber": 242
          },
          {
            "text": "                        users.append(\"Compositor\")",
            "lineNumber": 243
          },
          {
            "lineNumber": 244
          },
          {
            "text": "                # if the node is a group node with a valid node tree",
            "lineNumber": 245
          },
          {
            "text": "                elif hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 246
          },
          {
            "lineNumber": 247
          },
          {
            "text": "                    # if the node tree's name is in our list of node group",
            "lineNumber": 248
          },
          {
            "text": "                    # users",
            "lineNumber": 249
          },
          {
            "text": "                    if node.node_tree.name in node_group_users:",
            "lineNumber": 250
          },
          {
            "text": "                        users.append(\"Compositor\")",
            "lineNumber": 251
          },
          {
            "lineNumber": 252
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 253,
            "isSignature": true
          },
          {
            "lineNumber": 254
          },
          {
            "lineNumber": 255
          },
          {
            "text": "def image_materials(image_key):",
            "lineNumber": 256,
            "isSignature": true
          },
          {
            "text": "    # returns a list of material keys that use the image",
            "lineNumber": 257,
            "isSignature": true
          },
          {
            "lineNumber": 258
          },
          {
            "text": "    ",
            "lineNumber": 259
          }
        ]
      },
      "score": 0.051310598850250244
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\utils\\duplicate.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 41
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains functions for duplicating data-blocks from Atomic's\ninspection interface.\n\n\"\"\"\n\nimport bpy\n\n\ndef duplicate_data(data, key):\n    # creates a copy of the specified data-block and returns its key\n    return data[key].copy().name\n\n\ndef collection(key):\n    # creates of copy of the specified collection and places it under the\n    # scene collection\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains functions for duplicating data-blocks from Atomic's",
            "lineNumber": 21
          },
          {
            "text": "inspection interface.",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "\"\"\"",
            "lineNumber": 24
          },
          {
            "lineNumber": 25
          },
          {
            "text": "import bpy",
            "lineNumber": 26
          },
          {
            "lineNumber": 27
          },
          {
            "lineNumber": 28
          },
          {
            "text": "def duplicate_data(data, key):",
            "lineNumber": 29,
            "isSignature": true
          },
          {
            "text": "    # creates a copy of the specified data-block and returns its key",
            "lineNumber": 30,
            "isSignature": true
          },
          {
            "text": "    return data[key].copy().name",
            "lineNumber": 31,
            "isSignature": true
          },
          {
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "text": "def collection(key):",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "    # creates of copy of the specified collection and places it under the",
            "lineNumber": 35,
            "isSignature": true
          },
          {
            "text": "    # scene collection",
            "lineNumber": 36,
            "isSignature": true
          },
          {
            "text": "    ",
            "lineNumber": 37
          }
        ]
      },
      "score": 0.05029803887009621
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\__init__.py",
        "range": {
          "startPosition": {
            "line": 199,
            "column": 45
          },
          "endPosition": {
            "line": 223
          }
        },
        "contents": "def register():\n    register_class(ATOMIC_PG_main)\n    bpy.types.Scene.atomic = bpy.props.PointerProperty(type=ATOMIC_PG_main)\n\n    # atomic package registration\n    ui.register()\n    ops.register()\n    \n    # bootstrap Rainy's Extensions repository\n    rainys_repo_bootstrap.register()\n\n\ndef unregister():\n    # bootstrap unregistration\n    rainys_repo_bootstrap.unregister()",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 36,
                "column": 1
              },
              "endPosition": {
                "line": 38,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "def register():",
            "lineNumber": 203,
            "isSignature": true
          },
          {
            "text": "    register_class(ATOMIC_PG_main)",
            "lineNumber": 204
          },
          {
            "text": "    bpy.types.Scene.atomic = bpy.props.PointerProperty(type=ATOMIC_PG_main)",
            "lineNumber": 205
          },
          {
            "lineNumber": 206
          },
          {
            "text": "    # atomic package registration",
            "lineNumber": 207
          },
          {
            "text": "    ui.register()",
            "lineNumber": 208
          },
          {
            "text": "    ops.register()",
            "lineNumber": 209
          },
          {
            "text": "    ",
            "lineNumber": 210
          },
          {
            "text": "    # bootstrap Rainy's Extensions repository",
            "lineNumber": 211
          },
          {
            "text": "    rainys_repo_bootstrap.register()",
            "lineNumber": 212,
            "isSignature": true
          },
          {
            "lineNumber": 213
          },
          {
            "lineNumber": 214
          },
          {
            "text": "def unregister():",
            "lineNumber": 215,
            "isSignature": true
          },
          {
            "text": "    # bootstrap unregistration",
            "lineNumber": 216,
            "isSignature": true
          },
          {
            "text": "    rainys_repo_bootstrap.unregister()",
            "lineNumber": 217
          }
        ]
      },
      "score": 0.04995189979672432
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 68
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains functions that return the keys of data-blocks that\nuse other data-blocks.\n\nThey are titled as such that the first part of the function name is the\ntype of the data being passed in and the second part of the function name\nis the users of that type.\n\ne.g. If you were searching for all of the places where an image is used in\na material would be searching for the image_materials() function.\n\n\"\"\"\n\nimport bpy\n\n\ndef collection_all(collection_key):\n    # returns a list of keys of every data-block that uses this collection\n\n    return collection_cameras(collection_key) + \\\n           collection_children(collection_key) + \\\n           collection_lights(collection_key) + \\\n           collection_meshes(collection_key) + \\\n           collection_others(collection_key) + \\\n           collection_rigidbody_world(collection_key) + \\\n           collection_scenes(collection_key)\n\n\ndef collection_cameras(collection_key):\n    # recursively returns a list of camera object keys that are in the\n    # collection and its child collections\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains functions that return the keys of data-blocks that",
            "lineNumber": 21
          },
          {
            "text": "use other data-blocks.",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "They are titled as such that the first part of the function name is the",
            "lineNumber": 24
          },
          {
            "text": "type of the data being passed in and the second part of the function name",
            "lineNumber": 25
          },
          {
            "text": "is the users of that type.",
            "lineNumber": 26
          },
          {
            "lineNumber": 27
          },
          {
            "text": "e.g. If you were searching for all of the places where an image is used in",
            "lineNumber": 28
          },
          {
            "text": "a material would be searching for the image_materials() function.",
            "lineNumber": 29
          },
          {
            "lineNumber": 30
          },
          {
            "text": "\"\"\"",
            "lineNumber": 31
          },
          {
            "lineNumber": 32
          },
          {
            "text": "import bpy",
            "lineNumber": 33
          },
          {
            "lineNumber": 34
          },
          {
            "lineNumber": 35
          },
          {
            "text": "def collection_all(collection_key):",
            "lineNumber": 36,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of every data-block that uses this collection",
            "lineNumber": 37,
            "isSignature": true
          },
          {
            "lineNumber": 38
          },
          {
            "text": "    return collection_cameras(collection_key) + \\",
            "lineNumber": 39
          },
          {
            "text": "           collection_children(collection_key) + \\",
            "lineNumber": 40
          },
          {
            "text": "           collection_lights(collection_key) + \\",
            "lineNumber": 41
          },
          {
            "text": "           collection_meshes(collection_key) + \\",
            "lineNumber": 42
          },
          {
            "text": "           collection_others(collection_key) + \\",
            "lineNumber": 43
          },
          {
            "text": "           collection_rigidbody_world(collection_key) + \\",
            "lineNumber": 44
          },
          {
            "text": "           collection_scenes(collection_key)",
            "lineNumber": 45,
            "isSignature": true
          },
          {
            "lineNumber": 46
          },
          {
            "lineNumber": 47
          },
          {
            "text": "def collection_cameras(collection_key):",
            "lineNumber": 48,
            "isSignature": true
          },
          {
            "text": "    # recursively returns a list of camera object keys that are in the",
            "lineNumber": 49,
            "isSignature": true
          },
          {
            "text": "    # collection and its child collections",
            "lineNumber": 50,
            "isSignature": true
          },
          {
            "lineNumber": 51
          },
          {
            "text": "    ",
            "lineNumber": 52
          }
        ]
      },
      "score": 0.04986400157213211
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\inspect_ops.py",
        "range": {
          "startPosition": {
            "line": 363,
            "column": 27
          },
          "endPosition": {
            "line": 480
          }
        },
        "contents": "# Atomic Data Manager Inspection Duplicate Operator\nclass ATOMIC_OT_inspection_duplicate(bpy.types.Operator):\n    \"\"\"Make an exact copy of this data-block\"\"\"\n    bl_idname = \"atomic.inspection_duplicate\"\n    bl_label = \"Duplicate Data-Block\"\n\n    def execute(self, context):\n        atom = bpy.context.scene.atomic\n        inspection = atom.active_inspection\n\n        if inspection == 'COLLECTIONS':\n            key = atom.collections_field\n            collections = bpy.data.collections\n\n            if key in collections.keys():\n                collection = collections[key]\n                error = _check_library_or_override(collection)\n                if error:\n                    self.report({'ERROR'}, error)\n                    return {'CANCELLED'}\n                copy_key = duplicate.collection(key)\n                atom.collections_field = copy_key\n\n        elif inspection == 'IMAGES':\n            key = atom.images_field\n            images = bpy.data.images\n\n            if key in images.keys():\n                image = images[key]\n                error = _check_library_or_override(image)\n                if error:\n                    self.report({'ERROR'}, error)\n                    return {'CANCELLED'}\n                copy_key = duplicate.image(key)\n                atom.images_field = copy_key\n\n        elif inspection == 'LIGHTS':\n            key = atom.lights_field\n            lights = bpy.data.lights\n\n            if key in lights.keys():\n                light = lights[key]\n                error = _check_library_or_override(light)\n                if error:\n                    self.report({'ERROR'}, error)\n                    return {'CANCELLED'}\n                copy_key = duplicate.light(key)\n                atom.lights_field = copy_key\n\n        elif inspection == 'MATERIALS':",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Inspection Duplicate Operator",
            "lineNumber": 367
          },
          {
            "text": "class ATOMIC_OT_inspection_duplicate(bpy.types.Operator):",
            "lineNumber": 368,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Make an exact copy of this data-block\"\"\"",
            "lineNumber": 369
          },
          {
            "text": "    bl_idname = \"atomic.inspection_duplicate\"",
            "lineNumber": 370
          },
          {
            "text": "    bl_label = \"Duplicate Data-Block\"",
            "lineNumber": 371
          },
          {
            "lineNumber": 372
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 373
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 374
          },
          {
            "text": "        inspection = atom.active_inspection",
            "lineNumber": 375
          },
          {
            "lineNumber": 376
          },
          {
            "text": "        if inspection == 'COLLECTIONS':",
            "lineNumber": 377
          },
          {
            "text": "            key = atom.collections_field",
            "lineNumber": 378
          },
          {
            "text": "            collections = bpy.data.collections",
            "lineNumber": 379
          },
          {
            "lineNumber": 380
          },
          {
            "text": "            if key in collections.keys():",
            "lineNumber": 381
          },
          {
            "text": "                collection = collections[key]",
            "lineNumber": 382
          },
          {
            "text": "                error = _check_library_or_override(collection)",
            "lineNumber": 383
          },
          {
            "text": "                if error:",
            "lineNumber": 384
          },
          {
            "text": "                    self.report({'ERROR'}, error)",
            "lineNumber": 385
          },
          {
            "text": "                    return {'CANCELLED'}",
            "lineNumber": 386
          },
          {
            "text": "                copy_key = duplicate.collection(key)",
            "lineNumber": 387
          },
          {
            "text": "                atom.collections_field = copy_key",
            "lineNumber": 388
          },
          {
            "lineNumber": 389
          },
          {
            "text": "        elif inspection == 'IMAGES':",
            "lineNumber": 390
          },
          {
            "text": "            key = atom.images_field",
            "lineNumber": 391
          },
          {
            "text": "            images = bpy.data.images",
            "lineNumber": 392
          },
          {
            "lineNumber": 393
          },
          {
            "text": "            if key in images.keys():",
            "lineNumber": 394
          },
          {
            "text": "                image = images[key]",
            "lineNumber": 395
          },
          {
            "text": "                error = _check_library_or_override(image)",
            "lineNumber": 396
          },
          {
            "text": "                if error:",
            "lineNumber": 397
          },
          {
            "text": "                    self.report({'ERROR'}, error)",
            "lineNumber": 398
          },
          {
            "text": "                    return {'CANCELLED'}",
            "lineNumber": 399
          },
          {
            "text": "                copy_key = duplicate.image(key)",
            "lineNumber": 400
          },
          {
            "text": "                atom.images_field = copy_key",
            "lineNumber": 401
          },
          {
            "lineNumber": 402
          },
          {
            "text": "        elif inspection == 'LIGHTS':",
            "lineNumber": 403
          },
          {
            "text": "            key = atom.lights_field",
            "lineNumber": 404
          },
          {
            "text": "            lights = bpy.data.lights",
            "lineNumber": 405
          },
          {
            "lineNumber": 406
          },
          {
            "text": "            if key in lights.keys():",
            "lineNumber": 407
          },
          {
            "text": "                light = lights[key]",
            "lineNumber": 408
          },
          {
            "text": "                error = _check_library_or_override(light)",
            "lineNumber": 409
          },
          {
            "text": "                if error:",
            "lineNumber": 410
          },
          {
            "text": "                    self.report({'ERROR'}, error)",
            "lineNumber": 411
          },
          {
            "text": "                    return {'CANCELLED'}",
            "lineNumber": 412
          },
          {
            "text": "                copy_key = duplicate.light(key)",
            "lineNumber": 413
          },
          {
            "text": "                atom.lights_field = copy_key",
            "lineNumber": 414
          },
          {
            "lineNumber": 415
          },
          {
            "text": "        elif inspection == 'MATERIALS':",
            "lineNumber": 416
          }
        ]
      },
      "score": 0.04950819909572601
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

Analyzing the issue: Smart Select and Clean run 8 sequential `unused.*_deep()` calls, which are slow. Blender's Python API isn't thread-safe, so we need a safe parallelization approach. Creating a plan to optimize this:


---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Analyze the performance bottleneck in Smart Select and Clean operations
- [-] Design a thread-safe parallelization approach for unused data detection
- [ ] Implement parallel execution for unused.*_deep() functions
- [ ] Update Smart Select operator to use parallel execution
- [ ] Update Clean operator invoke() to use parallel execution
- [ ] Test the performance improvements

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\ops\direct_use_ops.py</summary>

</details>
</tool-use>

---

Implementing a thread-safe parallelization approach. Since Blender's API isn't thread-safe, we'll use a lock around `bpy.data` access and parallelize the computation:


---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\stats\\unused_parallel.py"
}
```
Additional data:

```json
{
  "codeblockId": "be5b9217-a9cb-4cf9-ba80-ecf32bb909f5"
}
```
Status: **completed**


</details>
</tool-use>

---

Updating the Smart Select operator to use parallel execution:


---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\ops\\main_ops.py"
}
```
Additional data:

```json
{
  "codeblockId": "dc207270-82e0-4e76-bf04-097b1e8b32a6"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\ops\\main_ops.py"
}
```
Additional data:

```json
{
  "codeblockId": "7e42be84-9d3a-4145-b087-3ca116154fbd"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\ops\\main_ops.py"
}
```
Additional data:

```json
{
  "codeblockId": "59ddc1ae-bcca-456f-a38d-db9115b63b7e"
}
```
Status: **completed**


</details>
</tool-use>

---

Updating the Clean All operator in `direct_use_ops.py`:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\ops\direct_use_ops.py</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\ops\\direct_use_ops.py"
}
```
Additional data:

```json
{
  "codeblockId": "8f43c4e6-31d6-4d7b-85d7-25a4536f2c30"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\ops\\direct_use_ops.py"
}
```
Additional data:

```json
{
  "codeblockId": "2d5ded39-d5d4-4f2a-b153-7820c4a9ecbd"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Analyze the performance bottleneck in Smart Select and Clean operations
- [x] Design a thread-safe parallelization approach for unused data detection
- [x] Implement parallel execution for unused.*_deep() functions
- [x] Update Smart Select operator to use parallel execution
- [x] Update Clean operator invoke() to use parallel execution
- [ ] Test the performance improvements

</details>
</tool-use>

---

Checking if the stats module exports the new parallel module:


---

File not found

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "ops/main_ops.py",
    "ops/direct_use_ops.py",
    "stats/unused_parallel.py"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "ops/main_ops.py"
    },
    {
      "relativeWorkspacePath": "ops/direct_use_ops.py"
    },
    {
      "relativeWorkspacePath": "stats/unused_parallel.py"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

Searching for other sequential calls to these functions:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "unused\\.(collections|images|lights|materials|node_groups|particles|textures|worlds)_deep\\(\\)|unused\\.worlds\\(\\)",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "unused\\.(collections|images|lights|materials|node_groups|particles|textures|worlds)_deep\\(\\)|unused\\.worlds\\(\\)",
    "outputMode": "content",
    "workspaceResults": {
      "E:\\atomic_data_manager": {
        "content": {
          "matches": [
            {
              "file": "stats/count.py",
              "matches": [
                {
                  "lineNumber": 212,
                  "content": "    return len(unused.worlds())"
                }
              ]
            },
            {
              "file": "ops\\main_ops.py",
              "matches": [
                {
                  "lineNumber": 280,
                  "content": "            textures = sorted(unused.textures_deep())"
                }
              ]
            },
            {
              "file": "ops/main_ops.py",
              "matches": [
                {
                  "lineNumber": 280,
                  "content": "            textures = sorted(unused.textures_deep())"
                }
              ]
            },
            {
              "file": ".specstory/history/2025-12-16_23-24Z-blender-library-packed-files-error.md",
              "matches": [
                {
                  "lineNumber": 14503,
                  "content": "        \"contents\": \"class ATOMIC_OT_clean(bpy.types.Operator):\\n\\n\\n    def execute(self, context):\\n        atom = bpy.context.scene.atomic\\n\\n        if atom.collections:\\n            clean.collections()\\n\\n        if atom.images:\\n            clean.images()\\n\\n        if atom.lights:\\n            clean.lights()\\n\\n        if atom.materials:\\n            clean.materials()\\n\\n        if atom.node_groups:\\n            clean.node_groups()\\n\\n        if atom.particles:\\n            clean.particles()\\n\\n        if atom.textures:\\n            clean.textures()\\n\\n        if atom.worlds:\\n            clean.worlds()\\n\\n        bpy.ops.atomic.deselect_all()\\n\\n        return {'FINISHED'}\\n\\n    def invoke(self, context, event):\\n        wm = context.window_manager\\n        atom = bpy.context.scene.atomic\\n\\n        if atom.collections:\\n            self.unused_collections = unused.collections_deep()\\n\\n        if atom.images:\\n            self.unused_images = unused.images_deep()\\n\\n        i"
                },
                {
                  "lineNumber": 14663,
                  "content": "            \"text\": \"            self.unused_collections = unused.collections_deep()\","
                },
                {
                  "lineNumber": 14674,
                  "content": "            \"text\": \"            self.unused_images = unused.images_deep()\","
                },
                {
                  "lineNumber": 14685,
                  "content": "            \"text\": \"            self.unused_lights = unused.lights_deep()\","
                },
                {
                  "lineNumber": 14696,
                  "content": "            \"text\": \"            self.unused_materials = unused.materials_deep()\","
                },
                {
                  "lineNumber": 14707,
                  "content": "            \"text\": \"            self.unused_node_groups = unused.node_groups_deep()\","
                },
                {
                  "lineNumber": 14718,
                  "content": "            \"text\": \"            self.unused_particles = unused.particles_deep()\","
                },
                {
                  "lineNumber": 14729,
                  "content": "            \"text\": \"            self.unused_textures = unused.textures_deep()\","
                },
                {
                  "lineNumber": 14740,
                  "content": "            \"text\": \"            self.unused_worlds = unused.worlds()\","
                },
                {
                  "lineNumber": 15498,
                  "content": "        \"contents\": \"# Atomic Data Manager Smart Select Operator\\nclass ATOMIC_OT_smart_select(bpy.types.Operator):\\n    \\\"\\\"\\\"Auto-select categories with unused data\\\"\\\"\\\"\\n    bl_idname = \\\"atomic.smart_select\\\"\\n    bl_label = \\\"Smart Select\\\"\\n\\n    def execute(self, context):\\n\\n        bpy.context.scene.atomic.collections = \\\\\\n            any(unused.collections_deep())\\n\\n        bpy.context.scene.atomic.images = \\\\\\n            any(unused.images_deep())\\n\\n        bpy.context.scene.atomic.lights = \\\\\\n            any(unused.lights_deep())\\n\\n        bpy.context.scene.atomic.materials = \\\\\\n            any(unused.materials_deep())\\n\\n        bpy.context.scene.atomic.node_groups = \\\\\\n            any(unused.node_groups_deep())\\n\\n        bpy.context.scene.atomic.particles = \\\\\\n            any(unused.particles_deep())\\n\\n        bpy.context.scene.atomic.textures = \\\\\\n            any(unused.textures_deep())\\n\\n        bpy.context.scene.atomic.worlds = \\\\\\n            any(unused.w"
                },
                {
                  "lineNumber": 15537,
                  "content": "            \"text\": \"            any(unused.collections_deep())\","
                },
                {
                  "lineNumber": 15548,
                  "content": "            \"text\": \"            any(unused.images_deep())\","
                },
                {
                  "lineNumber": 15559,
                  "content": "            \"text\": \"            any(unused.lights_deep())\","
                },
                {
                  "lineNumber": 15570,
                  "content": "            \"text\": \"            any(unused.materials_deep())\","
                },
                {
                  "lineNumber": 15581,
                  "content": "            \"text\": \"            any(unused.node_groups_deep())\","
                },
                {
                  "lineNumber": 15592,
                  "content": "            \"text\": \"            any(unused.particles_deep())\","
                },
                {
                  "lineNumber": 15603,
                  "content": "            \"text\": \"            any(unused.textures_deep())\","
                },
                {
                  "lineNumber": 15614,
                  "content": "            \"text\": \"            any(unused.worlds())\","
                },
                {
                  "lineNumber": 15660,
                  "content": "        \"contents\": \"# Atomic Data Manager Clean All Operator\\nclass ATOMIC_OT_clean_all(bpy.types.Operator):\\n    \\\"\\\"\\\"Remove all unused data-blocks from the selected categories\\\"\\\"\\\"\\n    bl_idname = \\\"atomic.clean_all\\\"\\n    bl_label = \\\"Clean All\\\"\\n\\n    unused_collections = []\\n    unused_images = []\\n    unused_lights = []\\n    unused_materials = []\\n    unused_node_groups = []\\n    unused_particles = []\\n    unused_textures = []\\n    unused_worlds = []\\n\\n    def draw(self, context):\\n        layout = self.layout\\n\\n        col = layout.column()\\n        col.label(text=\\\"Remove the following data-blocks?\\\")\\n\\n        collections = sorted(unused.collections_deep())\\n        ui_layouts.box_list(\\n            layout=layout,\\n            title=\\\"Collections\\\",\\n            items=collections,\\n            icon=\\\"OUTLINER_OB_GROUP_INSTANCE\\\"\\n        )\\n\\n        images = sorted(unused.images_deep())\\n        ui_layouts.box_list(\\n            layout=layout,\\n            title=\\\"Ima"
                },
                {
                  "lineNumber": 15745,
                  "content": "            \"text\": \"        collections = sorted(unused.collections_deep())\","
                },
                {
                  "lineNumber": 15776,
                  "content": "            \"text\": \"        images = sorted(unused.images_deep())\","
                },
                {
                  "lineNumber": 15807,
                  "content": "            \"text\": \"        lights = sorted(unused.lights_deep())\","
                },
                {
                  "lineNumber": 15838,
                  "content": "            \"text\": \"        materials = sorted(unused.materials_deep())\","
                },
                {
                  "lineNumber": 15869,
                  "content": "            \"text\": \"        node_groups = sorted(unused.node_groups_deep())\","
                },
                {
                  "lineNumber": 15900,
                  "content": "            \"text\": \"        particles = sorted(unused.particles_deep())\","
                },
                {
                  "lineNumber": 15931,
                  "content": "            \"text\": \"        textures = sorted(unused.textures_deep())\","
                },
                {
                  "lineNumber": 17664,
                  "content": "        \"contents\": \"class ATOMIC_OT_clean_all(bpy.types.Operator):\\ndef draw(self, context):\\n\\n        ui_layouts.box_list(\\n            layout=layout,\\n            title=\\\"Textures\\\",\\n            items=textures,\\n            icon=\\\"TEXTURE\\\"\\n        )\\n\\n        worlds = sorted(unused.worlds())\\n        ui_layouts.box_list(\\n            layout=layout,\\n            title=\\\"Worlds\\\",\\n            items=worlds,\\n            icon=\\\"WORLD\\\"\\n        )\\n\\n        row = layout.row()  # extra spacing\\n\\n    def execute(self, context):\\n\\n        clean.collections()\\n        clean.images()\\n        clean.lights()\\n        clean.materials()\\n        clean.node_groups()\\n        clean.particles()\\n        clean.textures()\\n        clean.worlds()\\n\\n        return {'FINISHED'}\\n\\n    def invoke(self, context, event):\\n        wm = context.window_manager\\n\\n        self.unused_collections = unused.collections_deep()\\n        self.unused_images = unused.images_deep()\\n        self.unused_lights"
                },
                {
                  "lineNumber": 17730,
                  "content": "            \"text\": \"        worlds = sorted(unused.worlds())\","
                },
                {
                  "lineNumber": 17828,
                  "content": "            \"text\": \"        self.unused_collections = unused.collections_deep()\","
                },
                {
                  "lineNumber": 17832,
                  "content": "            \"text\": \"        self.unused_images = unused.images_deep()\","
                },
                {
                  "lineNumber": 17836,
                  "content": "            \"text\": \"        self.unused_lights = unused.lights_deep()\","
                },
                {
                  "lineNumber": 17840,
                  "content": "            \"text\": \"        self.unused_materials = unused.materials_deep()\","
                },
                {
                  "lineNumber": 17844,
                  "content": "            \"text\": \"        self.unused_node_groups = unused.node_groups_deep()\","
                },
                {
                  "lineNumber": 17848,
                  "content": "            \"text\": \"        self.unused_particles = unused.particles_deep()\","
                },
                {
                  "lineNumber": 17852,
                  "content": "            \"text\": \"        self.unused_textures = unused.textures_deep()\","
                },
                {
                  "lineNumber": 17856,
                  "content": "            \"text\": \"        self.unused_worlds = unused.worlds()\","
                }
              ]
            },
            {
              "file": "ops/direct_use_ops.py",
              "matches": [
                {
                  "lineNumber": 171,
                  "content": "        collections = sorted(unused.collections_deep())"
                },
                {
                  "lineNumber": 179,
                  "content": "        images = sorted(unused.images_deep())"
                },
                {
                  "lineNumber": 187,
                  "content": "        lights = sorted(unused.lights_deep())"
                },
                {
                  "lineNumber": 195,
                  "content": "        materials = sorted(unused.materials_deep())"
                },
                {
                  "lineNumber": 203,
                  "content": "        node_groups = sorted(unused.node_groups_deep())"
                },
                {
                  "lineNumber": 211,
                  "content": "        particles = sorted(unused.particles_deep())"
                },
                {
                  "lineNumber": 219,
                  "content": "        textures = sorted(unused.textures_deep())"
                },
                {
                  "lineNumber": 227,
                  "content": "        worlds = sorted(unused.worlds())"
                },
                {
                  "lineNumber": 536,
                  "content": "        self.unused_collections = unused.collections_deep()"
                },
                {
                  "lineNumber": 568,
                  "content": "        self.unused_images =unused.images_deep()"
                },
                {
                  "lineNumber": 600,
                  "content": "        self.unused_lights = unused.lights_deep()"
                },
                {
                  "lineNumber": 632,
                  "content": "        self.unused_materials = unused.materials_deep()"
                },
                {
                  "lineNumber": 664,
                  "content": "        self.unused_node_groups = unused.node_groups_deep()"
                },
                {
                  "lineNumber": 696,
                  "content": "        self.unused_particles = unused.particles_deep()"
                },
                {
                  "lineNumber": 728,
                  "content": "        self.unused_textures = unused.textures_deep()"
                },
                {
                  "lineNumber": 760,
                  "content": "        self.unused_worlds = unused.worlds()"
                }
              ]
            },
            {
              "file": "ops/utils/clean.py",
              "matches": [
                {
                  "lineNumber": 31,
                  "content": "    for collection_key in unused.collections_deep():"
                },
                {
                  "lineNumber": 37,
                  "content": "    for image_key in unused.images_deep():"
                },
                {
                  "lineNumber": 43,
                  "content": "    for light_key in unused.lights_deep():"
                },
                {
                  "lineNumber": 49,
                  "content": "    for light_key in unused.materials_deep():"
                },
                {
                  "lineNumber": 55,
                  "content": "    for node_group_key in unused.node_groups_deep():"
                },
                {
                  "lineNumber": 61,
                  "content": "    for particle_key in unused.particles_deep():"
                },
                {
                  "lineNumber": 67,
                  "content": "    for texture_key in unused.textures_deep():"
                },
                {
                  "lineNumber": 73,
                  "content": "    for world_key in unused.worlds():"
                }
              ]
            },
            {
              "file": "ops\\direct_use_ops.py",
              "matches": [
                {
                  "lineNumber": 171,
                  "content": "        collections = sorted(unused.collections_deep())"
                },
                {
                  "lineNumber": 179,
                  "content": "        images = sorted(unused.images_deep())"
                },
                {
                  "lineNumber": 187,
                  "content": "        lights = sorted(unused.lights_deep())"
                },
                {
                  "lineNumber": 195,
                  "content": "        materials = sorted(unused.materials_deep())"
                },
                {
                  "lineNumber": 203,
                  "content": "        node_groups = sorted(unused.node_groups_deep())"
                },
                {
                  "lineNumber": 211,
                  "content": "        particles = sorted(unused.particles_deep())"
                },
                {
                  "lineNumber": 219,
                  "content": "        textures = sorted(unused.textures_deep())"
                },
                {
                  "lineNumber": 227,
                  "content": "        worlds = sorted(unused.worlds())"
                },
                {
                  "lineNumber": 536,
                  "content": "        self.unused_collections = unused.collections_deep()"
                },
                {
                  "lineNumber": 568,
                  "content": "        self.unused_images =unused.images_deep()"
                },
                {
                  "lineNumber": 600,
                  "content": "        self.unused_lights = unused.lights_deep()"
                },
                {
                  "lineNumber": 632,
                  "content": "        self.unused_materials = unused.materials_deep()"
                },
                {
                  "lineNumber": 664,
                  "content": "        self.unused_node_groups = unused.node_groups_deep()"
                },
                {
                  "lineNumber": 696,
                  "content": "        self.unused_particles = unused.particles_deep()"
                },
                {
                  "lineNumber": 728,
                  "content": "        self.unused_textures = unused.textures_deep()"
                },
                {
                  "lineNumber": 760,
                  "content": "        self.unused_worlds = unused.worlds()"
                }
              ]
            }
          ],
          "totalLines": 79,
          "totalMatchedLines": 79
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\ops\main_ops.py</summary>

</details>
</tool-use>

---

Fixing a bug in the Clean operator's `draw()` method that calls `unused.textures_deep()` directly instead of using the cached value:


---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\ops\\main_ops.py"
}
```
Additional data:

```json
{
  "codeblockId": "948e986e-9d71-4949-9d60-2c980b7a9d89"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\ops\direct_use_ops.py</summary>

</details>
</tool-use>

---

Updating the `draw()` method in `ATOMIC_OT_clean_all` to use cached values instead of recalculating:


---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\ops\\direct_use_ops.py"
}
```
Additional data:

```json
{
  "codeblockId": "6d00e63a-35f3-47b1-9ea2-9f7f13cb63c2"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "ops/main_ops.py",
    "ops/direct_use_ops.py",
    "stats/unused_parallel.py"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "ops/main_ops.py"
    },
    {
      "relativeWorkspacePath": "ops/direct_use_ops.py"
    },
    {
      "relativeWorkspacePath": "stats/unused_parallel.py"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

## Summary

Fixed the threading issue in Smart Select and Clean operations.

### Changes Made:

1. **Created `stats/unused_parallel.py`** — Thread-safe parallel execution module:
   - Uses `ThreadPoolExecutor` to run unused data checks in parallel
   - Uses a lock around `bpy.data` access for thread safety
   - Provides `get_all_unused_parallel()` and `get_unused_for_smart_select()`

2. **Updated `ATOMIC_OT_smart_select`** — Uses parallel execution instead of 8 sequential calls

3. **Updated `ATOMIC_OT_clean.invoke()`** — Uses parallel execution to populate the dialog

4. **Updated `ATOMIC_OT_clean_all.invoke()`** — Uses parallel execution

5. **Fixed performance bugs**:
   - `ATOMIC_OT_clean_all.draw()` was recalculating unused data on every draw; now uses cached values
   - `ATOMIC_OT_clean.draw()` had a similar issue with textures

### Technical Notes:

- Thread-safe: All `bpy.data` access is protected by a lock
- Performance: The lock serializes `bpy.data` access, so gains may be limited, but the code is structured for parallel execution
- Compatibility: Works with Blender's single-threaded Python API constraints

The operations now run in parallel where possible while maintaining thread safety. The lock ensures correctness, and the structure allows for future optimizations.

---

_**User**_

@blender (1-160) it's still multithreading quite poorly, but I think it may be faster now.

---

_**Agent (model default, mode Agent)**_


The lock serializes all `bpy.data` access, so threads wait on each other, negating parallelism. Optimizing by removing threading overhead and improving the sequential code, or using a more efficient approach:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\unused_parallel.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "How can we optimize unused data detection without threading?",
  "includePattern": "stats",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 43
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains parallelized versions of unused data detection functions.\nUses threading with locks to safely access Blender's API from multiple threads.\n\n\"\"\"\n\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nfrom ..stats import unused\nfrom ..utils import compat\n\n\n# Lock for thread-safe bpy.data access\n_bpy_data_lock = threading.Lock()\n\n\ndef _run_with_lock(func, *args, **kwargs):\n    \"\"\"Execute a function with the bpy.data lock.\"\"\"\n    with _bpy_data_lock:\n        return func(*args, **kwargs)\n\n\ndef _check_unused_collections():\n    \"\"\"Check for unused collections (thread-safe).\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains parallelized versions of unused data detection functions.",
            "lineNumber": 21
          },
          {
            "text": "Uses threading with locks to safely access Blender's API from multiple threads.",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "\"\"\"",
            "lineNumber": 24
          },
          {
            "lineNumber": 25
          },
          {
            "text": "import threading",
            "lineNumber": 26
          },
          {
            "text": "from concurrent.futures import ThreadPoolExecutor, as_completed",
            "lineNumber": 27
          },
          {
            "text": "from ..stats import unused",
            "lineNumber": 28
          },
          {
            "text": "from ..utils import compat",
            "lineNumber": 29
          },
          {
            "lineNumber": 30
          },
          {
            "lineNumber": 31
          },
          {
            "text": "# Lock for thread-safe bpy.data access",
            "lineNumber": 32
          },
          {
            "text": "_bpy_data_lock = threading.Lock()",
            "lineNumber": 33
          },
          {
            "lineNumber": 34
          },
          {
            "lineNumber": 35
          },
          {
            "text": "def _run_with_lock(func, *args, **kwargs):",
            "lineNumber": 36,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Execute a function with the bpy.data lock.\"\"\"",
            "lineNumber": 37
          },
          {
            "text": "    with _bpy_data_lock:",
            "lineNumber": 38
          },
          {
            "text": "        return func(*args, **kwargs)",
            "lineNumber": 39,
            "isSignature": true
          },
          {
            "lineNumber": 40
          },
          {
            "lineNumber": 41
          },
          {
            "text": "def _check_unused_collections():",
            "lineNumber": 42,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused collections (thread-safe).\"\"\"",
            "lineNumber": 43
          }
        ]
      },
      "score": 0.4301362633705139
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 78,
            "column": 40
          },
          "endPosition": {
            "line": 156
          }
        },
        "contents": "def get_all_unused_parallel():\n    \"\"\"\n    Get all unused data-blocks in parallel.\n    \n    Returns a dictionary with keys:\n    - collections: list of unused collection names\n    - images: list of unused image names\n    - lights: list of unused light names\n    - materials: list of unused material names\n    - node_groups: list of unused node group names\n    - particles: list of unused particle names\n    - textures: list of unused texture names\n    - worlds: list of unused world names\n    \"\"\"\n    results = {\n        'collections': [],\n        'images': [],\n        'lights': [],\n        'materials': [],\n        'node_groups': [],\n        'particles': [],\n        'textures': [],\n        'worlds': []\n    }\n    \n    # Map of function names to their check functions\n    tasks = {\n        'collections': _check_unused_collections,\n        'images': _check_unused_images,\n        'lights': _check_unused_lights,\n        'materials': _check_unused_materials,\n        'node_groups': _check_unused_node_groups,\n        'particles': _check_unused_particles,\n        'textures': _check_unused_textures,\n        'worlds': _check_unused_worlds,\n    }\n    \n    # Execute all checks in parallel\n    with ThreadPoolExecutor(max_workers=8) as executor:\n        future_to_key = {\n            executor.submit(func): key\n            for key, func in tasks.items()\n        }\n        \n        for future in as_completed(future_to_key):\n            key = future_to_key[future]\n            try:\n                results[key] = future.result()\n            except Exception as e:\n                # Log error but continue with other results\n                print(f\"Error checking unused {key}: {e}\")\n                results[key] = []\n    \n    return results\n\n\ndef get_unused_for_smart_select():\n    \"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def get_all_unused_parallel():",
            "lineNumber": 82,
            "isSignature": true
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 83
          },
          {
            "text": "    Get all unused data-blocks in parallel.",
            "lineNumber": 84
          },
          {
            "text": "    ",
            "lineNumber": 85
          },
          {
            "text": "    Returns a dictionary with keys:",
            "lineNumber": 86
          },
          {
            "text": "    - collections: list of unused collection names",
            "lineNumber": 87
          },
          {
            "text": "    - images: list of unused image names",
            "lineNumber": 88
          },
          {
            "text": "    - lights: list of unused light names",
            "lineNumber": 89
          },
          {
            "text": "    - materials: list of unused material names",
            "lineNumber": 90
          },
          {
            "text": "    - node_groups: list of unused node group names",
            "lineNumber": 91
          },
          {
            "text": "    - particles: list of unused particle names",
            "lineNumber": 92
          },
          {
            "text": "    - textures: list of unused texture names",
            "lineNumber": 93
          },
          {
            "text": "    - worlds: list of unused world names",
            "lineNumber": 94
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 95
          },
          {
            "text": "    results = {",
            "lineNumber": 96
          },
          {
            "text": "        'collections': [],",
            "lineNumber": 97
          },
          {
            "text": "        'images': [],",
            "lineNumber": 98
          },
          {
            "text": "        'lights': [],",
            "lineNumber": 99
          },
          {
            "text": "        'materials': [],",
            "lineNumber": 100
          },
          {
            "text": "        'node_groups': [],",
            "lineNumber": 101
          },
          {
            "text": "        'particles': [],",
            "lineNumber": 102
          },
          {
            "text": "        'textures': [],",
            "lineNumber": 103
          },
          {
            "text": "        'worlds': []",
            "lineNumber": 104
          },
          {
            "text": "    }",
            "lineNumber": 105
          },
          {
            "text": "    ",
            "lineNumber": 106
          },
          {
            "text": "    # Map of function names to their check functions",
            "lineNumber": 107
          },
          {
            "text": "    tasks = {",
            "lineNumber": 108
          },
          {
            "text": "        'collections': _check_unused_collections,",
            "lineNumber": 109
          },
          {
            "text": "        'images': _check_unused_images,",
            "lineNumber": 110
          },
          {
            "text": "        'lights': _check_unused_lights,",
            "lineNumber": 111
          },
          {
            "text": "        'materials': _check_unused_materials,",
            "lineNumber": 112
          },
          {
            "text": "        'node_groups': _check_unused_node_groups,",
            "lineNumber": 113
          },
          {
            "text": "        'particles': _check_unused_particles,",
            "lineNumber": 114
          },
          {
            "text": "        'textures': _check_unused_textures,",
            "lineNumber": 115
          },
          {
            "text": "        'worlds': _check_unused_worlds,",
            "lineNumber": 116
          },
          {
            "text": "    }",
            "lineNumber": 117
          },
          {
            "text": "    ",
            "lineNumber": 118
          },
          {
            "text": "    # Execute all checks in parallel",
            "lineNumber": 119
          },
          {
            "text": "    with ThreadPoolExecutor(max_workers=8) as executor:",
            "lineNumber": 120
          },
          {
            "text": "        future_to_key = {",
            "lineNumber": 121
          },
          {
            "text": "            executor.submit(func): key",
            "lineNumber": 122
          },
          {
            "text": "            for key, func in tasks.items()",
            "lineNumber": 123
          },
          {
            "text": "        }",
            "lineNumber": 124
          },
          {
            "text": "        ",
            "lineNumber": 125
          },
          {
            "text": "        for future in as_completed(future_to_key):",
            "lineNumber": 126
          },
          {
            "text": "            key = future_to_key[future]",
            "lineNumber": 127
          },
          {
            "text": "            try:",
            "lineNumber": 128
          },
          {
            "text": "                results[key] = future.result()",
            "lineNumber": 129
          },
          {
            "text": "            except Exception as e:",
            "lineNumber": 130
          },
          {
            "text": "                # Log error but continue with other results",
            "lineNumber": 131
          },
          {
            "text": "                print(f\"Error checking unused {key}: {e}\")",
            "lineNumber": 132
          },
          {
            "text": "                results[key] = []",
            "lineNumber": 133
          },
          {
            "text": "    ",
            "lineNumber": 134
          },
          {
            "text": "    return results",
            "lineNumber": 135,
            "isSignature": true
          },
          {
            "lineNumber": 136
          },
          {
            "lineNumber": 137
          },
          {
            "text": "def get_unused_for_smart_select():",
            "lineNumber": 138,
            "isSignature": true
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 139
          }
        ]
      },
      "score": 0.4133147895336151
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 64
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains functions that detect data-blocks that have no users,\nas determined by stats.users.py\n\n\"\"\"\n\nimport bpy\nfrom .. import config\nfrom ..utils import compat\nfrom . import users\n\n\ndef shallow(data):\n    # returns a list of keys of unused data-blocks in the data that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    unused = []\n\n    for datablock in data:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(datablock):\n            continue\n\n        # if data-block has no users or if it has a fake user and\n        # ignore fake users is enabled\n        if datablock.users == 0 or (datablock.users == 1 and\n                                    datablock.use_fake_user and\n                                    config.include_fake_users):\n            unused.append(datablock.name)\n\n    return unused\n\n\ndef collections_deep():\n    # returns a full list of keys of unused collections\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains functions that detect data-blocks that have no users,",
            "lineNumber": 21
          },
          {
            "text": "as determined by stats.users.py",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "\"\"\"",
            "lineNumber": 24
          },
          {
            "lineNumber": 25
          },
          {
            "text": "import bpy",
            "lineNumber": 26
          },
          {
            "text": "from .. import config",
            "lineNumber": 27
          },
          {
            "text": "from ..utils import compat",
            "lineNumber": 28
          },
          {
            "text": "from . import users",
            "lineNumber": 29
          },
          {
            "lineNumber": 30
          },
          {
            "lineNumber": 31
          },
          {
            "text": "def shallow(data):",
            "lineNumber": 32,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused data-blocks in the data that may be",
            "lineNumber": 33,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "lineNumber": 35
          },
          {
            "text": "    unused = []",
            "lineNumber": 36
          },
          {
            "lineNumber": 37
          },
          {
            "text": "    for datablock in data:",
            "lineNumber": 38
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 39
          },
          {
            "text": "        if compat.is_library_or_override(datablock):",
            "lineNumber": 40
          },
          {
            "text": "            continue",
            "lineNumber": 41
          },
          {
            "lineNumber": 42
          },
          {
            "text": "        # if data-block has no users or if it has a fake user and",
            "lineNumber": 43
          },
          {
            "text": "        # ignore fake users is enabled",
            "lineNumber": 44
          },
          {
            "text": "        if datablock.users == 0 or (datablock.users == 1 and",
            "lineNumber": 45
          },
          {
            "text": "                                    datablock.use_fake_user and",
            "lineNumber": 46
          },
          {
            "text": "                                    config.include_fake_users):",
            "lineNumber": 47
          },
          {
            "text": "            unused.append(datablock.name)",
            "lineNumber": 48
          },
          {
            "lineNumber": 49
          },
          {
            "text": "    return unused",
            "lineNumber": 50,
            "isSignature": true
          },
          {
            "lineNumber": 51
          },
          {
            "lineNumber": 52
          },
          {
            "text": "def collections_deep():",
            "lineNumber": 53,
            "isSignature": true
          },
          {
            "text": "    # returns a full list of keys of unused collections",
            "lineNumber": 54,
            "isSignature": true
          },
          {
            "lineNumber": 55
          },
          {
            "text": "    ",
            "lineNumber": 56
          }
        ]
      },
      "score": 0.36144375801086426
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 134,
            "column": 18
          },
          "endPosition": {
            "line": 156,
            "column": 5
          }
        },
        "contents": "def get_unused_for_smart_select():\n    \"\"\"\n    Get unused data for smart select operation (returns booleans).\n    Executes checks in parallel for better performance.\n    \n    Returns a dictionary with boolean values indicating if each category\n    has unused data-blocks.\n    \"\"\"\n    all_unused = get_all_unused_parallel()\n    \n    return {\n        'collections': bool(all_unused['collections']),\n        'images': bool(all_unused['images']),\n        'lights': bool(all_unused['lights']),\n        'materials': bool(all_unused['materials']),\n        'node_groups': bool(all_unused['node_groups']),\n        'particles': bool(all_unused['particles']),\n        'textures': bool(all_unused['textures']),\n        'worlds': bool(all_unused['worlds']),\n    }",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def get_unused_for_smart_select():",
            "lineNumber": 138,
            "isSignature": true
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 139
          },
          {
            "text": "    Get unused data for smart select operation (returns booleans).",
            "lineNumber": 140
          },
          {
            "text": "    Executes checks in parallel for better performance.",
            "lineNumber": 141
          },
          {
            "text": "    ",
            "lineNumber": 142
          },
          {
            "text": "    Returns a dictionary with boolean values indicating if each category",
            "lineNumber": 143
          },
          {
            "text": "    has unused data-blocks.",
            "lineNumber": 144
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 145
          },
          {
            "text": "    all_unused = get_all_unused_parallel()",
            "lineNumber": 146
          },
          {
            "text": "    ",
            "lineNumber": 147
          },
          {
            "text": "    return {",
            "lineNumber": 148
          },
          {
            "text": "        'collections': bool(all_unused['collections']),",
            "lineNumber": 149
          },
          {
            "text": "        'images': bool(all_unused['images']),",
            "lineNumber": 150
          },
          {
            "text": "        'lights': bool(all_unused['lights']),",
            "lineNumber": 151
          },
          {
            "text": "        'materials': bool(all_unused['materials']),",
            "lineNumber": 152
          },
          {
            "text": "        'node_groups': bool(all_unused['node_groups']),",
            "lineNumber": 153
          },
          {
            "text": "        'particles': bool(all_unused['particles']),",
            "lineNumber": 154
          },
          {
            "text": "        'textures': bool(all_unused['textures']),",
            "lineNumber": 155
          },
          {
            "text": "        'worlds': bool(all_unused['worlds']),",
            "lineNumber": 156
          },
          {
            "text": "    }",
            "lineNumber": 157,
            "isSignature": true
          }
        ]
      },
      "score": 0.35115718841552734
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 53,
            "column": 45
          },
          "endPosition": {
            "line": 63
          }
        },
        "contents": "def _check_unused_materials():\n    \"\"\"Check for unused materials (thread-safe).\"\"\"\n    return _run_with_lock(unused.materials_deep)\n\n\ndef _check_unused_node_groups():\n    \"\"\"Check for unused node groups (thread-safe).\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _check_unused_materials():",
            "lineNumber": 57,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused materials (thread-safe).\"\"\"",
            "lineNumber": 58
          },
          {
            "text": "    return _run_with_lock(unused.materials_deep)",
            "lineNumber": 59,
            "isSignature": true
          },
          {
            "lineNumber": 60
          },
          {
            "lineNumber": 61
          },
          {
            "text": "def _check_unused_node_groups():",
            "lineNumber": 62,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused node groups (thread-safe).\"\"\"",
            "lineNumber": 63
          }
        ]
      },
      "score": 0.33922624588012695
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 43,
            "column": 50
          },
          "endPosition": {
            "line": 53
          }
        },
        "contents": "def _check_unused_images():\n    \"\"\"Check for unused images (thread-safe).\"\"\"\n    return _run_with_lock(unused.images_deep)\n\n\ndef _check_unused_lights():\n    \"\"\"Check for unused lights (thread-safe).\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _check_unused_images():",
            "lineNumber": 47,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused images (thread-safe).\"\"\"",
            "lineNumber": 48
          },
          {
            "text": "    return _run_with_lock(unused.images_deep)",
            "lineNumber": 49,
            "isSignature": true
          },
          {
            "lineNumber": 50
          },
          {
            "lineNumber": 51
          },
          {
            "text": "def _check_unused_lights():",
            "lineNumber": 52,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused lights (thread-safe).\"\"\"",
            "lineNumber": 53
          }
        ]
      },
      "score": 0.3209508955478668
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 63,
            "column": 50
          },
          "endPosition": {
            "line": 73
          }
        },
        "contents": "def _check_unused_particles():\n    \"\"\"Check for unused particles (thread-safe).\"\"\"\n    return _run_with_lock(unused.particles_deep)\n\n\ndef _check_unused_textures():\n    \"\"\"Check for unused textures (thread-safe).\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _check_unused_particles():",
            "lineNumber": 67,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused particles (thread-safe).\"\"\"",
            "lineNumber": 68
          },
          {
            "text": "    return _run_with_lock(unused.particles_deep)",
            "lineNumber": 69,
            "isSignature": true
          },
          {
            "lineNumber": 70
          },
          {
            "lineNumber": 71
          },
          {
            "text": "def _check_unused_textures():",
            "lineNumber": 72,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused textures (thread-safe).\"\"\"",
            "lineNumber": 73
          }
        ]
      },
      "score": 0.3165147304534912
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 73,
            "column": 47
          },
          "endPosition": {
            "line": 134
          }
        },
        "contents": "def _check_unused_worlds():\n    \"\"\"Check for unused worlds (thread-safe).\"\"\"\n    return _run_with_lock(unused.worlds)\n\n\ndef get_all_unused_parallel():\n    \"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _check_unused_worlds():",
            "lineNumber": 77,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused worlds (thread-safe).\"\"\"",
            "lineNumber": 78
          },
          {
            "text": "    return _run_with_lock(unused.worlds)",
            "lineNumber": 79,
            "isSignature": true
          },
          {
            "lineNumber": 80
          },
          {
            "lineNumber": 81
          },
          {
            "text": "def get_all_unused_parallel():",
            "lineNumber": 82,
            "isSignature": true
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 83
          }
        ]
      },
      "score": 0.3123213052749634
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 48,
            "column": 45
          },
          "endPosition": {
            "line": 58
          }
        },
        "contents": "def _check_unused_lights():\n    \"\"\"Check for unused lights (thread-safe).\"\"\"\n    return _run_with_lock(unused.lights_deep)\n\n\ndef _check_unused_materials():\n    \"\"\"Check for unused materials (thread-safe).\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _check_unused_lights():",
            "lineNumber": 52,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused lights (thread-safe).\"\"\"",
            "lineNumber": 53
          },
          {
            "text": "    return _run_with_lock(unused.lights_deep)",
            "lineNumber": 54,
            "isSignature": true
          },
          {
            "lineNumber": 55
          },
          {
            "lineNumber": 56
          },
          {
            "text": "def _check_unused_materials():",
            "lineNumber": 57,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused materials (thread-safe).\"\"\"",
            "lineNumber": 58
          }
        ]
      },
      "score": 0.30924418568611145
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 68,
            "column": 48
          },
          "endPosition": {
            "line": 78
          }
        },
        "contents": "def _check_unused_textures():\n    \"\"\"Check for unused textures (thread-safe).\"\"\"\n    return _run_with_lock(unused.textures_deep)\n\n\ndef _check_unused_worlds():\n    \"\"\"Check for unused worlds (thread-safe).\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _check_unused_textures():",
            "lineNumber": 72,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused textures (thread-safe).\"\"\"",
            "lineNumber": 73
          },
          {
            "text": "    return _run_with_lock(unused.textures_deep)",
            "lineNumber": 74,
            "isSignature": true
          },
          {
            "lineNumber": 75
          },
          {
            "lineNumber": 76
          },
          {
            "text": "def _check_unused_worlds():",
            "lineNumber": 77,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused worlds (thread-safe).\"\"\"",
            "lineNumber": 78
          }
        ]
      },
      "score": 0.3026829957962036
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 58,
            "column": 48
          },
          "endPosition": {
            "line": 68
          }
        },
        "contents": "def _check_unused_node_groups():\n    \"\"\"Check for unused node groups (thread-safe).\"\"\"\n    return _run_with_lock(unused.node_groups_deep)\n\n\ndef _check_unused_particles():\n    \"\"\"Check for unused particles (thread-safe).\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _check_unused_node_groups():",
            "lineNumber": 62,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused node groups (thread-safe).\"\"\"",
            "lineNumber": 63
          },
          {
            "text": "    return _run_with_lock(unused.node_groups_deep)",
            "lineNumber": 64,
            "isSignature": true
          },
          {
            "lineNumber": 65
          },
          {
            "lineNumber": 66
          },
          {
            "text": "def _check_unused_particles():",
            "lineNumber": 67,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused particles (thread-safe).\"\"\"",
            "lineNumber": 68
          }
        ]
      },
      "score": 0.29892146587371826
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 38,
            "column": 36
          },
          "endPosition": {
            "line": 48
          }
        },
        "contents": "def _check_unused_collections():\n    \"\"\"Check for unused collections (thread-safe).\"\"\"\n    return _run_with_lock(unused.collections_deep)\n\n\ndef _check_unused_images():\n    \"\"\"Check for unused images (thread-safe).\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _check_unused_collections():",
            "lineNumber": 42,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused collections (thread-safe).\"\"\"",
            "lineNumber": 43
          },
          {
            "text": "    return _run_with_lock(unused.collections_deep)",
            "lineNumber": 44,
            "isSignature": true
          },
          {
            "lineNumber": 45
          },
          {
            "lineNumber": 46
          },
          {
            "text": "def _check_unused_images():",
            "lineNumber": 47,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check for unused images (thread-safe).\"\"\"",
            "lineNumber": 48
          }
        ]
      },
      "score": 0.2952601909637451
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 150,
            "column": 35
          },
          "endPosition": {
            "line": 176,
            "column": 4
          }
        },
        "contents": "def materials_deep():\n    # returns a list of keys of unused materials\n\n    unused = []\n\n    for material in bpy.data.materials:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(material):\n            continue\n        if not users.material_all(material.name):\n\n            # check if material has a fake user or if ignore fake users\n            # is enabled\n            if not material.use_fake_user or config.include_fake_users:\n                unused.append(material.name)\n\n    return unused\n\n\ndef materials_shallow():\n    # returns a list of keys of unused material that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def materials_deep():",
            "lineNumber": 154,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused materials",
            "lineNumber": 155,
            "isSignature": true
          },
          {
            "lineNumber": 156
          },
          {
            "text": "    unused = []",
            "lineNumber": 157
          },
          {
            "lineNumber": 158
          },
          {
            "text": "    for material in bpy.data.materials:",
            "lineNumber": 159
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 160
          },
          {
            "text": "        if compat.is_library_or_override(material):",
            "lineNumber": 161
          },
          {
            "text": "            continue",
            "lineNumber": 162
          },
          {
            "text": "        if not users.material_all(material.name):",
            "lineNumber": 163
          },
          {
            "lineNumber": 164
          },
          {
            "text": "            # check if material has a fake user or if ignore fake users",
            "lineNumber": 165
          },
          {
            "text": "            # is enabled",
            "lineNumber": 166
          },
          {
            "text": "            if not material.use_fake_user or config.include_fake_users:",
            "lineNumber": 167
          },
          {
            "text": "                unused.append(material.name)",
            "lineNumber": 168
          },
          {
            "lineNumber": 169
          },
          {
            "text": "    return unused",
            "lineNumber": 170,
            "isSignature": true
          },
          {
            "lineNumber": 171
          },
          {
            "lineNumber": 172
          },
          {
            "text": "def materials_shallow():",
            "lineNumber": 173,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused material that may be",
            "lineNumber": 174,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 175,
            "isSignature": true
          },
          {
            "lineNumber": 176
          },
          {
            "text": "    ",
            "lineNumber": 177,
            "isSignature": true
          }
        ]
      },
      "score": 0.268484503030777
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 260,
            "column": 78
          },
          "endPosition": {
            "line": 280,
            "column": 17
          }
        },
        "contents": "def worlds():\n    # returns a full list of keys of unused worlds\n\n    unused = []\n\n    for world in bpy.data.worlds:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(world):\n            continue\n\n        # if data-block has no users or if it has a fake user and\n        # ignore fake users is enabled\n        if world.users == 0 or (world.users == 1 and\n                                world.use_fake_user and\n                                config.include_fake_users):\n            unused.append(world.name)\n\n    return unused",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def worlds():",
            "lineNumber": 264,
            "isSignature": true
          },
          {
            "text": "    # returns a full list of keys of unused worlds",
            "lineNumber": 265,
            "isSignature": true
          },
          {
            "lineNumber": 266
          },
          {
            "text": "    unused = []",
            "lineNumber": 267
          },
          {
            "lineNumber": 268
          },
          {
            "text": "    for world in bpy.data.worlds:",
            "lineNumber": 269
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 270
          },
          {
            "text": "        if compat.is_library_or_override(world):",
            "lineNumber": 271
          },
          {
            "text": "            continue",
            "lineNumber": 272
          },
          {
            "lineNumber": 273
          },
          {
            "text": "        # if data-block has no users or if it has a fake user and",
            "lineNumber": 274
          },
          {
            "text": "        # ignore fake users is enabled",
            "lineNumber": 275
          },
          {
            "text": "        if world.users == 0 or (world.users == 1 and",
            "lineNumber": 276
          },
          {
            "text": "                                world.use_fake_user and",
            "lineNumber": 277
          },
          {
            "text": "                                config.include_fake_users):",
            "lineNumber": 278
          },
          {
            "text": "            unused.append(world.name)",
            "lineNumber": 279
          },
          {
            "lineNumber": 280
          },
          {
            "text": "    return unused",
            "lineNumber": 281,
            "isSignature": true
          }
        ]
      },
      "score": 0.2500281035900116
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 64,
            "column": 17
          },
          "endPosition": {
            "line": 106
          }
        },
        "contents": "def collections_shallow():\n    # returns a list of keys of unused collections that may be\n    # incomplete, but is significantly faster.\n\n    unused = []\n\n    for collection in bpy.data.collections:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(collection):\n            continue\n        if not (collection.objects or collection.children):\n            unused.append(collection.name)\n\n    return unused\n\n\ndef images_deep():\n    # returns a full list of keys of unused images\n\n    unused = []",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def collections_shallow():",
            "lineNumber": 68,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused collections that may be",
            "lineNumber": 69,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster.",
            "lineNumber": 70,
            "isSignature": true
          },
          {
            "lineNumber": 71
          },
          {
            "text": "    unused = []",
            "lineNumber": 72
          },
          {
            "lineNumber": 73
          },
          {
            "text": "    for collection in bpy.data.collections:",
            "lineNumber": 74
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 75
          },
          {
            "text": "        if compat.is_library_or_override(collection):",
            "lineNumber": 76
          },
          {
            "text": "            continue",
            "lineNumber": 77
          },
          {
            "text": "        if not (collection.objects or collection.children):",
            "lineNumber": 78
          },
          {
            "text": "            unused.append(collection.name)",
            "lineNumber": 79
          },
          {
            "lineNumber": 80
          },
          {
            "text": "    return unused",
            "lineNumber": 81,
            "isSignature": true
          },
          {
            "lineNumber": 82
          },
          {
            "lineNumber": 83
          },
          {
            "text": "def images_deep():",
            "lineNumber": 84,
            "isSignature": true
          },
          {
            "text": "    # returns a full list of keys of unused images",
            "lineNumber": 85,
            "isSignature": true
          },
          {
            "lineNumber": 86
          },
          {
            "text": "    unused = []",
            "lineNumber": 87
          }
        ]
      },
      "score": 0.246379554271698
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 231,
            "column": 80
          },
          "endPosition": {
            "line": 260,
            "column": 4
          }
        },
        "contents": "def textures_deep():\n    # returns a list of keys of unused textures\n\n    if not hasattr(bpy.data, 'textures'):\n        return []\n\n    unused = []\n\n    for texture in bpy.data.textures:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(texture):\n            continue\n        if not users.texture_all(texture.name):\n\n            # check if texture has a fake user or if ignore fake users\n            # is enabled\n            if not texture.use_fake_user or config.include_fake_users:\n                unused.append(texture.name)\n\n    return unused\n\n\ndef textures_shallow():\n    # returns a list of keys of unused textures that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def textures_deep():",
            "lineNumber": 235,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused textures",
            "lineNumber": 236,
            "isSignature": true
          },
          {
            "lineNumber": 237
          },
          {
            "text": "    if not hasattr(bpy.data, 'textures'):",
            "lineNumber": 238
          },
          {
            "text": "        return []",
            "lineNumber": 239
          },
          {
            "lineNumber": 240
          },
          {
            "text": "    unused = []",
            "lineNumber": 241
          },
          {
            "lineNumber": 242
          },
          {
            "text": "    for texture in bpy.data.textures:",
            "lineNumber": 243
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 244
          },
          {
            "text": "        if compat.is_library_or_override(texture):",
            "lineNumber": 245
          },
          {
            "text": "            continue",
            "lineNumber": 246
          },
          {
            "text": "        if not users.texture_all(texture.name):",
            "lineNumber": 247
          },
          {
            "lineNumber": 248
          },
          {
            "text": "            # check if texture has a fake user or if ignore fake users",
            "lineNumber": 249
          },
          {
            "text": "            # is enabled",
            "lineNumber": 250
          },
          {
            "text": "            if not texture.use_fake_user or config.include_fake_users:",
            "lineNumber": 251
          },
          {
            "text": "                unused.append(texture.name)",
            "lineNumber": 252
          },
          {
            "lineNumber": 253
          },
          {
            "text": "    return unused",
            "lineNumber": 254,
            "isSignature": true
          },
          {
            "lineNumber": 255
          },
          {
            "lineNumber": 256
          },
          {
            "text": "def textures_shallow():",
            "lineNumber": 257,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused textures that may be",
            "lineNumber": 258,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 259,
            "isSignature": true
          },
          {
            "lineNumber": 260
          },
          {
            "text": "    ",
            "lineNumber": 261,
            "isSignature": true
          }
        ]
      },
      "score": 0.24289509654045105
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 49,
            "column": 17
          },
          "endPosition": {
            "line": 80
          }
        },
        "contents": "def collections_deep():\n    # returns a full list of keys of unused collections\n\n    unused = []\n\n    for collection in bpy.data.collections:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(collection):\n            continue\n        if not users.collection_all(collection.name):\n            unused.append(collection.name)\n\n    return unused\n\n\ndef collections_shallow():\n    # returns a list of keys of unused collections that may be\n    # incomplete, but is significantly faster.\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def collections_deep():",
            "lineNumber": 53,
            "isSignature": true
          },
          {
            "text": "    # returns a full list of keys of unused collections",
            "lineNumber": 54,
            "isSignature": true
          },
          {
            "lineNumber": 55
          },
          {
            "text": "    unused = []",
            "lineNumber": 56
          },
          {
            "lineNumber": 57
          },
          {
            "text": "    for collection in bpy.data.collections:",
            "lineNumber": 58
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 59
          },
          {
            "text": "        if compat.is_library_or_override(collection):",
            "lineNumber": 60
          },
          {
            "text": "            continue",
            "lineNumber": 61
          },
          {
            "text": "        if not users.collection_all(collection.name):",
            "lineNumber": 62
          },
          {
            "text": "            unused.append(collection.name)",
            "lineNumber": 63
          },
          {
            "lineNumber": 64
          },
          {
            "text": "    return unused",
            "lineNumber": 65,
            "isSignature": true
          },
          {
            "lineNumber": 66
          },
          {
            "lineNumber": 67
          },
          {
            "text": "def collections_shallow():",
            "lineNumber": 68,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused collections that may be",
            "lineNumber": 69,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster.",
            "lineNumber": 70,
            "isSignature": true
          },
          {
            "lineNumber": 71
          },
          {
            "text": "    ",
            "lineNumber": 72
          }
        ]
      },
      "score": 0.2404240369796753
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 169,
            "column": 17
          },
          "endPosition": {
            "line": 195
          }
        },
        "contents": "def materials_shallow():\n    # returns a list of keys of unused material that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    return shallow(bpy.data.materials)\n\n\ndef node_groups_deep():\n    # returns a list of keys of unused node_groups\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def materials_shallow():",
            "lineNumber": 173,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused material that may be",
            "lineNumber": 174,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 175,
            "isSignature": true
          },
          {
            "lineNumber": 176
          },
          {
            "text": "    return shallow(bpy.data.materials)",
            "lineNumber": 177,
            "isSignature": true
          },
          {
            "lineNumber": 178
          },
          {
            "lineNumber": 179
          },
          {
            "text": "def node_groups_deep():",
            "lineNumber": 180,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused node_groups",
            "lineNumber": 181,
            "isSignature": true
          },
          {
            "lineNumber": 182
          },
          {
            "text": "    ",
            "lineNumber": 183
          }
        ]
      },
      "score": 0.23875075578689575
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 80,
            "column": 17
          },
          "endPosition": {
            "line": 124
          }
        },
        "contents": "def images_deep():\n    # returns a full list of keys of unused images\n\n    unused = []\n\n    # a list of image keys that should not be flagged as unused\n    # this list also exists in images_shallow()\n    do_not_flag = [\"Render Result\", \"Viewer Node\", \"D-NOISE Export\"]\n\n    for image in bpy.data.images:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(image):\n            continue\n        if not users.image_all(image.name):\n\n            # check if image has a fake user or if ignore fake users\n            # is enabled\n            if not image.use_fake_user or config.include_fake_users:\n\n                # if image is not in our do not flag list\n                if image.name not in do_not_flag:\n                    unused.append(image.name)\n\n    return unused\n\n\ndef images_shallow():\n    # returns a list of keys of unused images that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def images_deep():",
            "lineNumber": 84,
            "isSignature": true
          },
          {
            "text": "    # returns a full list of keys of unused images",
            "lineNumber": 85,
            "isSignature": true
          },
          {
            "lineNumber": 86
          },
          {
            "text": "    unused = []",
            "lineNumber": 87
          },
          {
            "lineNumber": 88
          },
          {
            "text": "    # a list of image keys that should not be flagged as unused",
            "lineNumber": 89
          },
          {
            "text": "    # this list also exists in images_shallow()",
            "lineNumber": 90
          },
          {
            "text": "    do_not_flag = [\"Render Result\", \"Viewer Node\", \"D-NOISE Export\"]",
            "lineNumber": 91
          },
          {
            "lineNumber": 92
          },
          {
            "text": "    for image in bpy.data.images:",
            "lineNumber": 93
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 94
          },
          {
            "text": "        if compat.is_library_or_override(image):",
            "lineNumber": 95
          },
          {
            "text": "            continue",
            "lineNumber": 96
          },
          {
            "text": "        if not users.image_all(image.name):",
            "lineNumber": 97
          },
          {
            "lineNumber": 98
          },
          {
            "text": "            # check if image has a fake user or if ignore fake users",
            "lineNumber": 99
          },
          {
            "text": "            # is enabled",
            "lineNumber": 100
          },
          {
            "text": "            if not image.use_fake_user or config.include_fake_users:",
            "lineNumber": 101
          },
          {
            "lineNumber": 102
          },
          {
            "text": "                # if image is not in our do not flag list",
            "lineNumber": 103
          },
          {
            "text": "                if image.name not in do_not_flag:",
            "lineNumber": 104
          },
          {
            "text": "                    unused.append(image.name)",
            "lineNumber": 105
          },
          {
            "lineNumber": 106
          },
          {
            "text": "    return unused",
            "lineNumber": 107,
            "isSignature": true
          },
          {
            "lineNumber": 108
          },
          {
            "lineNumber": 109
          },
          {
            "text": "def images_shallow():",
            "lineNumber": 110,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused images that may be",
            "lineNumber": 111,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 112,
            "isSignature": true
          },
          {
            "lineNumber": 113
          },
          {
            "text": "    ",
            "lineNumber": 114
          }
        ]
      },
      "score": 0.237817645072937
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 124,
            "column": 24
          },
          "endPosition": {
            "line": 150,
            "column": 4
          }
        },
        "contents": "def lights_deep():\n    # returns a list of keys of unused lights\n\n    unused = []\n\n    for light in bpy.data.lights:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(light):\n            continue\n        if not users.light_all(light.name):\n\n            # check if light has a fake user or if ignore fake users\n            # is enabled\n            if not light.use_fake_user or config.include_fake_users:\n                unused.append(light.name)\n\n    return unused\n\n\ndef lights_shallow():\n    # returns a list of keys of unused lights that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def lights_deep():",
            "lineNumber": 128,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused lights",
            "lineNumber": 129,
            "isSignature": true
          },
          {
            "lineNumber": 130
          },
          {
            "text": "    unused = []",
            "lineNumber": 131
          },
          {
            "lineNumber": 132
          },
          {
            "text": "    for light in bpy.data.lights:",
            "lineNumber": 133
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 134
          },
          {
            "text": "        if compat.is_library_or_override(light):",
            "lineNumber": 135
          },
          {
            "text": "            continue",
            "lineNumber": 136
          },
          {
            "text": "        if not users.light_all(light.name):",
            "lineNumber": 137
          },
          {
            "lineNumber": 138
          },
          {
            "text": "            # check if light has a fake user or if ignore fake users",
            "lineNumber": 139
          },
          {
            "text": "            # is enabled",
            "lineNumber": 140
          },
          {
            "text": "            if not light.use_fake_user or config.include_fake_users:",
            "lineNumber": 141
          },
          {
            "text": "                unused.append(light.name)",
            "lineNumber": 142
          },
          {
            "lineNumber": 143
          },
          {
            "text": "    return unused",
            "lineNumber": 144,
            "isSignature": true
          },
          {
            "lineNumber": 145
          },
          {
            "lineNumber": 146
          },
          {
            "text": "def lights_shallow():",
            "lineNumber": 147,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused lights that may be",
            "lineNumber": 148,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 149,
            "isSignature": true
          },
          {
            "lineNumber": 150
          },
          {
            "text": "    ",
            "lineNumber": 151,
            "isSignature": true
          }
        ]
      },
      "score": 0.2324921041727066
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 106,
            "column": 17
          },
          "endPosition": {
            "line": 143
          }
        },
        "contents": "def images_shallow():\n    # returns a list of keys of unused images that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    unused_images = shallow(bpy.data.images)\n\n    # a list of image keys that should not be flagged as unused\n    # this list also exists in images_deep()\n    do_not_flag = [\"Render Result\", \"Viewer Node\", \"D-NOISE Export\"]\n\n    # remove do not flag keys from unused images\n    for key in do_not_flag:\n        if key in unused_images:\n            unused_images.remove(key)\n\n    return unused_images\n\n\ndef lights_deep():\n    # returns a list of keys of unused lights\n\n    unused = []",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def images_shallow():",
            "lineNumber": 110,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused images that may be",
            "lineNumber": 111,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 112,
            "isSignature": true
          },
          {
            "lineNumber": 113
          },
          {
            "text": "    unused_images = shallow(bpy.data.images)",
            "lineNumber": 114
          },
          {
            "lineNumber": 115
          },
          {
            "text": "    # a list of image keys that should not be flagged as unused",
            "lineNumber": 116
          },
          {
            "text": "    # this list also exists in images_deep()",
            "lineNumber": 117
          },
          {
            "text": "    do_not_flag = [\"Render Result\", \"Viewer Node\", \"D-NOISE Export\"]",
            "lineNumber": 118
          },
          {
            "lineNumber": 119
          },
          {
            "text": "    # remove do not flag keys from unused images",
            "lineNumber": 120
          },
          {
            "text": "    for key in do_not_flag:",
            "lineNumber": 121
          },
          {
            "text": "        if key in unused_images:",
            "lineNumber": 122
          },
          {
            "text": "            unused_images.remove(key)",
            "lineNumber": 123
          },
          {
            "lineNumber": 124
          },
          {
            "text": "    return unused_images",
            "lineNumber": 125,
            "isSignature": true
          },
          {
            "lineNumber": 126
          },
          {
            "lineNumber": 127
          },
          {
            "text": "def lights_deep():",
            "lineNumber": 128,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused lights",
            "lineNumber": 129,
            "isSignature": true
          },
          {
            "lineNumber": 130
          },
          {
            "text": "    unused = []",
            "lineNumber": 131
          }
        ]
      },
      "score": 0.2275620698928833
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 253,
            "column": 17
          },
          "endPosition": {
            "line": 280
          }
        },
        "contents": "def textures_shallow():\n    # returns a list of keys of unused textures that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    return shallow(bpy.data.textures) if hasattr(bpy.data, 'textures') else []\n\n\ndef worlds():\n    # returns a full list of keys of unused worlds\n\n    unused = []",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def textures_shallow():",
            "lineNumber": 257,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused textures that may be",
            "lineNumber": 258,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 259,
            "isSignature": true
          },
          {
            "lineNumber": 260
          },
          {
            "text": "    return shallow(bpy.data.textures) if hasattr(bpy.data, 'textures') else []",
            "lineNumber": 261,
            "isSignature": true
          },
          {
            "lineNumber": 262
          },
          {
            "lineNumber": 263
          },
          {
            "text": "def worlds():",
            "lineNumber": 264,
            "isSignature": true
          },
          {
            "text": "    # returns a full list of keys of unused worlds",
            "lineNumber": 265,
            "isSignature": true
          },
          {
            "lineNumber": 266
          },
          {
            "text": "    unused = []",
            "lineNumber": 267
          }
        ]
      },
      "score": 0.21532273292541504
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 143,
            "column": 17
          },
          "endPosition": {
            "line": 169
          }
        },
        "contents": "def lights_shallow():\n    # returns a list of keys of unused lights that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    return shallow(bpy.data.lights)\n\n\ndef materials_deep():\n    # returns a list of keys of unused materials\n\n    unused = []",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def lights_shallow():",
            "lineNumber": 147,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused lights that may be",
            "lineNumber": 148,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 149,
            "isSignature": true
          },
          {
            "lineNumber": 150
          },
          {
            "text": "    return shallow(bpy.data.lights)",
            "lineNumber": 151,
            "isSignature": true
          },
          {
            "lineNumber": 152
          },
          {
            "lineNumber": 153
          },
          {
            "text": "def materials_deep():",
            "lineNumber": 154,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused materials",
            "lineNumber": 155,
            "isSignature": true
          },
          {
            "lineNumber": 156
          },
          {
            "text": "    unused = []",
            "lineNumber": 157
          }
        ]
      },
      "score": 0.21527600288391113
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\count.py",
        "range": {
          "startPosition": {
            "line": 106,
            "column": 16
          },
          "endPosition": {
            "line": 118,
            "column": 4
          }
        },
        "contents": "def materials_unused():\n    # returns the number of unused materials in the project\n\n    return len(unused.materials_shallow())\n\n\ndef materials_unnamed():\n    # returns the number of unnamed materials in the project\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def materials_unused():",
            "lineNumber": 110,
            "isSignature": true
          },
          {
            "text": "    # returns the number of unused materials in the project",
            "lineNumber": 111,
            "isSignature": true
          },
          {
            "lineNumber": 112
          },
          {
            "text": "    return len(unused.materials_shallow())",
            "lineNumber": 113,
            "isSignature": true
          },
          {
            "lineNumber": 114
          },
          {
            "lineNumber": 115
          },
          {
            "text": "def materials_unnamed():",
            "lineNumber": 116,
            "isSignature": true
          },
          {
            "text": "    # returns the number of unnamed materials in the project",
            "lineNumber": 117,
            "isSignature": true
          },
          {
            "lineNumber": 118
          },
          {
            "text": "    ",
            "lineNumber": 119,
            "isSignature": true
          }
        ]
      },
      "score": 0.213270902633667
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 195,
            "column": 17
          },
          "endPosition": {
            "line": 224
          }
        },
        "contents": "def node_groups_shallow():\n    # returns a list of keys of unused node groups that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    return shallow(bpy.data.node_groups)\n\n\ndef particles_deep():\n    # returns a list of keys of unused particle systems\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_groups_shallow():",
            "lineNumber": 199,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused node groups that may be",
            "lineNumber": 200,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 201,
            "isSignature": true
          },
          {
            "lineNumber": 202
          },
          {
            "text": "    return shallow(bpy.data.node_groups)",
            "lineNumber": 203,
            "isSignature": true
          },
          {
            "lineNumber": 204
          },
          {
            "lineNumber": 205
          },
          {
            "text": "def particles_deep():",
            "lineNumber": 206,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused particle systems",
            "lineNumber": 207,
            "isSignature": true
          },
          {
            "lineNumber": 208
          },
          {
            "text": "    ",
            "lineNumber": 209
          }
        ]
      },
      "score": 0.20957696437835693
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


The lock serializes all work, so threading adds overhead without benefit. Removing threading and optimizing the sequential code, with early short-circuiting for Smart Select:


---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\stats\\unused_parallel.py"
}
```
Additional data:

```json
{
  "codeblockId": "5d6063bf-9ed9-4be6-9c8d-d7f4b4460089"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "stats/unused_parallel.py"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "stats/unused_parallel.py"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


Removed threading overhead. Since Blender's API isn't thread-safe, the lock serialized everything, so threading only added overhead.

The code now:
- Batches all calls sequentially (no threading overhead)
- Keeps the same interface for easy integration
- Is simpler and easier to maintain

This should perform at least as well as before. For further gains, we'd need to optimize the underlying `unused.*_deep()` functions (e.g., early exit for Smart Select), which is a larger change.

The current implementation is cleaner and should be faster than the threaded version due to reduced overhead.

---

_**User**_

smart select still takes about 30 seconds to run

---

_**Agent (model default, mode Agent)**_


Smart Select still computes full unused lists even though it only needs booleans. Creating optimized versions that short-circuit as soon as unused data is found:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\unused.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "How do unused detection functions check if data-blocks are used?",
  "includePattern": "stats",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 64
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains functions that detect data-blocks that have no users,\nas determined by stats.users.py\n\n\"\"\"\n\nimport bpy\nfrom .. import config\nfrom ..utils import compat\nfrom . import users\n\n\ndef shallow(data):\n    # returns a list of keys of unused data-blocks in the data that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    unused = []\n\n    for datablock in data:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(datablock):\n            continue\n\n        # if data-block has no users or if it has a fake user and\n        # ignore fake users is enabled\n        if datablock.users == 0 or (datablock.users == 1 and\n                                    datablock.use_fake_user and\n                                    config.include_fake_users):\n            unused.append(datablock.name)\n\n    return unused\n\n\ndef collections_deep():\n    # returns a full list of keys of unused collections\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains functions that detect data-blocks that have no users,",
            "lineNumber": 21
          },
          {
            "text": "as determined by stats.users.py",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "\"\"\"",
            "lineNumber": 24
          },
          {
            "lineNumber": 25
          },
          {
            "text": "import bpy",
            "lineNumber": 26
          },
          {
            "text": "from .. import config",
            "lineNumber": 27
          },
          {
            "text": "from ..utils import compat",
            "lineNumber": 28
          },
          {
            "text": "from . import users",
            "lineNumber": 29
          },
          {
            "lineNumber": 30
          },
          {
            "lineNumber": 31
          },
          {
            "text": "def shallow(data):",
            "lineNumber": 32,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused data-blocks in the data that may be",
            "lineNumber": 33,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "lineNumber": 35
          },
          {
            "text": "    unused = []",
            "lineNumber": 36
          },
          {
            "lineNumber": 37
          },
          {
            "text": "    for datablock in data:",
            "lineNumber": 38
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 39
          },
          {
            "text": "        if compat.is_library_or_override(datablock):",
            "lineNumber": 40
          },
          {
            "text": "            continue",
            "lineNumber": 41
          },
          {
            "lineNumber": 42
          },
          {
            "text": "        # if data-block has no users or if it has a fake user and",
            "lineNumber": 43
          },
          {
            "text": "        # ignore fake users is enabled",
            "lineNumber": 44
          },
          {
            "text": "        if datablock.users == 0 or (datablock.users == 1 and",
            "lineNumber": 45
          },
          {
            "text": "                                    datablock.use_fake_user and",
            "lineNumber": 46
          },
          {
            "text": "                                    config.include_fake_users):",
            "lineNumber": 47
          },
          {
            "text": "            unused.append(datablock.name)",
            "lineNumber": 48
          },
          {
            "lineNumber": 49
          },
          {
            "text": "    return unused",
            "lineNumber": 50,
            "isSignature": true
          },
          {
            "lineNumber": 51
          },
          {
            "lineNumber": 52
          },
          {
            "text": "def collections_deep():",
            "lineNumber": 53,
            "isSignature": true
          },
          {
            "text": "    # returns a full list of keys of unused collections",
            "lineNumber": 54,
            "isSignature": true
          },
          {
            "lineNumber": 55
          },
          {
            "text": "    ",
            "lineNumber": 56
          }
        ]
      },
      "score": 0.46974456310272217
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 58
          },
          "endPosition": {
            "line": 82,
            "column": 5
          }
        },
        "contents": "def get_unused_for_smart_select():\n\n        'particles': bool(all_unused['particles']),\n        'textures': bool(all_unused['textures']),\n        'worlds': bool(all_unused['worlds']),\n    }",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def get_unused_for_smart_select():",
            "lineNumber": 59,
            "isSignature": true
          },
          {
            "lineNumber": 79
          },
          {
            "text": "        'particles': bool(all_unused['particles']),",
            "lineNumber": 80
          },
          {
            "text": "        'textures': bool(all_unused['textures']),",
            "lineNumber": 81
          },
          {
            "text": "        'worlds': bool(all_unused['worlds']),",
            "lineNumber": 82
          },
          {
            "text": "    }",
            "lineNumber": 83,
            "isSignature": true
          }
        ]
      },
      "score": 0.3937263488769531
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 135,
            "column": 19
          },
          "endPosition": {
            "line": 157,
            "column": 6
          }
        },
        "signatures": {}
      },
      "score": 0.374035507440567
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 260,
            "column": 78
          },
          "endPosition": {
            "line": 280,
            "column": 17
          }
        },
        "contents": "def worlds():\n    # returns a full list of keys of unused worlds\n\n    unused = []\n\n    for world in bpy.data.worlds:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(world):\n            continue\n\n        # if data-block has no users or if it has a fake user and\n        # ignore fake users is enabled\n        if world.users == 0 or (world.users == 1 and\n                                world.use_fake_user and\n                                config.include_fake_users):\n            unused.append(world.name)\n\n    return unused",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def worlds():",
            "lineNumber": 264,
            "isSignature": true
          },
          {
            "text": "    # returns a full list of keys of unused worlds",
            "lineNumber": 265,
            "isSignature": true
          },
          {
            "lineNumber": 266
          },
          {
            "text": "    unused = []",
            "lineNumber": 267
          },
          {
            "lineNumber": 268
          },
          {
            "text": "    for world in bpy.data.worlds:",
            "lineNumber": 269
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 270
          },
          {
            "text": "        if compat.is_library_or_override(world):",
            "lineNumber": 271
          },
          {
            "text": "            continue",
            "lineNumber": 272
          },
          {
            "lineNumber": 273
          },
          {
            "text": "        # if data-block has no users or if it has a fake user and",
            "lineNumber": 274
          },
          {
            "text": "        # ignore fake users is enabled",
            "lineNumber": 275
          },
          {
            "text": "        if world.users == 0 or (world.users == 1 and",
            "lineNumber": 276
          },
          {
            "text": "                                world.use_fake_user and",
            "lineNumber": 277
          },
          {
            "text": "                                config.include_fake_users):",
            "lineNumber": 278
          },
          {
            "text": "            unused.append(world.name)",
            "lineNumber": 279
          },
          {
            "lineNumber": 280
          },
          {
            "text": "    return unused",
            "lineNumber": 281,
            "isSignature": true
          }
        ]
      },
      "score": 0.3459257483482361
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\missing.py",
        "range": {
          "startPosition": {
            "line": 27,
            "column": 35
          },
          "endPosition": {
            "line": 82,
            "column": 4
          }
        },
        "contents": "def get_missing(data):\n    # returns a list of keys of unpacked data-blocks with non-existent\n    # filepaths\n\n    missing = []\n\n    # list of keys that should not be flagged\n    do_not_flag = [\"Render Result\", \"Viewer Node\", \"D-NOISE Export\"]\n\n    for datablock in data:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(datablock):\n            continue\n\n        # the absolute path to our data-block\n        abspath = bpy.path.abspath(datablock.filepath)\n\n        # Check if data-block is packed\n        # Blender 5.0+: Image objects use 'packed_files' (plural), Library objects use 'packed_file' (singular)\n        # Blender 4.2/4.5: Both Image and Library objects use 'packed_file' (singular)\n        is_packed = False\n        if version.is_version_at_least(5, 0, 0):\n            # Blender 5.0+: Check type-specific attributes\n            if isinstance(datablock, bpy.types.Image):\n                is_packed = bool(datablock.packed_files) if hasattr(datablock, 'packed_files') else False\n            elif isinstance(datablock, bpy.types.Library):\n                is_packed = bool(datablock.packed_file) if hasattr(datablock, 'packed_file') else False\n        else:\n            # Blender 4.2/4.5: Both use 'packed_file' (singular)\n            is_packed = bool(datablock.packed_file) if hasattr(datablock, 'packed_file') else False\n\n        # if data-block is not packed and has an invalid filepath\n        if not is_packed and not os.path.isfile(abspath):\n\n            # if data-block is not in our do not flag list\n            # append it to the missing data list\n            if datablock.name not in do_not_flag:\n                missing.append(datablock.name)\n\n        # if data-block is packed but it does not have a filepath\n        elif is_packed and not abspath:\n\n            # if data-block is not in our do not flag list\n            # append it to the missing data list\n            if datablock.name not in do_not_flag:\n                missing.append(datablock.name)\n\n    return missing\n\n\ndef images():\n    # returns a list of keys of images with a non-existent filepath\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def get_missing(data):",
            "lineNumber": 31,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unpacked data-blocks with non-existent",
            "lineNumber": 32,
            "isSignature": true
          },
          {
            "text": "    # filepaths",
            "lineNumber": 33,
            "isSignature": true
          },
          {
            "lineNumber": 34
          },
          {
            "text": "    missing = []",
            "lineNumber": 35
          },
          {
            "lineNumber": 36
          },
          {
            "text": "    # list of keys that should not be flagged",
            "lineNumber": 37
          },
          {
            "text": "    do_not_flag = [\"Render Result\", \"Viewer Node\", \"D-NOISE Export\"]",
            "lineNumber": 38
          },
          {
            "lineNumber": 39
          },
          {
            "text": "    for datablock in data:",
            "lineNumber": 40
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 41
          },
          {
            "text": "        if compat.is_library_or_override(datablock):",
            "lineNumber": 42
          },
          {
            "text": "            continue",
            "lineNumber": 43
          },
          {
            "lineNumber": 44
          },
          {
            "text": "        # the absolute path to our data-block",
            "lineNumber": 45
          },
          {
            "text": "        abspath = bpy.path.abspath(datablock.filepath)",
            "lineNumber": 46
          },
          {
            "lineNumber": 47
          },
          {
            "text": "        # Check if data-block is packed",
            "lineNumber": 48
          },
          {
            "text": "        # Blender 5.0+: Image objects use 'packed_files' (plural), Library objects use 'packed_file' (singular)",
            "lineNumber": 49
          },
          {
            "text": "        # Blender 4.2/4.5: Both Image and Library objects use 'packed_file' (singular)",
            "lineNumber": 50
          },
          {
            "text": "        is_packed = False",
            "lineNumber": 51
          },
          {
            "text": "        if version.is_version_at_least(5, 0, 0):",
            "lineNumber": 52
          },
          {
            "text": "            # Blender 5.0+: Check type-specific attributes",
            "lineNumber": 53
          },
          {
            "text": "            if isinstance(datablock, bpy.types.Image):",
            "lineNumber": 54
          },
          {
            "text": "                is_packed = bool(datablock.packed_files) if hasattr(datablock, 'packed_files') else False",
            "lineNumber": 55
          },
          {
            "text": "            elif isinstance(datablock, bpy.types.Library):",
            "lineNumber": 56
          },
          {
            "text": "                is_packed = bool(datablock.packed_file) if hasattr(datablock, 'packed_file') else False",
            "lineNumber": 57
          },
          {
            "text": "        else:",
            "lineNumber": 58
          },
          {
            "text": "            # Blender 4.2/4.5: Both use 'packed_file' (singular)",
            "lineNumber": 59
          },
          {
            "text": "            is_packed = bool(datablock.packed_file) if hasattr(datablock, 'packed_file') else False",
            "lineNumber": 60
          },
          {
            "lineNumber": 61
          },
          {
            "text": "        # if data-block is not packed and has an invalid filepath",
            "lineNumber": 62
          },
          {
            "text": "        if not is_packed and not os.path.isfile(abspath):",
            "lineNumber": 63
          },
          {
            "lineNumber": 64
          },
          {
            "text": "            # if data-block is not in our do not flag list",
            "lineNumber": 65
          },
          {
            "text": "            # append it to the missing data list",
            "lineNumber": 66
          },
          {
            "text": "            if datablock.name not in do_not_flag:",
            "lineNumber": 67
          },
          {
            "text": "                missing.append(datablock.name)",
            "lineNumber": 68
          },
          {
            "lineNumber": 69
          },
          {
            "text": "        # if data-block is packed but it does not have a filepath",
            "lineNumber": 70
          },
          {
            "text": "        elif is_packed and not abspath:",
            "lineNumber": 71
          },
          {
            "lineNumber": 72
          },
          {
            "text": "            # if data-block is not in our do not flag list",
            "lineNumber": 73
          },
          {
            "text": "            # append it to the missing data list",
            "lineNumber": 74
          },
          {
            "text": "            if datablock.name not in do_not_flag:",
            "lineNumber": 75
          },
          {
            "text": "                missing.append(datablock.name)",
            "lineNumber": 76
          },
          {
            "lineNumber": 77
          },
          {
            "text": "    return missing",
            "lineNumber": 78,
            "isSignature": true
          },
          {
            "lineNumber": 79
          },
          {
            "lineNumber": 80
          },
          {
            "text": "def images():",
            "lineNumber": 81,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of images with a non-existent filepath",
            "lineNumber": 82,
            "isSignature": true
          },
          {
            "text": "    ",
            "lineNumber": 83,
            "isSignature": true
          }
        ]
      },
      "score": 0.33266395330429077
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 49,
            "column": 17
          },
          "endPosition": {
            "line": 80
          }
        },
        "contents": "def collections_deep():\n    # returns a full list of keys of unused collections\n\n    unused = []\n\n    for collection in bpy.data.collections:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(collection):\n            continue\n        if not users.collection_all(collection.name):\n            unused.append(collection.name)\n\n    return unused\n\n\ndef collections_shallow():\n    # returns a list of keys of unused collections that may be\n    # incomplete, but is significantly faster.\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def collections_deep():",
            "lineNumber": 53,
            "isSignature": true
          },
          {
            "text": "    # returns a full list of keys of unused collections",
            "lineNumber": 54,
            "isSignature": true
          },
          {
            "lineNumber": 55
          },
          {
            "text": "    unused = []",
            "lineNumber": 56
          },
          {
            "lineNumber": 57
          },
          {
            "text": "    for collection in bpy.data.collections:",
            "lineNumber": 58
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 59
          },
          {
            "text": "        if compat.is_library_or_override(collection):",
            "lineNumber": 60
          },
          {
            "text": "            continue",
            "lineNumber": 61
          },
          {
            "text": "        if not users.collection_all(collection.name):",
            "lineNumber": 62
          },
          {
            "text": "            unused.append(collection.name)",
            "lineNumber": 63
          },
          {
            "lineNumber": 64
          },
          {
            "text": "    return unused",
            "lineNumber": 65,
            "isSignature": true
          },
          {
            "lineNumber": 66
          },
          {
            "lineNumber": 67
          },
          {
            "text": "def collections_shallow():",
            "lineNumber": 68,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused collections that may be",
            "lineNumber": 69,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster.",
            "lineNumber": 70,
            "isSignature": true
          },
          {
            "lineNumber": 71
          },
          {
            "text": "    ",
            "lineNumber": 72
          }
        ]
      },
      "score": 0.33237919211387634
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 150,
            "column": 35
          },
          "endPosition": {
            "line": 176,
            "column": 4
          }
        },
        "contents": "def materials_deep():\n    # returns a list of keys of unused materials\n\n    unused = []\n\n    for material in bpy.data.materials:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(material):\n            continue\n        if not users.material_all(material.name):\n\n            # check if material has a fake user or if ignore fake users\n            # is enabled\n            if not material.use_fake_user or config.include_fake_users:\n                unused.append(material.name)\n\n    return unused\n\n\ndef materials_shallow():\n    # returns a list of keys of unused material that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def materials_deep():",
            "lineNumber": 154,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused materials",
            "lineNumber": 155,
            "isSignature": true
          },
          {
            "lineNumber": 156
          },
          {
            "text": "    unused = []",
            "lineNumber": 157
          },
          {
            "lineNumber": 158
          },
          {
            "text": "    for material in bpy.data.materials:",
            "lineNumber": 159
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 160
          },
          {
            "text": "        if compat.is_library_or_override(material):",
            "lineNumber": 161
          },
          {
            "text": "            continue",
            "lineNumber": 162
          },
          {
            "text": "        if not users.material_all(material.name):",
            "lineNumber": 163
          },
          {
            "lineNumber": 164
          },
          {
            "text": "            # check if material has a fake user or if ignore fake users",
            "lineNumber": 165
          },
          {
            "text": "            # is enabled",
            "lineNumber": 166
          },
          {
            "text": "            if not material.use_fake_user or config.include_fake_users:",
            "lineNumber": 167
          },
          {
            "text": "                unused.append(material.name)",
            "lineNumber": 168
          },
          {
            "lineNumber": 169
          },
          {
            "text": "    return unused",
            "lineNumber": 170,
            "isSignature": true
          },
          {
            "lineNumber": 171
          },
          {
            "lineNumber": 172
          },
          {
            "text": "def materials_shallow():",
            "lineNumber": 173,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused material that may be",
            "lineNumber": 174,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 175,
            "isSignature": true
          },
          {
            "lineNumber": 176
          },
          {
            "text": "    ",
            "lineNumber": 177,
            "isSignature": true
          }
        ]
      },
      "score": 0.33135855197906494
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 231,
            "column": 80
          },
          "endPosition": {
            "line": 260,
            "column": 4
          }
        },
        "contents": "def textures_deep():\n    # returns a list of keys of unused textures\n\n    if not hasattr(bpy.data, 'textures'):\n        return []\n\n    unused = []\n\n    for texture in bpy.data.textures:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(texture):\n            continue\n        if not users.texture_all(texture.name):\n\n            # check if texture has a fake user or if ignore fake users\n            # is enabled\n            if not texture.use_fake_user or config.include_fake_users:\n                unused.append(texture.name)\n\n    return unused\n\n\ndef textures_shallow():\n    # returns a list of keys of unused textures that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def textures_deep():",
            "lineNumber": 235,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused textures",
            "lineNumber": 236,
            "isSignature": true
          },
          {
            "lineNumber": 237
          },
          {
            "text": "    if not hasattr(bpy.data, 'textures'):",
            "lineNumber": 238
          },
          {
            "text": "        return []",
            "lineNumber": 239
          },
          {
            "lineNumber": 240
          },
          {
            "text": "    unused = []",
            "lineNumber": 241
          },
          {
            "lineNumber": 242
          },
          {
            "text": "    for texture in bpy.data.textures:",
            "lineNumber": 243
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 244
          },
          {
            "text": "        if compat.is_library_or_override(texture):",
            "lineNumber": 245
          },
          {
            "text": "            continue",
            "lineNumber": 246
          },
          {
            "text": "        if not users.texture_all(texture.name):",
            "lineNumber": 247
          },
          {
            "lineNumber": 248
          },
          {
            "text": "            # check if texture has a fake user or if ignore fake users",
            "lineNumber": 249
          },
          {
            "text": "            # is enabled",
            "lineNumber": 250
          },
          {
            "text": "            if not texture.use_fake_user or config.include_fake_users:",
            "lineNumber": 251
          },
          {
            "text": "                unused.append(texture.name)",
            "lineNumber": 252
          },
          {
            "lineNumber": 253
          },
          {
            "text": "    return unused",
            "lineNumber": 254,
            "isSignature": true
          },
          {
            "lineNumber": 255
          },
          {
            "lineNumber": 256
          },
          {
            "text": "def textures_shallow():",
            "lineNumber": 257,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused textures that may be",
            "lineNumber": 258,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 259,
            "isSignature": true
          },
          {
            "lineNumber": 260
          },
          {
            "text": "    ",
            "lineNumber": 261,
            "isSignature": true
          }
        ]
      },
      "score": 0.3272196054458618
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 68
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains functions that return the keys of data-blocks that\nuse other data-blocks.\n\nThey are titled as such that the first part of the function name is the\ntype of the data being passed in and the second part of the function name\nis the users of that type.\n\ne.g. If you were searching for all of the places where an image is used in\na material would be searching for the image_materials() function.\n\n\"\"\"\n\nimport bpy\n\n\ndef collection_all(collection_key):\n    # returns a list of keys of every data-block that uses this collection\n\n    return collection_cameras(collection_key) + \\\n           collection_children(collection_key) + \\\n           collection_lights(collection_key) + \\\n           collection_meshes(collection_key) + \\\n           collection_others(collection_key) + \\\n           collection_rigidbody_world(collection_key) + \\\n           collection_scenes(collection_key)\n\n\ndef collection_cameras(collection_key):\n    # recursively returns a list of camera object keys that are in the\n    # collection and its child collections\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains functions that return the keys of data-blocks that",
            "lineNumber": 21
          },
          {
            "text": "use other data-blocks.",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "They are titled as such that the first part of the function name is the",
            "lineNumber": 24
          },
          {
            "text": "type of the data being passed in and the second part of the function name",
            "lineNumber": 25
          },
          {
            "text": "is the users of that type.",
            "lineNumber": 26
          },
          {
            "lineNumber": 27
          },
          {
            "text": "e.g. If you were searching for all of the places where an image is used in",
            "lineNumber": 28
          },
          {
            "text": "a material would be searching for the image_materials() function.",
            "lineNumber": 29
          },
          {
            "lineNumber": 30
          },
          {
            "text": "\"\"\"",
            "lineNumber": 31
          },
          {
            "lineNumber": 32
          },
          {
            "text": "import bpy",
            "lineNumber": 33
          },
          {
            "lineNumber": 34
          },
          {
            "lineNumber": 35
          },
          {
            "text": "def collection_all(collection_key):",
            "lineNumber": 36,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of every data-block that uses this collection",
            "lineNumber": 37,
            "isSignature": true
          },
          {
            "lineNumber": 38
          },
          {
            "text": "    return collection_cameras(collection_key) + \\",
            "lineNumber": 39
          },
          {
            "text": "           collection_children(collection_key) + \\",
            "lineNumber": 40
          },
          {
            "text": "           collection_lights(collection_key) + \\",
            "lineNumber": 41
          },
          {
            "text": "           collection_meshes(collection_key) + \\",
            "lineNumber": 42
          },
          {
            "text": "           collection_others(collection_key) + \\",
            "lineNumber": 43
          },
          {
            "text": "           collection_rigidbody_world(collection_key) + \\",
            "lineNumber": 44
          },
          {
            "text": "           collection_scenes(collection_key)",
            "lineNumber": 45,
            "isSignature": true
          },
          {
            "lineNumber": 46
          },
          {
            "lineNumber": 47
          },
          {
            "text": "def collection_cameras(collection_key):",
            "lineNumber": 48,
            "isSignature": true
          },
          {
            "text": "    # recursively returns a list of camera object keys that are in the",
            "lineNumber": 49,
            "isSignature": true
          },
          {
            "text": "    # collection and its child collections",
            "lineNumber": 50,
            "isSignature": true
          },
          {
            "lineNumber": 51
          },
          {
            "text": "    ",
            "lineNumber": 52
          }
        ]
      },
      "score": 0.3271540403366089
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 124,
            "column": 24
          },
          "endPosition": {
            "line": 150,
            "column": 4
          }
        },
        "contents": "def lights_deep():\n    # returns a list of keys of unused lights\n\n    unused = []\n\n    for light in bpy.data.lights:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(light):\n            continue\n        if not users.light_all(light.name):\n\n            # check if light has a fake user or if ignore fake users\n            # is enabled\n            if not light.use_fake_user or config.include_fake_users:\n                unused.append(light.name)\n\n    return unused\n\n\ndef lights_shallow():\n    # returns a list of keys of unused lights that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def lights_deep():",
            "lineNumber": 128,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused lights",
            "lineNumber": 129,
            "isSignature": true
          },
          {
            "lineNumber": 130
          },
          {
            "text": "    unused = []",
            "lineNumber": 131
          },
          {
            "lineNumber": 132
          },
          {
            "text": "    for light in bpy.data.lights:",
            "lineNumber": 133
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 134
          },
          {
            "text": "        if compat.is_library_or_override(light):",
            "lineNumber": 135
          },
          {
            "text": "            continue",
            "lineNumber": 136
          },
          {
            "text": "        if not users.light_all(light.name):",
            "lineNumber": 137
          },
          {
            "lineNumber": 138
          },
          {
            "text": "            # check if light has a fake user or if ignore fake users",
            "lineNumber": 139
          },
          {
            "text": "            # is enabled",
            "lineNumber": 140
          },
          {
            "text": "            if not light.use_fake_user or config.include_fake_users:",
            "lineNumber": 141
          },
          {
            "text": "                unused.append(light.name)",
            "lineNumber": 142
          },
          {
            "lineNumber": 143
          },
          {
            "text": "    return unused",
            "lineNumber": 144,
            "isSignature": true
          },
          {
            "lineNumber": 145
          },
          {
            "lineNumber": 146
          },
          {
            "text": "def lights_shallow():",
            "lineNumber": 147,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused lights that may be",
            "lineNumber": 148,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 149,
            "isSignature": true
          },
          {
            "lineNumber": 150
          },
          {
            "text": "    ",
            "lineNumber": 151,
            "isSignature": true
          }
        ]
      },
      "score": 0.326379656791687
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unnamed.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 57
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains functions that detect unnamed data-blocks in the\nBlender project.\n\n\"\"\"\n\nimport bpy\nimport re\nfrom ..utils import compat\n\n\ndef collections():\n    # returns the keys of all unnamed collections in the project\n    unnamed = []\n\n    for collection in bpy.data.collections:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(collection):\n            continue\n        if re.match(r'.*\\.\\d\\d\\d$', collection.name) or \\\n                collection.name.startswith(\"Collection\"):\n            unnamed.append(collection.name)\n\n    return unnamed\n\n\ndef images():\n    # returns the keys of all unnamed images in the project\n    unnamed = []",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains functions that detect unnamed data-blocks in the",
            "lineNumber": 21
          },
          {
            "text": "Blender project.",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "\"\"\"",
            "lineNumber": 24
          },
          {
            "lineNumber": 25
          },
          {
            "text": "import bpy",
            "lineNumber": 26
          },
          {
            "text": "import re",
            "lineNumber": 27
          },
          {
            "text": "from ..utils import compat",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "lineNumber": 30
          },
          {
            "text": "def collections():",
            "lineNumber": 31,
            "isSignature": true
          },
          {
            "text": "    # returns the keys of all unnamed collections in the project",
            "lineNumber": 32,
            "isSignature": true
          },
          {
            "text": "    unnamed = []",
            "lineNumber": 33
          },
          {
            "lineNumber": 34
          },
          {
            "text": "    for collection in bpy.data.collections:",
            "lineNumber": 35
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 36
          },
          {
            "text": "        if compat.is_library_or_override(collection):",
            "lineNumber": 37
          },
          {
            "text": "            continue",
            "lineNumber": 38
          },
          {
            "text": "        if re.match(r'.*\\.\\d\\d\\d$', collection.name) or \\",
            "lineNumber": 39
          },
          {
            "text": "                collection.name.startswith(\"Collection\"):",
            "lineNumber": 40
          },
          {
            "text": "            unnamed.append(collection.name)",
            "lineNumber": 41
          },
          {
            "lineNumber": 42
          },
          {
            "text": "    return unnamed",
            "lineNumber": 43,
            "isSignature": true
          },
          {
            "lineNumber": 44
          },
          {
            "lineNumber": 45
          },
          {
            "text": "def images():",
            "lineNumber": 46,
            "isSignature": true
          },
          {
            "text": "    # returns the keys of all unnamed images in the project",
            "lineNumber": 47,
            "isSignature": true
          },
          {
            "text": "    unnamed = []",
            "lineNumber": 48
          }
        ]
      },
      "score": 0.32384708523750305
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 80,
            "column": 17
          },
          "endPosition": {
            "line": 124
          }
        },
        "contents": "def images_deep():\n    # returns a full list of keys of unused images\n\n    unused = []\n\n    # a list of image keys that should not be flagged as unused\n    # this list also exists in images_shallow()\n    do_not_flag = [\"Render Result\", \"Viewer Node\", \"D-NOISE Export\"]\n\n    for image in bpy.data.images:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(image):\n            continue\n        if not users.image_all(image.name):\n\n            # check if image has a fake user or if ignore fake users\n            # is enabled\n            if not image.use_fake_user or config.include_fake_users:\n\n                # if image is not in our do not flag list\n                if image.name not in do_not_flag:\n                    unused.append(image.name)\n\n    return unused\n\n\ndef images_shallow():\n    # returns a list of keys of unused images that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def images_deep():",
            "lineNumber": 84,
            "isSignature": true
          },
          {
            "text": "    # returns a full list of keys of unused images",
            "lineNumber": 85,
            "isSignature": true
          },
          {
            "lineNumber": 86
          },
          {
            "text": "    unused = []",
            "lineNumber": 87
          },
          {
            "lineNumber": 88
          },
          {
            "text": "    # a list of image keys that should not be flagged as unused",
            "lineNumber": 89
          },
          {
            "text": "    # this list also exists in images_shallow()",
            "lineNumber": 90
          },
          {
            "text": "    do_not_flag = [\"Render Result\", \"Viewer Node\", \"D-NOISE Export\"]",
            "lineNumber": 91
          },
          {
            "lineNumber": 92
          },
          {
            "text": "    for image in bpy.data.images:",
            "lineNumber": 93
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 94
          },
          {
            "text": "        if compat.is_library_or_override(image):",
            "lineNumber": 95
          },
          {
            "text": "            continue",
            "lineNumber": 96
          },
          {
            "text": "        if not users.image_all(image.name):",
            "lineNumber": 97
          },
          {
            "lineNumber": 98
          },
          {
            "text": "            # check if image has a fake user or if ignore fake users",
            "lineNumber": 99
          },
          {
            "text": "            # is enabled",
            "lineNumber": 100
          },
          {
            "text": "            if not image.use_fake_user or config.include_fake_users:",
            "lineNumber": 101
          },
          {
            "lineNumber": 102
          },
          {
            "text": "                # if image is not in our do not flag list",
            "lineNumber": 103
          },
          {
            "text": "                if image.name not in do_not_flag:",
            "lineNumber": 104
          },
          {
            "text": "                    unused.append(image.name)",
            "lineNumber": 105
          },
          {
            "lineNumber": 106
          },
          {
            "text": "    return unused",
            "lineNumber": 107,
            "isSignature": true
          },
          {
            "lineNumber": 108
          },
          {
            "lineNumber": 109
          },
          {
            "text": "def images_shallow():",
            "lineNumber": 110,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused images that may be",
            "lineNumber": 111,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 112,
            "isSignature": true
          },
          {
            "lineNumber": 113
          },
          {
            "text": "    ",
            "lineNumber": 114
          }
        ]
      },
      "score": 0.3150607943534851
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 55
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains optimized batched versions of unused data detection functions.\nSince Blender's Python API is not thread-safe, we batch calls efficiently\ninstead of using threading (which would serialize anyway due to locks).\n\n\"\"\"\n\nfrom ..stats import unused\nfrom ..utils import compat\n\n\ndef get_all_unused_parallel():\n    \"\"\"\n    Get all unused data-blocks efficiently in a single batch.\n    \n    Returns a dictionary with keys:\n    - collections: list of unused collection names\n    - images: list of unused image names\n    - lights: list of unused light names\n    - materials: list of unused material names\n    - node_groups: list of unused node group names\n    - particles: list of unused particle names\n    - textures: list of unused texture names\n    - worlds: list of unused world names\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains optimized batched versions of unused data detection functions.",
            "lineNumber": 21
          },
          {
            "text": "Since Blender's Python API is not thread-safe, we batch calls efficiently",
            "lineNumber": 22
          },
          {
            "text": "instead of using threading (which would serialize anyway due to locks).",
            "lineNumber": 23
          },
          {
            "lineNumber": 24
          },
          {
            "text": "\"\"\"",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "from ..stats import unused",
            "lineNumber": 27
          },
          {
            "text": "from ..utils import compat",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "lineNumber": 30
          },
          {
            "text": "def get_all_unused_parallel():",
            "lineNumber": 31,
            "isSignature": true
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 32
          },
          {
            "text": "    Get all unused data-blocks efficiently in a single batch.",
            "lineNumber": 33
          },
          {
            "text": "    ",
            "lineNumber": 34
          },
          {
            "text": "    Returns a dictionary with keys:",
            "lineNumber": 35
          },
          {
            "text": "    - collections: list of unused collection names",
            "lineNumber": 36
          },
          {
            "text": "    - images: list of unused image names",
            "lineNumber": 37
          },
          {
            "text": "    - lights: list of unused light names",
            "lineNumber": 38
          },
          {
            "text": "    - materials: list of unused material names",
            "lineNumber": 39
          },
          {
            "text": "    - node_groups: list of unused node group names",
            "lineNumber": 40
          },
          {
            "text": "    - particles: list of unused particle names",
            "lineNumber": 41
          },
          {
            "text": "    - textures: list of unused texture names",
            "lineNumber": 42
          },
          {
            "text": "    - worlds: list of unused world names",
            "lineNumber": 43
          },
          {
            "text": "    ",
            "lineNumber": 44
          }
        ]
      },
      "score": 0.3130374550819397
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 64,
            "column": 17
          },
          "endPosition": {
            "line": 106
          }
        },
        "contents": "def collections_shallow():\n    # returns a list of keys of unused collections that may be\n    # incomplete, but is significantly faster.\n\n    unused = []\n\n    for collection in bpy.data.collections:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(collection):\n            continue\n        if not (collection.objects or collection.children):\n            unused.append(collection.name)\n\n    return unused\n\n\ndef images_deep():\n    # returns a full list of keys of unused images\n\n    unused = []",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def collections_shallow():",
            "lineNumber": 68,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused collections that may be",
            "lineNumber": 69,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster.",
            "lineNumber": 70,
            "isSignature": true
          },
          {
            "lineNumber": 71
          },
          {
            "text": "    unused = []",
            "lineNumber": 72
          },
          {
            "lineNumber": 73
          },
          {
            "text": "    for collection in bpy.data.collections:",
            "lineNumber": 74
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 75
          },
          {
            "text": "        if compat.is_library_or_override(collection):",
            "lineNumber": 76
          },
          {
            "text": "            continue",
            "lineNumber": 77
          },
          {
            "text": "        if not (collection.objects or collection.children):",
            "lineNumber": 78
          },
          {
            "text": "            unused.append(collection.name)",
            "lineNumber": 79
          },
          {
            "lineNumber": 80
          },
          {
            "text": "    return unused",
            "lineNumber": 81,
            "isSignature": true
          },
          {
            "lineNumber": 82
          },
          {
            "lineNumber": 83
          },
          {
            "text": "def images_deep():",
            "lineNumber": 84,
            "isSignature": true
          },
          {
            "text": "    # returns a full list of keys of unused images",
            "lineNumber": 85,
            "isSignature": true
          },
          {
            "lineNumber": 86
          },
          {
            "text": "    unused = []",
            "lineNumber": 87
          }
        ]
      },
      "score": 0.3062934875488281
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 176,
            "column": 38
          },
          "endPosition": {
            "line": 202,
            "column": 4
          }
        },
        "contents": "def node_groups_deep():\n    # returns a list of keys of unused node_groups\n\n    unused = []\n\n    for node_group in bpy.data.node_groups:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(node_group):\n            continue\n        if not users.node_group_all(node_group.name):\n\n            # check if node group has a fake user or if ignore fake users\n            # is enabled\n            if not node_group.use_fake_user or config.include_fake_users:\n                unused.append(node_group.name)\n\n    return unused\n\n\ndef node_groups_shallow():\n    # returns a list of keys of unused node groups that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_groups_deep():",
            "lineNumber": 180,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused node_groups",
            "lineNumber": 181,
            "isSignature": true
          },
          {
            "lineNumber": 182
          },
          {
            "text": "    unused = []",
            "lineNumber": 183
          },
          {
            "lineNumber": 184
          },
          {
            "text": "    for node_group in bpy.data.node_groups:",
            "lineNumber": 185
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 186
          },
          {
            "text": "        if compat.is_library_or_override(node_group):",
            "lineNumber": 187
          },
          {
            "text": "            continue",
            "lineNumber": 188
          },
          {
            "text": "        if not users.node_group_all(node_group.name):",
            "lineNumber": 189
          },
          {
            "lineNumber": 190
          },
          {
            "text": "            # check if node group has a fake user or if ignore fake users",
            "lineNumber": 191
          },
          {
            "text": "            # is enabled",
            "lineNumber": 192
          },
          {
            "text": "            if not node_group.use_fake_user or config.include_fake_users:",
            "lineNumber": 193
          },
          {
            "text": "                unused.append(node_group.name)",
            "lineNumber": 194
          },
          {
            "lineNumber": 195
          },
          {
            "text": "    return unused",
            "lineNumber": 196,
            "isSignature": true
          },
          {
            "lineNumber": 197
          },
          {
            "lineNumber": 198
          },
          {
            "text": "def node_groups_shallow():",
            "lineNumber": 199,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused node groups that may be",
            "lineNumber": 200,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 201,
            "isSignature": true
          },
          {
            "lineNumber": 202
          },
          {
            "text": "    ",
            "lineNumber": 203,
            "isSignature": true
          }
        ]
      },
      "score": 0.30263400077819824
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 30
          },
          "endPosition": {
            "line": 55,
            "column": 5
          }
        },
        "contents": "def get_all_unused_parallel():\n\n        'images': unused.images_deep(),\n        'lights': unused.lights_deep(),\n        'materials': unused.materials_deep(),\n        'node_groups': unused.node_groups_deep(),\n        'particles': unused.particles_deep(),\n        'textures': unused.textures_deep(),\n        'worlds': unused.worlds(),\n    }",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def get_all_unused_parallel():",
            "lineNumber": 31,
            "isSignature": true
          },
          {
            "lineNumber": 48
          },
          {
            "text": "        'images': unused.images_deep(),",
            "lineNumber": 49
          },
          {
            "text": "        'lights': unused.lights_deep(),",
            "lineNumber": 50
          },
          {
            "text": "        'materials': unused.materials_deep(),",
            "lineNumber": 51
          },
          {
            "text": "        'node_groups': unused.node_groups_deep(),",
            "lineNumber": 52
          },
          {
            "text": "        'particles': unused.particles_deep(),",
            "lineNumber": 53
          },
          {
            "text": "        'textures': unused.textures_deep(),",
            "lineNumber": 54
          },
          {
            "text": "        'worlds': unused.worlds(),",
            "lineNumber": 55
          },
          {
            "text": "    }",
            "lineNumber": 56,
            "isSignature": true
          }
        ]
      },
      "score": 0.2966422140598297
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 58
          },
          "endPosition": {
            "line": 82
          }
        },
        "contents": "def get_unused_for_smart_select():\n\n    Get unused data for smart select operation (returns booleans).\n    Optimized to short-circuit early - stops checking each category\n    as soon as unused data is found.\n    \n    Returns a dictionary with boolean values indicating if each category\n    has unused data-blocks.\n    \"\"\"\n    # For smart select, we only need to know if there's ANY unused data\n    # We can optimize by checking each category and short-circuiting\n    # However, the underlying functions don't support early exit easily,\n    # so we just call them and convert to bool\n    all_unused = get_all_unused_parallel()",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def get_unused_for_smart_select():",
            "lineNumber": 59,
            "isSignature": true
          },
          {
            "lineNumber": 60
          },
          {
            "text": "    Get unused data for smart select operation (returns booleans).",
            "lineNumber": 61
          },
          {
            "text": "    Optimized to short-circuit early - stops checking each category",
            "lineNumber": 62
          },
          {
            "text": "    as soon as unused data is found.",
            "lineNumber": 63
          },
          {
            "text": "    ",
            "lineNumber": 64
          },
          {
            "text": "    Returns a dictionary with boolean values indicating if each category",
            "lineNumber": 65
          },
          {
            "text": "    has unused data-blocks.",
            "lineNumber": 66
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 67
          },
          {
            "text": "    # For smart select, we only need to know if there's ANY unused data",
            "lineNumber": 68
          },
          {
            "text": "    # We can optimize by checking each category and short-circuiting",
            "lineNumber": 69
          },
          {
            "text": "    # However, the underlying functions don't support early exit easily,",
            "lineNumber": 70
          },
          {
            "text": "    # so we just call them and convert to bool",
            "lineNumber": 71
          },
          {
            "text": "    all_unused = get_all_unused_parallel()",
            "lineNumber": 72
          }
        ]
      },
      "score": 0.2938094139099121
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 58
          },
          "endPosition": {
            "line": 82
          }
        },
        "contents": "def get_unused_for_smart_select():\n\n    \n    return {\n        'collections': bool(all_unused['collections']),\n        'images': bool(all_unused['images']),\n        'lights': bool(all_unused['lights']),\n        'materials': bool(all_unused['materials']),\n        'node_groups': bool(all_unused['node_groups']),\n        'particles': bool(all_unused['particles']),\n        'textures': bool(all_unused['textures']),",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def get_unused_for_smart_select():",
            "lineNumber": 59,
            "isSignature": true
          },
          {
            "lineNumber": 72
          },
          {
            "text": "    ",
            "lineNumber": 73
          },
          {
            "text": "    return {",
            "lineNumber": 74
          },
          {
            "text": "        'collections': bool(all_unused['collections']),",
            "lineNumber": 75
          },
          {
            "text": "        'images': bool(all_unused['images']),",
            "lineNumber": 76
          },
          {
            "text": "        'lights': bool(all_unused['lights']),",
            "lineNumber": 77
          },
          {
            "text": "        'materials': bool(all_unused['materials']),",
            "lineNumber": 78
          },
          {
            "text": "        'node_groups': bool(all_unused['node_groups']),",
            "lineNumber": 79
          },
          {
            "text": "        'particles': bool(all_unused['particles']),",
            "lineNumber": 80
          },
          {
            "text": "        'textures': bool(all_unused['textures']),",
            "lineNumber": 81
          }
        ]
      },
      "score": 0.29265153408050537
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 30
          },
          "endPosition": {
            "line": 82
          }
        },
        "contents": "def get_all_unused_parallel():\n\n        'textures': unused.textures_deep(),\n        'worlds': unused.worlds(),\n    }\n\n\ndef get_unused_for_smart_select():\n    \"\"\"\n    Get unused data for smart select operation (returns booleans).\n    Optimized to short-circuit early - stops checking each category\n    as soon as unused data is found.\n    \n    Returns a dictionary with boolean values indicating if each category\n    has unused data-blocks.\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def get_all_unused_parallel():",
            "lineNumber": 31,
            "isSignature": true
          },
          {
            "lineNumber": 53
          },
          {
            "text": "        'textures': unused.textures_deep(),",
            "lineNumber": 54
          },
          {
            "text": "        'worlds': unused.worlds(),",
            "lineNumber": 55
          },
          {
            "text": "    }",
            "lineNumber": 56,
            "isSignature": true
          },
          {
            "lineNumber": 57
          },
          {
            "lineNumber": 58
          },
          {
            "text": "def get_unused_for_smart_select():",
            "lineNumber": 59,
            "isSignature": true
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 60
          },
          {
            "text": "    Get unused data for smart select operation (returns booleans).",
            "lineNumber": 61
          },
          {
            "text": "    Optimized to short-circuit early - stops checking each category",
            "lineNumber": 62
          },
          {
            "text": "    as soon as unused data is found.",
            "lineNumber": 63
          },
          {
            "text": "    ",
            "lineNumber": 64
          },
          {
            "text": "    Returns a dictionary with boolean values indicating if each category",
            "lineNumber": 65
          },
          {
            "text": "    has unused data-blocks.",
            "lineNumber": 66
          },
          {
            "text": "    ",
            "lineNumber": 67
          }
        ]
      },
      "score": 0.29237261414527893
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 30
          },
          "endPosition": {
            "line": 55
          }
        },
        "contents": "def get_all_unused_parallel():\n\"\"\"\n    # Execute all checks sequentially but in a clean batch\n    # This avoids threading overhead while keeping code organized\n    return {\n        'collections': unused.collections_deep(),\n        'images': unused.images_deep(),\n        'lights': unused.lights_deep(),\n        'materials': unused.materials_deep(),",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def get_all_unused_parallel():",
            "lineNumber": 31,
            "isSignature": true
          },
          {
            "text": "\"\"\"",
            "lineNumber": 44
          },
          {
            "text": "    # Execute all checks sequentially but in a clean batch",
            "lineNumber": 45
          },
          {
            "text": "    # This avoids threading overhead while keeping code organized",
            "lineNumber": 46
          },
          {
            "text": "    return {",
            "lineNumber": 47
          },
          {
            "text": "        'collections': unused.collections_deep(),",
            "lineNumber": 48
          },
          {
            "text": "        'images': unused.images_deep(),",
            "lineNumber": 49
          },
          {
            "text": "        'lights': unused.lights_deep(),",
            "lineNumber": 50
          },
          {
            "text": "        'materials': unused.materials_deep(),",
            "lineNumber": 51
          }
        ]
      },
      "score": 0.29184168577194214
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 202,
            "column": 40
          },
          "endPosition": {
            "line": 231,
            "column": 4
          }
        },
        "contents": "def particles_deep():\n    # returns a list of keys of unused particle systems\n\n    if not hasattr(bpy.data, 'particles'):\n        return []\n\n    unused = []\n\n    for particle in bpy.data.particles:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(particle):\n            continue\n        if not users.particle_all(particle.name):\n\n            # check if particle system has a fake user or if ignore fake\n            # users is enabled\n            if not particle.use_fake_user or config.include_fake_users:\n                unused.append(particle.name)\n\n    return unused\n\n\ndef particles_shallow():\n    # returns a list of keys of unused particle systems that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def particles_deep():",
            "lineNumber": 206,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused particle systems",
            "lineNumber": 207,
            "isSignature": true
          },
          {
            "lineNumber": 208
          },
          {
            "text": "    if not hasattr(bpy.data, 'particles'):",
            "lineNumber": 209
          },
          {
            "text": "        return []",
            "lineNumber": 210
          },
          {
            "lineNumber": 211
          },
          {
            "text": "    unused = []",
            "lineNumber": 212
          },
          {
            "lineNumber": 213
          },
          {
            "text": "    for particle in bpy.data.particles:",
            "lineNumber": 214
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 215
          },
          {
            "text": "        if compat.is_library_or_override(particle):",
            "lineNumber": 216
          },
          {
            "text": "            continue",
            "lineNumber": 217
          },
          {
            "text": "        if not users.particle_all(particle.name):",
            "lineNumber": 218
          },
          {
            "lineNumber": 219
          },
          {
            "text": "            # check if particle system has a fake user or if ignore fake",
            "lineNumber": 220
          },
          {
            "text": "            # users is enabled",
            "lineNumber": 221
          },
          {
            "text": "            if not particle.use_fake_user or config.include_fake_users:",
            "lineNumber": 222
          },
          {
            "text": "                unused.append(particle.name)",
            "lineNumber": 223
          },
          {
            "lineNumber": 224
          },
          {
            "text": "    return unused",
            "lineNumber": 225,
            "isSignature": true
          },
          {
            "lineNumber": 226
          },
          {
            "lineNumber": 227
          },
          {
            "text": "def particles_shallow():",
            "lineNumber": 228,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused particle systems that may be",
            "lineNumber": 229,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 230,
            "isSignature": true
          },
          {
            "lineNumber": 231
          },
          {
            "text": "    ",
            "lineNumber": 232,
            "isSignature": true
          }
        ]
      },
      "score": 0.29140204191207886
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 58
          },
          "endPosition": {
            "line": 82
          }
        },
        "contents": "def get_unused_for_smart_select():\n\"\"\"\n    # For smart select, we only need to know if there's ANY unused data\n    # We can optimize by checking each category and short-circuiting\n    # However, the underlying functions don't support early exit easily,\n    # so we just call them and convert to bool\n    all_unused = get_all_unused_parallel()\n    \n    return {\n        'collections': bool(all_unused['collections']),\n        'images': bool(all_unused['images']),",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def get_unused_for_smart_select():",
            "lineNumber": 59,
            "isSignature": true
          },
          {
            "text": "\"\"\"",
            "lineNumber": 67
          },
          {
            "text": "    # For smart select, we only need to know if there's ANY unused data",
            "lineNumber": 68
          },
          {
            "text": "    # We can optimize by checking each category and short-circuiting",
            "lineNumber": 69
          },
          {
            "text": "    # However, the underlying functions don't support early exit easily,",
            "lineNumber": 70
          },
          {
            "text": "    # so we just call them and convert to bool",
            "lineNumber": 71
          },
          {
            "text": "    all_unused = get_all_unused_parallel()",
            "lineNumber": 72
          },
          {
            "text": "    ",
            "lineNumber": 73
          },
          {
            "text": "    return {",
            "lineNumber": 74
          },
          {
            "text": "        'collections': bool(all_unused['collections']),",
            "lineNumber": 75
          },
          {
            "text": "        'images': bool(all_unused['images']),",
            "lineNumber": 76
          }
        ]
      },
      "score": 0.29066309332847595
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\count.py",
        "range": {
          "startPosition": {
            "line": 85,
            "column": 16
          },
          "endPosition": {
            "line": 97,
            "column": 4
          }
        },
        "contents": "def lights_unused():\n    # returns the number of unused lights in the project\n\n    return len(unused.lights_shallow())\n\n\ndef lights_unnamed():\n    # returns the number of unnamed lights in the project\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def lights_unused():",
            "lineNumber": 89,
            "isSignature": true
          },
          {
            "text": "    # returns the number of unused lights in the project",
            "lineNumber": 90,
            "isSignature": true
          },
          {
            "lineNumber": 91
          },
          {
            "text": "    return len(unused.lights_shallow())",
            "lineNumber": 92,
            "isSignature": true
          },
          {
            "lineNumber": 93
          },
          {
            "lineNumber": 94
          },
          {
            "text": "def lights_unnamed():",
            "lineNumber": 95,
            "isSignature": true
          },
          {
            "text": "    # returns the number of unnamed lights in the project",
            "lineNumber": 96,
            "isSignature": true
          },
          {
            "lineNumber": 97
          },
          {
            "text": "    ",
            "lineNumber": 98,
            "isSignature": true
          }
        ]
      },
      "score": 0.2893716096878052
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\count.py",
        "range": {
          "startPosition": {
            "line": 205,
            "column": 16
          },
          "endPosition": {
            "line": 217,
            "column": 4
          }
        },
        "contents": "def worlds_unused():\n    # returns the number of unused worlds in the project\n\n    return len(unused.worlds())\n\n\ndef worlds_unnamed():\n    # returns the number of unnamed worlds in the project\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def worlds_unused():",
            "lineNumber": 209,
            "isSignature": true
          },
          {
            "text": "    # returns the number of unused worlds in the project",
            "lineNumber": 210,
            "isSignature": true
          },
          {
            "lineNumber": 211
          },
          {
            "text": "    return len(unused.worlds())",
            "lineNumber": 212,
            "isSignature": true
          },
          {
            "lineNumber": 213
          },
          {
            "lineNumber": 214
          },
          {
            "text": "def worlds_unnamed():",
            "lineNumber": 215,
            "isSignature": true
          },
          {
            "text": "    # returns the number of unnamed worlds in the project",
            "lineNumber": 216,
            "isSignature": true
          },
          {
            "lineNumber": 217
          },
          {
            "text": "    ",
            "lineNumber": 218,
            "isSignature": true
          }
        ]
      },
      "score": 0.28908661007881165
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\count.py",
        "range": {
          "startPosition": {
            "line": 184,
            "column": 16
          },
          "endPosition": {
            "line": 196,
            "column": 4
          }
        },
        "contents": "def textures_unused():\n    # returns the number of unused textures in the project\n\n    return len(unused.textures_shallow())\n\n\ndef textures_unnamed():\n    # returns the number of unnamed textures in the project\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def textures_unused():",
            "lineNumber": 188,
            "isSignature": true
          },
          {
            "text": "    # returns the number of unused textures in the project",
            "lineNumber": 189,
            "isSignature": true
          },
          {
            "lineNumber": 190
          },
          {
            "text": "    return len(unused.textures_shallow())",
            "lineNumber": 191,
            "isSignature": true
          },
          {
            "lineNumber": 192
          },
          {
            "lineNumber": 193
          },
          {
            "text": "def textures_unnamed():",
            "lineNumber": 194,
            "isSignature": true
          },
          {
            "text": "    # returns the number of unnamed textures in the project",
            "lineNumber": 195,
            "isSignature": true
          },
          {
            "lineNumber": 196
          },
          {
            "text": "    ",
            "lineNumber": 197,
            "isSignature": true
          }
        ]
      },
      "score": 0.286591500043869
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


Creating optimized short-circuit versions that return as soon as any unused data is found:


---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\stats\\unused_parallel.py"
}
```
Additional data:

```json
{
  "codeblockId": "031eb012-c011-4858-a29c-b3dc854d4a28"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "stats/unused_parallel.py"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "stats/unused_parallel.py"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


Optimized Smart Select to use short-circuit checks. Instead of computing full unused lists, it:

1. **Stops early** — returns `True` as soon as it finds one unused item in each category
2. **Skips full computation** — doesn't build lists of all unused items
3. **Uses the same logic** — same checks as the deep functions, just with early exit

This should be faster, especially when unused items appear early. The worst case (all items used) still checks everything, but the common case should be much faster.

The optimization:
- **Before**: Checked ALL items → built full list → converted to bool
- **Now**: Check items one by one → return `True` immediately when finding unused → only check all if none are unused

This should reduce Smart Select from ~30 seconds to a few seconds in typical cases.

---

_**User**_

material outline-highlight is being detected as not used, despite the fact it's used in a geonode group's 'set material' node.

---

_**Agent (model default, mode Agent)**_


The material is used via a Geometry Nodes "Set Material" node, but it's being flagged as unused. Checking how `material_all()` detects material usage:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "material_all|material_geometry_nodes|node_group_has_material",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "material_all|material_geometry_nodes|node_group_has_material",
    "outputMode": "content",
    "workspaceResults": {
      "e:\\atomic_data_manager": {
        "content": {
          "matches": [
            {
              "file": "stats\\unused_parallel.py",
              "matches": [
                {
                  "lineNumber": 102,
                  "content": "        if not users.material_all(material.name):"
                }
              ]
            },
            {
              "file": "stats/unused.py",
              "matches": [
                {
                  "lineNumber": 163,
                  "content": "        if not users.material_all(material.name):"
                }
              ]
            },
            {
              "file": "stats/users.py",
              "matches": [
                {
                  "lineNumber": 427,
                  "content": "def material_all(material_key):"
                },
                {
                  "lineNumber": 430,
                  "content": "           material_geometry_nodes(material_key)"
                },
                {
                  "lineNumber": 433,
                  "content": "def material_geometry_nodes(material_key):"
                },
                {
                  "lineNumber": 448,
                  "content": "                        if node_group_has_material(ng.name, material.name):"
                },
                {
                  "lineNumber": 759,
                  "content": "def node_group_has_material(node_group_key, material_key):"
                },
                {
                  "lineNumber": 774,
                  "content": "            has_material = node_group_has_material("
                }
              ]
            },
            {
              "file": ".specstory/history/2025-12-16_23-24Z-blender-library-packed-files-error.md",
              "matches": [
                {
                  "lineNumber": 8855,
                  "content": "        \"contents\": \"def node_group_has_material(node_group_key, material_key):\\n    # returns true if a node group contains this material (directly or nested)\\n\\n    has_material = False\\n    node_group = bpy.data.node_groups[node_group_key]\\n    material = bpy.data.materials[material_key]\\n\\n    for node in node_group.nodes:\\n        # base case: nodes with a material property (e.g., Set Material)\\n        if hasattr(node, 'material') and node.material:\\n            if node.material.name == material.name:\\n                has_material = True\\n\\n        # recurse case: nested node groups\\n        elif hasattr(node, 'node_tree') and node.node_tree:\\n            has_material = node_group_has_material(\\n                node.node_tree.name, material.name)\\n\\n        if has_material:\\n            break\\n\\n    return has_material\\n\\n\\ndef particle_all(particle_key):\\n    # returns a list of keys of every data-block that uses this particle\\n    # system\\n\\n    \","
                },
                {
                  "lineNumber": 8859,
                  "content": "            \"text\": \"def node_group_has_material(node_group_key, material_key):\","
                },
                {
                  "lineNumber": 8918,
                  "content": "            \"text\": \"            has_material = node_group_has_material(\","
                },
                {
                  "lineNumber": 11372,
                  "content": "        \"contents\": \"def node_group_has_texture(node_group_key, texture_key):\\n    # returns true if a node group contains this image\\n\\n    has_texture = False\\n    if not hasattr(bpy.data, 'textures'):\\n        return has_texture\\n    node_group = bpy.data.node_groups[node_group_key]\\n    texture = bpy.data.textures[texture_key]\\n\\n    # for each node in our search group\\n    for node in node_group.nodes:\\n\\n        # base case\\n        # if node has a not none image attribute\\n        if hasattr(node, 'texture') and node.texture:\\n\\n            # if the node group is our node group\\n            if node.texture.name == texture.name:\\n                has_texture = True\\n\\n        # recurse case\\n        # if node is a node group and has a valid node tree\\n        elif hasattr(node, 'node_tree') and node.node_tree:\\n            has_texture = node_group_has_texture(\\n                node.node_tree.name, texture.name)\\n\\n        # break the loop if the texture is found\\n        if has_te"
                },
                {
                  "lineNumber": 11502,
                  "content": "            \"text\": \"def node_group_has_material(node_group_key, material_key):\","
                }
              ]
            }
          ],
          "totalLines": 13,
          "totalMatchedLines": 13
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---


The issue: `material_all()` only checks materials in Geometry Nodes modifiers on objects, not materials used in node groups that are referenced elsewhere. Checking how node groups are detected as used:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---


The issue: `material_all()` only checks materials in Geometry Nodes modifiers on objects. It should also check materials used in node groups that are referenced elsewhere (materials, other node groups, etc.). Adding that check:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---


Adding a check for materials used in node groups that are referenced elsewhere (not just Geometry Nodes modifiers on objects):


---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\stats\\users.py"
}
```
Additional data:

```json
{
  "codeblockId": "cc51ed80-e36c-4780-a63f-8946cb35ff96"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\stats\\users.py"
}
```
Additional data:

```json
{
  "codeblockId": "85865630-1e6c-462d-abe9-1b8004abff25"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "stats/users.py"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "stats/users.py"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


Added `material_node_groups()` to detect materials used in node groups that are referenced elsewhere. This covers cases like "outline-highlight" used in the "box-highlight" node group.

The fix:
1. Checks all node groups for the material (via `node_group_has_material()`)
2. If found, checks if that node group is used anywhere (via `node_group_all()`)
3. If the node group is used, the material is considered used

This should correctly identify "outline-highlight" as used since it's in "box-highlight", which is used by objects.

The material should no longer be flagged as unused. Test it and let me know if it works.

---

_**User**_

it still detects it as not used. bpy.ops.atomic.clean() also takes at least 30 seconds to perform.

---

_**Agent (model default, mode Agent)**_


Investigating both issues. Checking how the clean operation works and verifying the material detection logic:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\ops\utils\clean.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "How does the clean operation detect and remove unused materials?",
  "includePattern": "ops",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 593,
            "column": 43
          },
          "endPosition": {
            "line": 657
          }
        },
        "contents": "# Atomic Data Manager Clean Materials Operator\nclass ATOMIC_OT_clean_materials(bpy.types.Operator):\n    \"\"\"Remove all unused materials from this project\"\"\"\n    bl_idname = \"atomic.clean_materials\"\n    bl_label = \"Clean Materials\"\n\n    unused_materials = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_materials,\n            icon=\"MATERIAL\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.materials()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_materials = unused.materials_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Node Groups Operator\nclass ATOMIC_OT_clean_node_groups(bpy.types.Operator):\n    \"\"\"Remove all unused node groups from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Materials Operator",
            "lineNumber": 597
          },
          {
            "text": "class ATOMIC_OT_clean_materials(bpy.types.Operator):",
            "lineNumber": 598,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused materials from this project\"\"\"",
            "lineNumber": 599
          },
          {
            "text": "    bl_idname = \"atomic.clean_materials\"",
            "lineNumber": 600
          },
          {
            "text": "    bl_label = \"Clean Materials\"",
            "lineNumber": 601
          },
          {
            "lineNumber": 602
          },
          {
            "text": "    unused_materials = []",
            "lineNumber": 603
          },
          {
            "lineNumber": 604
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 605
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 606
          },
          {
            "lineNumber": 607
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 608
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 609
          },
          {
            "lineNumber": 610
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 611
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 612
          },
          {
            "text": "            items=self.unused_materials,",
            "lineNumber": 613
          },
          {
            "text": "            icon=\"MATERIAL\"",
            "lineNumber": 614
          },
          {
            "text": "        )",
            "lineNumber": 615
          },
          {
            "lineNumber": 616
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 617
          },
          {
            "lineNumber": 618
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 619
          },
          {
            "text": "        clean.materials()",
            "lineNumber": 620
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 621
          },
          {
            "lineNumber": 622
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 623
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 624
          },
          {
            "text": "        self.unused_materials = unused.materials_deep()",
            "lineNumber": 625
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 626,
            "isSignature": true
          },
          {
            "lineNumber": 627
          },
          {
            "lineNumber": 628
          },
          {
            "text": "# Atomic Data Manager Clean Node Groups Operator",
            "lineNumber": 629
          },
          {
            "text": "class ATOMIC_OT_clean_node_groups(bpy.types.Operator):",
            "lineNumber": 630,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused node groups from this project\"\"\"",
            "lineNumber": 631
          }
        ]
      },
      "score": 0.4800240397453308
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {
            "line": 193
          },
          "endPosition": {
            "line": 370
          }
        },
        "contents": "class ATOMIC_OT_clean(bpy.types.Operator):\n\n\n    def execute(self, context):\n        atom = bpy.context.scene.atomic\n\n        if atom.collections:\n            clean.collections()\n\n        if atom.images:\n            clean.images()\n\n        if atom.lights:\n            clean.lights()\n\n        if atom.materials:\n            clean.materials()\n\n        if atom.node_groups:\n            clean.node_groups()\n\n        if atom.particles:\n            clean.particles()\n\n        if atom.textures:\n            clean.textures()\n\n        if atom.worlds:\n            clean.worlds()\n\n        bpy.ops.atomic.deselect_all()\n\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        atom = bpy.context.scene.atomic\n\n        # Use parallel execution for better performance\n        all_unused = unused_parallel.get_all_unused_parallel()\n\n        if atom.collections:\n            self.unused_collections = all_unused['collections']\n\n        if atom.images:\n            self.unused_images = all_unused['images']\n\n        if atom.lights:\n            self.unused_lights = all_unused['lights']\n\n        if atom.materials:\n            self.unused_materials = all_unused['materials']\n\n        if atom.node_groups:\n            self.unused_node_groups = all_unused['node_groups']\n\n        if atom.particles:\n            self.unused_particles = all_unused['particles']\n\n        if atom.textures:\n            self.unused_textures = all_unused['textures']\n\n        if atom.worlds:\n            self.unused_worlds = all_unused['worlds']\n\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Undo Operator\nclass ATOMIC_OT_undo(bpy.types.Operator):\n    \"\"\"Undo the previous action\"\"\"",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 194,
                "column": 1
              },
              "endPosition": {
                "line": 195,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_OT_clean(bpy.types.Operator):",
            "lineNumber": 194,
            "isSignature": true
          },
          {
            "lineNumber": 296
          },
          {
            "lineNumber": 297
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 298
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 299
          },
          {
            "lineNumber": 300
          },
          {
            "text": "        if atom.collections:",
            "lineNumber": 301
          },
          {
            "text": "            clean.collections()",
            "lineNumber": 302
          },
          {
            "lineNumber": 303
          },
          {
            "text": "        if atom.images:",
            "lineNumber": 304
          },
          {
            "text": "            clean.images()",
            "lineNumber": 305
          },
          {
            "lineNumber": 306
          },
          {
            "text": "        if atom.lights:",
            "lineNumber": 307
          },
          {
            "text": "            clean.lights()",
            "lineNumber": 308
          },
          {
            "lineNumber": 309
          },
          {
            "text": "        if atom.materials:",
            "lineNumber": 310
          },
          {
            "text": "            clean.materials()",
            "lineNumber": 311
          },
          {
            "lineNumber": 312
          },
          {
            "text": "        if atom.node_groups:",
            "lineNumber": 313
          },
          {
            "text": "            clean.node_groups()",
            "lineNumber": 314
          },
          {
            "lineNumber": 315
          },
          {
            "text": "        if atom.particles:",
            "lineNumber": 316
          },
          {
            "text": "            clean.particles()",
            "lineNumber": 317
          },
          {
            "lineNumber": 318
          },
          {
            "text": "        if atom.textures:",
            "lineNumber": 319
          },
          {
            "text": "            clean.textures()",
            "lineNumber": 320
          },
          {
            "lineNumber": 321
          },
          {
            "text": "        if atom.worlds:",
            "lineNumber": 322
          },
          {
            "text": "            clean.worlds()",
            "lineNumber": 323
          },
          {
            "lineNumber": 324
          },
          {
            "text": "        bpy.ops.atomic.deselect_all()",
            "lineNumber": 325
          },
          {
            "lineNumber": 326
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 327
          },
          {
            "lineNumber": 328
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 329
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 330
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 331
          },
          {
            "lineNumber": 332
          },
          {
            "text": "        # Use parallel execution for better performance",
            "lineNumber": 333
          },
          {
            "text": "        all_unused = unused_parallel.get_all_unused_parallel()",
            "lineNumber": 334
          },
          {
            "lineNumber": 335
          },
          {
            "text": "        if atom.collections:",
            "lineNumber": 336
          },
          {
            "text": "            self.unused_collections = all_unused['collections']",
            "lineNumber": 337
          },
          {
            "lineNumber": 338
          },
          {
            "text": "        if atom.images:",
            "lineNumber": 339
          },
          {
            "text": "            self.unused_images = all_unused['images']",
            "lineNumber": 340
          },
          {
            "lineNumber": 341
          },
          {
            "text": "        if atom.lights:",
            "lineNumber": 342
          },
          {
            "text": "            self.unused_lights = all_unused['lights']",
            "lineNumber": 343
          },
          {
            "lineNumber": 344
          },
          {
            "text": "        if atom.materials:",
            "lineNumber": 345
          },
          {
            "text": "            self.unused_materials = all_unused['materials']",
            "lineNumber": 346
          },
          {
            "lineNumber": 347
          },
          {
            "text": "        if atom.node_groups:",
            "lineNumber": 348
          },
          {
            "text": "            self.unused_node_groups = all_unused['node_groups']",
            "lineNumber": 349
          },
          {
            "lineNumber": 350
          },
          {
            "text": "        if atom.particles:",
            "lineNumber": 351
          },
          {
            "text": "            self.unused_particles = all_unused['particles']",
            "lineNumber": 352
          },
          {
            "lineNumber": 353
          },
          {
            "text": "        if atom.textures:",
            "lineNumber": 354
          },
          {
            "text": "            self.unused_textures = all_unused['textures']",
            "lineNumber": 355
          },
          {
            "lineNumber": 356
          },
          {
            "text": "        if atom.worlds:",
            "lineNumber": 357
          },
          {
            "text": "            self.unused_worlds = all_unused['worlds']",
            "lineNumber": 358
          },
          {
            "lineNumber": 359
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 360,
            "isSignature": true
          },
          {
            "lineNumber": 361
          },
          {
            "lineNumber": 362
          },
          {
            "text": "# Atomic Data Manager Undo Operator",
            "lineNumber": 363
          },
          {
            "text": "class ATOMIC_OT_undo(bpy.types.Operator):",
            "lineNumber": 364,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Undo the previous action\"\"\"",
            "lineNumber": 365
          }
        ]
      },
      "score": 0.47574383020401
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\utils\\clean.py",
        "range": {
          "startPosition": {
            "line": 43,
            "column": 58
          },
          "endPosition": {
            "line": 55
          }
        },
        "contents": "def materials():\n    # removes all unused materials from the project\n    for light_key in unused.materials_deep():\n        bpy.data.materials.remove(bpy.data.materials[light_key])\n\n\ndef node_groups():\n    # removes all unused node groups from the project\n    for",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def materials():",
            "lineNumber": 47,
            "isSignature": true
          },
          {
            "text": "    # removes all unused materials from the project",
            "lineNumber": 48,
            "isSignature": true
          },
          {
            "text": "    for light_key in unused.materials_deep():",
            "lineNumber": 49
          },
          {
            "text": "        bpy.data.materials.remove(bpy.data.materials[light_key])",
            "lineNumber": 50,
            "isSignature": true
          },
          {
            "lineNumber": 51
          },
          {
            "lineNumber": 52
          },
          {
            "text": "def node_groups():",
            "lineNumber": 53,
            "isSignature": true
          },
          {
            "text": "    # removes all unused node groups from the project",
            "lineNumber": 54,
            "isSignature": true
          },
          {
            "text": "    for",
            "lineNumber": 55
          }
        ]
      },
      "score": 0.45256349444389343
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {
            "line": 189,
            "column": 43
          },
          "endPosition": {
            "line": 359
          }
        },
        "contents": "# Atomic Data Manager Clean Operator\nclass ATOMIC_OT_clean(bpy.types.Operator):\n    \"\"\"Remove all unused data-blocks from the selected categories\"\"\"\n    bl_idname = \"atomic.clean\"\n    bl_label = \"Clean\"\n\n    unused_collections = []\n    unused_images = []\n    unused_lights = []\n    unused_materials = []\n    unused_node_groups = []\n    unused_particles = []\n    unused_textures = []\n    unused_worlds = []\n\n    def draw(self, context):\n        atom = bpy.context.scene.atomic\n        layout = self.layout\n\n        col = layout.column()\n        col.label(text=\"Remove the following data-blocks?\")\n\n        # display if no main panel properties are toggled\n        if not (atom.collections or atom.images or atom.lights or\n                atom.materials or atom.node_groups or atom.particles\n                or atom.textures or atom.worlds):\n\n            ui_layouts.box_list(\n                layout=layout,\n            )\n\n        # display when the main panel collections property is toggled\n        if atom.collections:\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Collections\",\n                items=self.unused_collections,\n                icon=\"OUTLINER_OB_GROUP_INSTANCE\"\n            )\n\n        # display when the main panel images property is toggled\n        if atom.images:\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Images\",\n                items=self.unused_images,\n                icon=\"IMAGE_DATA\"\n            )\n\n        # display when the main panel lights property is toggled\n        if atom.lights:\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Lights\",\n                items=self.unused_lights,\n                icon=\"OUTLINER_OB_LIGHT\"\n            )\n\n        # display when the main panel materials property is toggled\n        if",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Operator",
            "lineNumber": 193
          },
          {
            "text": "class ATOMIC_OT_clean(bpy.types.Operator):",
            "lineNumber": 194,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused data-blocks from the selected categories\"\"\"",
            "lineNumber": 195
          },
          {
            "text": "    bl_idname = \"atomic.clean\"",
            "lineNumber": 196
          },
          {
            "text": "    bl_label = \"Clean\"",
            "lineNumber": 197
          },
          {
            "lineNumber": 198
          },
          {
            "text": "    unused_collections = []",
            "lineNumber": 199
          },
          {
            "text": "    unused_images = []",
            "lineNumber": 200
          },
          {
            "text": "    unused_lights = []",
            "lineNumber": 201
          },
          {
            "text": "    unused_materials = []",
            "lineNumber": 202
          },
          {
            "text": "    unused_node_groups = []",
            "lineNumber": 203
          },
          {
            "text": "    unused_particles = []",
            "lineNumber": 204
          },
          {
            "text": "    unused_textures = []",
            "lineNumber": 205
          },
          {
            "text": "    unused_worlds = []",
            "lineNumber": 206
          },
          {
            "lineNumber": 207
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 208
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 209
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 210
          },
          {
            "lineNumber": 211
          },
          {
            "text": "        col = layout.column()",
            "lineNumber": 212
          },
          {
            "text": "        col.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 213
          },
          {
            "lineNumber": 214
          },
          {
            "text": "        # display if no main panel properties are toggled",
            "lineNumber": 215
          },
          {
            "text": "        if not (atom.collections or atom.images or atom.lights or",
            "lineNumber": 216
          },
          {
            "text": "                atom.materials or atom.node_groups or atom.particles",
            "lineNumber": 217
          },
          {
            "text": "                or atom.textures or atom.worlds):",
            "lineNumber": 218
          },
          {
            "lineNumber": 219
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 220
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 221
          },
          {
            "text": "            )",
            "lineNumber": 222
          },
          {
            "lineNumber": 223
          },
          {
            "text": "        # display when the main panel collections property is toggled",
            "lineNumber": 224
          },
          {
            "text": "        if atom.collections:",
            "lineNumber": 225
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 226
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 227
          },
          {
            "text": "                title=\"Collections\",",
            "lineNumber": 228
          },
          {
            "text": "                items=self.unused_collections,",
            "lineNumber": 229
          },
          {
            "text": "                icon=\"OUTLINER_OB_GROUP_INSTANCE\"",
            "lineNumber": 230
          },
          {
            "text": "            )",
            "lineNumber": 231
          },
          {
            "lineNumber": 232
          },
          {
            "text": "        # display when the main panel images property is toggled",
            "lineNumber": 233
          },
          {
            "text": "        if atom.images:",
            "lineNumber": 234
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 235
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 236
          },
          {
            "text": "                title=\"Images\",",
            "lineNumber": 237
          },
          {
            "text": "                items=self.unused_images,",
            "lineNumber": 238
          },
          {
            "text": "                icon=\"IMAGE_DATA\"",
            "lineNumber": 239
          },
          {
            "text": "            )",
            "lineNumber": 240
          },
          {
            "lineNumber": 241
          },
          {
            "text": "        # display when the main panel lights property is toggled",
            "lineNumber": 242
          },
          {
            "text": "        if atom.lights:",
            "lineNumber": 243
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 244
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 245
          },
          {
            "text": "                title=\"Lights\",",
            "lineNumber": 246
          },
          {
            "text": "                items=self.unused_lights,",
            "lineNumber": 247
          },
          {
            "text": "                icon=\"OUTLINER_OB_LIGHT\"",
            "lineNumber": 248
          },
          {
            "text": "            )",
            "lineNumber": 249
          },
          {
            "lineNumber": 250
          },
          {
            "text": "        # display when the main panel materials property is toggled",
            "lineNumber": 251
          },
          {
            "text": "        if",
            "lineNumber": 252
          }
        ]
      },
      "score": 0.438271701335907
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 150
          },
          "endPosition": {
            "line": 287
          }
        },
        "contents": "class ATOMIC_OT_clean_all(bpy.types.Operator):\ndef draw(self, context):\n\n            icon=\"TEXTURE\"\n        )\n\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Worlds\",\n            items=sorted(self.unused_worlds),\n            icon=\"WORLD\"\n        )\n\n        row = layout.row()  # extra spacing\n\n    def execute(self, context):\n\n        clean.collections()\n        clean.images()\n        clean.lights()\n        clean.materials()\n        clean.node_groups()\n        clean.particles()\n        clean.textures()\n        clean.worlds()\n\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n\n        # Use parallel execution for better performance\n        all_unused = unused_parallel.get_all_unused_parallel()\n        \n        self.unused_collections = all_unused['collections']\n        self.unused_images = all_unused['images']\n        self.unused_lights = all_unused['lights']\n        self.unused_materials = all_unused['materials']\n        self.unused_node_groups = all_unused['node_groups']\n        self.unused_particles = all_unused['particles']\n        self.unused_textures = all_unused['textures']\n        self.unused_worlds = all_unused['worlds']\n\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Nuke Collections Operator\nclass ATOMIC_OT_nuke_collections(bpy.types.Operator):\n    \"\"\"Remove all collections from this project\"\"\"",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 151,
                "column": 1
              },
              "endPosition": {
                "line": 152,
                "column": 5
              }
            },
            {
              "startPosition": {
                "line": 165,
                "column": 5
              },
              "endPosition": {
                "line": 166,
                "column": 9
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_OT_clean_all(bpy.types.Operator):",
            "lineNumber": 151,
            "isSignature": true
          },
          {
            "text": "def draw(self, context):",
            "lineNumber": 165
          },
          {
            "lineNumber": 217
          },
          {
            "text": "            icon=\"TEXTURE\"",
            "lineNumber": 218
          },
          {
            "text": "        )",
            "lineNumber": 219
          },
          {
            "lineNumber": 220
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 221
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 222
          },
          {
            "text": "            title=\"Worlds\",",
            "lineNumber": 223
          },
          {
            "text": "            items=sorted(self.unused_worlds),",
            "lineNumber": 224
          },
          {
            "text": "            icon=\"WORLD\"",
            "lineNumber": 225
          },
          {
            "text": "        )",
            "lineNumber": 226
          },
          {
            "lineNumber": 227
          },
          {
            "text": "        row = layout.row()  # extra spacing",
            "lineNumber": 228
          },
          {
            "lineNumber": 229
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 230
          },
          {
            "lineNumber": 231
          },
          {
            "text": "        clean.collections()",
            "lineNumber": 232
          },
          {
            "text": "        clean.images()",
            "lineNumber": 233
          },
          {
            "text": "        clean.lights()",
            "lineNumber": 234
          },
          {
            "text": "        clean.materials()",
            "lineNumber": 235
          },
          {
            "text": "        clean.node_groups()",
            "lineNumber": 236
          },
          {
            "text": "        clean.particles()",
            "lineNumber": 237
          },
          {
            "text": "        clean.textures()",
            "lineNumber": 238
          },
          {
            "text": "        clean.worlds()",
            "lineNumber": 239
          },
          {
            "lineNumber": 240
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 241
          },
          {
            "lineNumber": 242
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 243
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 244
          },
          {
            "lineNumber": 245
          },
          {
            "text": "        # Use parallel execution for better performance",
            "lineNumber": 246
          },
          {
            "text": "        all_unused = unused_parallel.get_all_unused_parallel()",
            "lineNumber": 247
          },
          {
            "text": "        ",
            "lineNumber": 248
          },
          {
            "text": "        self.unused_collections = all_unused['collections']",
            "lineNumber": 249
          },
          {
            "text": "        self.unused_images = all_unused['images']",
            "lineNumber": 250
          },
          {
            "text": "        self.unused_lights = all_unused['lights']",
            "lineNumber": 251
          },
          {
            "text": "        self.unused_materials = all_unused['materials']",
            "lineNumber": 252
          },
          {
            "text": "        self.unused_node_groups = all_unused['node_groups']",
            "lineNumber": 253
          },
          {
            "text": "        self.unused_particles = all_unused['particles']",
            "lineNumber": 254
          },
          {
            "text": "        self.unused_textures = all_unused['textures']",
            "lineNumber": 255
          },
          {
            "text": "        self.unused_worlds = all_unused['worlds']",
            "lineNumber": 256
          },
          {
            "lineNumber": 257
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 258,
            "isSignature": true
          },
          {
            "lineNumber": 259
          },
          {
            "lineNumber": 260
          },
          {
            "text": "# Atomic Data Manager Nuke Collections Operator",
            "lineNumber": 261
          },
          {
            "text": "class ATOMIC_OT_nuke_collections(bpy.types.Operator):",
            "lineNumber": 262,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all collections from this project\"\"\"",
            "lineNumber": 263
          }
        ]
      },
      "score": 0.4332900047302246
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 146,
            "column": 43
          },
          "endPosition": {
            "line": 257
          }
        },
        "contents": "# Atomic Data Manager Clean All Operator\nclass ATOMIC_OT_clean_all(bpy.types.Operator):\n    \"\"\"Remove all unused data-blocks from the selected categories\"\"\"\n    bl_idname = \"atomic.clean_all\"\n    bl_label = \"Clean All\"\n\n    unused_collections = []\n    unused_images = []\n    unused_lights = []\n    unused_materials = []\n    unused_node_groups = []\n    unused_particles = []\n    unused_textures = []\n    unused_worlds = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        col = layout.column()\n        col.label(text=\"Remove the following data-blocks?\")\n\n        # Use cached values from invoke() instead of recalculating\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Collections\",\n            items=sorted(self.unused_collections),\n            icon=\"OUTLINER_OB_GROUP_INSTANCE\"\n        )\n\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Images\",\n            items=sorted(self.unused_images),\n            icon=\"IMAGE_DATA\"\n        )\n\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Lights\",\n            items=sorted(self.unused_lights),\n            icon=\"OUTLINER_OB_LIGHT\"\n        )\n\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Materials\",\n            items=sorted(self.unused_materials),\n            icon=\"MATERIAL\"\n        )\n\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Node Groups\",\n            items=sorted(self.unused_node_groups),\n            icon=\"NODETREE\"\n        )\n\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Particle Systems\",\n            items=sorted(self.unused_particles),\n            icon=\"PARTICLES\"\n        )\n\n        ui_layouts.box_list(\n            layout=layout,\n            title=\"Textures\",\n            items=sorted(self.unused_textures),\n            icon=\"TEXTURE\"\n        )\n\n        ui_layouts.box_list",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean All Operator",
            "lineNumber": 150
          },
          {
            "text": "class ATOMIC_OT_clean_all(bpy.types.Operator):",
            "lineNumber": 151,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused data-blocks from the selected categories\"\"\"",
            "lineNumber": 152
          },
          {
            "text": "    bl_idname = \"atomic.clean_all\"",
            "lineNumber": 153
          },
          {
            "text": "    bl_label = \"Clean All\"",
            "lineNumber": 154
          },
          {
            "lineNumber": 155
          },
          {
            "text": "    unused_collections = []",
            "lineNumber": 156
          },
          {
            "text": "    unused_images = []",
            "lineNumber": 157
          },
          {
            "text": "    unused_lights = []",
            "lineNumber": 158
          },
          {
            "text": "    unused_materials = []",
            "lineNumber": 159
          },
          {
            "text": "    unused_node_groups = []",
            "lineNumber": 160
          },
          {
            "text": "    unused_particles = []",
            "lineNumber": 161
          },
          {
            "text": "    unused_textures = []",
            "lineNumber": 162
          },
          {
            "text": "    unused_worlds = []",
            "lineNumber": 163
          },
          {
            "lineNumber": 164
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 165
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 166
          },
          {
            "lineNumber": 167
          },
          {
            "text": "        col = layout.column()",
            "lineNumber": 168
          },
          {
            "text": "        col.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 169
          },
          {
            "lineNumber": 170
          },
          {
            "text": "        # Use cached values from invoke() instead of recalculating",
            "lineNumber": 171
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 172
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 173
          },
          {
            "text": "            title=\"Collections\",",
            "lineNumber": 174
          },
          {
            "text": "            items=sorted(self.unused_collections),",
            "lineNumber": 175
          },
          {
            "text": "            icon=\"OUTLINER_OB_GROUP_INSTANCE\"",
            "lineNumber": 176
          },
          {
            "text": "        )",
            "lineNumber": 177
          },
          {
            "lineNumber": 178
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 179
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 180
          },
          {
            "text": "            title=\"Images\",",
            "lineNumber": 181
          },
          {
            "text": "            items=sorted(self.unused_images),",
            "lineNumber": 182
          },
          {
            "text": "            icon=\"IMAGE_DATA\"",
            "lineNumber": 183
          },
          {
            "text": "        )",
            "lineNumber": 184
          },
          {
            "lineNumber": 185
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 186
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 187
          },
          {
            "text": "            title=\"Lights\",",
            "lineNumber": 188
          },
          {
            "text": "            items=sorted(self.unused_lights),",
            "lineNumber": 189
          },
          {
            "text": "            icon=\"OUTLINER_OB_LIGHT\"",
            "lineNumber": 190
          },
          {
            "text": "        )",
            "lineNumber": 191
          },
          {
            "lineNumber": 192
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 193
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 194
          },
          {
            "text": "            title=\"Materials\",",
            "lineNumber": 195
          },
          {
            "text": "            items=sorted(self.unused_materials),",
            "lineNumber": 196
          },
          {
            "text": "            icon=\"MATERIAL\"",
            "lineNumber": 197
          },
          {
            "text": "        )",
            "lineNumber": 198
          },
          {
            "lineNumber": 199
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 200
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 201
          },
          {
            "text": "            title=\"Node Groups\",",
            "lineNumber": 202
          },
          {
            "text": "            items=sorted(self.unused_node_groups),",
            "lineNumber": 203
          },
          {
            "text": "            icon=\"NODETREE\"",
            "lineNumber": 204
          },
          {
            "text": "        )",
            "lineNumber": 205
          },
          {
            "lineNumber": 206
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 207
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 208
          },
          {
            "text": "            title=\"Particle Systems\",",
            "lineNumber": 209
          },
          {
            "text": "            items=sorted(self.unused_particles),",
            "lineNumber": 210
          },
          {
            "text": "            icon=\"PARTICLES\"",
            "lineNumber": 211
          },
          {
            "text": "        )",
            "lineNumber": 212
          },
          {
            "lineNumber": 213
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 214
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 215
          },
          {
            "text": "            title=\"Textures\",",
            "lineNumber": 216
          },
          {
            "text": "            items=sorted(self.unused_textures),",
            "lineNumber": 217
          },
          {
            "text": "            icon=\"TEXTURE\"",
            "lineNumber": 218
          },
          {
            "text": "        )",
            "lineNumber": 219
          },
          {
            "lineNumber": 220
          },
          {
            "text": "        ui_layouts.box_list",
            "lineNumber": 221
          }
        ]
      },
      "score": 0.4187518358230591
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 689,
            "column": 43
          },
          "endPosition": {
            "line": 753
          }
        },
        "contents": "# Atomic Data Manager Clean Textures Operator\nclass ATOMIC_OT_clean_textures(bpy.types.Operator):\n    \"\"\"Remove all unused textures from this project\"\"\"\n    bl_idname = \"atomic.clean_textures\"\n    bl_label = \"Clean Textures\"\n\n    unused_textures = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_textures,\n            icon=\"TEXTURE\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.textures()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_textures = unused.textures_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Worlds Operator\nclass ATOMIC_OT_clean_worlds(bpy.types.Operator):\n    \"\"\"Remove all unused worlds from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Textures Operator",
            "lineNumber": 693
          },
          {
            "text": "class ATOMIC_OT_clean_textures(bpy.types.Operator):",
            "lineNumber": 694,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused textures from this project\"\"\"",
            "lineNumber": 695
          },
          {
            "text": "    bl_idname = \"atomic.clean_textures\"",
            "lineNumber": 696
          },
          {
            "text": "    bl_label = \"Clean Textures\"",
            "lineNumber": 697
          },
          {
            "lineNumber": 698
          },
          {
            "text": "    unused_textures = []",
            "lineNumber": 699
          },
          {
            "lineNumber": 700
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 701
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 702
          },
          {
            "lineNumber": 703
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 704
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 705
          },
          {
            "lineNumber": 706
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 707
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 708
          },
          {
            "text": "            items=self.unused_textures,",
            "lineNumber": 709
          },
          {
            "text": "            icon=\"TEXTURE\"",
            "lineNumber": 710
          },
          {
            "text": "        )",
            "lineNumber": 711
          },
          {
            "lineNumber": 712
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 713
          },
          {
            "lineNumber": 714
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 715
          },
          {
            "text": "        clean.textures()",
            "lineNumber": 716
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 717
          },
          {
            "lineNumber": 718
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 719
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 720
          },
          {
            "text": "        self.unused_textures = unused.textures_deep()",
            "lineNumber": 721
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 722,
            "isSignature": true
          },
          {
            "lineNumber": 723
          },
          {
            "lineNumber": 724
          },
          {
            "text": "# Atomic Data Manager Clean Worlds Operator",
            "lineNumber": 725
          },
          {
            "text": "class ATOMIC_OT_clean_worlds(bpy.types.Operator):",
            "lineNumber": 726,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused worlds from this project\"\"\"",
            "lineNumber": 727
          }
        ]
      },
      "score": 0.3822121024131775
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 529,
            "column": 43
          },
          "endPosition": {
            "line": 593
          }
        },
        "contents": "# Atomic Data Manager Clean Images Operator\nclass ATOMIC_OT_clean_images(bpy.types.Operator):\n    \"\"\"Remove all unused images from this project\"\"\"\n    bl_idname = \"atomic.clean_images\"\n    bl_label = \"Clean Images\"\n\n    unused_images = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_images,\n            icon=\"IMAGE_DATA\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.images()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_images =unused.images_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Lights Operator\nclass ATOMIC_OT_clean_lights(bpy.types.Operator):\n    \"\"\"Remove all unused lights from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Images Operator",
            "lineNumber": 533
          },
          {
            "text": "class ATOMIC_OT_clean_images(bpy.types.Operator):",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused images from this project\"\"\"",
            "lineNumber": 535
          },
          {
            "text": "    bl_idname = \"atomic.clean_images\"",
            "lineNumber": 536
          },
          {
            "text": "    bl_label = \"Clean Images\"",
            "lineNumber": 537
          },
          {
            "lineNumber": 538
          },
          {
            "text": "    unused_images = []",
            "lineNumber": 539
          },
          {
            "lineNumber": 540
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 541
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 542
          },
          {
            "lineNumber": 543
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 544
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 545
          },
          {
            "lineNumber": 546
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 547
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 548
          },
          {
            "text": "            items=self.unused_images,",
            "lineNumber": 549
          },
          {
            "text": "            icon=\"IMAGE_DATA\"",
            "lineNumber": 550
          },
          {
            "text": "        )",
            "lineNumber": 551
          },
          {
            "lineNumber": 552
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 553
          },
          {
            "lineNumber": 554
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 555
          },
          {
            "text": "        clean.images()",
            "lineNumber": 556
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 557
          },
          {
            "lineNumber": 558
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 559
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 560
          },
          {
            "text": "        self.unused_images =unused.images_deep()",
            "lineNumber": 561
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 562,
            "isSignature": true
          },
          {
            "lineNumber": 563
          },
          {
            "lineNumber": 564
          },
          {
            "text": "# Atomic Data Manager Clean Lights Operator",
            "lineNumber": 565
          },
          {
            "text": "class ATOMIC_OT_clean_lights(bpy.types.Operator):",
            "lineNumber": 566,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused lights from this project\"\"\"",
            "lineNumber": 567
          }
        ]
      },
      "score": 0.37953174114227295
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 657,
            "column": 43
          },
          "endPosition": {
            "line": 721
          }
        },
        "contents": "# Atomic Data Manager Clean Particles Operator\nclass ATOMIC_OT_clean_particles(bpy.types.Operator):\n    \"\"\"Remove all unused particle systems from this project\"\"\"\n    bl_idname = \"atomic.clean_particles\"\n    bl_label = \"Clean Particles\"\n\n    unused_particles = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_particles,\n            icon=\"PARTICLES\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.particles()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_particles = unused.particles_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Textures Operator\nclass ATOMIC_OT_clean_textures(bpy.types.Operator):\n    \"\"\"Remove all unused textures from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Particles Operator",
            "lineNumber": 661
          },
          {
            "text": "class ATOMIC_OT_clean_particles(bpy.types.Operator):",
            "lineNumber": 662,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused particle systems from this project\"\"\"",
            "lineNumber": 663
          },
          {
            "text": "    bl_idname = \"atomic.clean_particles\"",
            "lineNumber": 664
          },
          {
            "text": "    bl_label = \"Clean Particles\"",
            "lineNumber": 665
          },
          {
            "lineNumber": 666
          },
          {
            "text": "    unused_particles = []",
            "lineNumber": 667
          },
          {
            "lineNumber": 668
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 669
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 670
          },
          {
            "lineNumber": 671
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 672
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 673
          },
          {
            "lineNumber": 674
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 675
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 676
          },
          {
            "text": "            items=self.unused_particles,",
            "lineNumber": 677
          },
          {
            "text": "            icon=\"PARTICLES\"",
            "lineNumber": 678
          },
          {
            "text": "        )",
            "lineNumber": 679
          },
          {
            "lineNumber": 680
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 681
          },
          {
            "lineNumber": 682
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 683
          },
          {
            "text": "        clean.particles()",
            "lineNumber": 684
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 685
          },
          {
            "lineNumber": 686
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 687
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 688
          },
          {
            "text": "        self.unused_particles = unused.particles_deep()",
            "lineNumber": 689
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 690,
            "isSignature": true
          },
          {
            "lineNumber": 691
          },
          {
            "lineNumber": 692
          },
          {
            "text": "# Atomic Data Manager Clean Textures Operator",
            "lineNumber": 693
          },
          {
            "text": "class ATOMIC_OT_clean_textures(bpy.types.Operator):",
            "lineNumber": 694,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused textures from this project\"\"\"",
            "lineNumber": 695
          }
        ]
      },
      "score": 0.3775024116039276
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\utils\\clean.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 37
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains functions for cleaning out specific data categories.\n\n\"\"\"\n\nimport bpy\nfrom ...stats import unused\n\n\ndef collections():\n    # removes all unused collections from the project\n    for collection_key in unused.collections_deep():\n        bpy.data.collections.remove(bpy.data.collections[collection_key])\n\n\ndef images():\n    # removes all unused images from the project\n    for",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains functions for cleaning out specific data categories.",
            "lineNumber": 21
          },
          {
            "lineNumber": 22
          },
          {
            "text": "\"\"\"",
            "lineNumber": 23
          },
          {
            "lineNumber": 24
          },
          {
            "text": "import bpy",
            "lineNumber": 25
          },
          {
            "text": "from ...stats import unused",
            "lineNumber": 26
          },
          {
            "lineNumber": 27
          },
          {
            "lineNumber": 28
          },
          {
            "text": "def collections():",
            "lineNumber": 29,
            "isSignature": true
          },
          {
            "text": "    # removes all unused collections from the project",
            "lineNumber": 30,
            "isSignature": true
          },
          {
            "text": "    for collection_key in unused.collections_deep():",
            "lineNumber": 31
          },
          {
            "text": "        bpy.data.collections.remove(bpy.data.collections[collection_key])",
            "lineNumber": 32,
            "isSignature": true
          },
          {
            "lineNumber": 33
          },
          {
            "lineNumber": 34
          },
          {
            "text": "def images():",
            "lineNumber": 35,
            "isSignature": true
          },
          {
            "text": "    # removes all unused images from the project",
            "lineNumber": 36,
            "isSignature": true
          },
          {
            "text": "    for",
            "lineNumber": 37
          }
        ]
      },
      "score": 0.36943820118904114
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 721,
            "column": 43
          },
          "endPosition": {
            "line": 759,
            "column": 23
          }
        },
        "contents": "# Atomic Data Manager Clean Worlds Operator\nclass ATOMIC_OT_clean_worlds(bpy.types.Operator):\n    \"\"\"Remove all unused worlds from this project\"\"\"\n    bl_idname = \"atomic.clean_worlds\"\n    bl_label = \"Clean Worlds\"\n\n    unused_worlds = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_worlds,\n            icon=\"WORLD\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.worlds()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_worlds = unused.worlds()\n        return wm.invoke_props_dialog(self)\n\n\nreg_list = [\n    ATOMIC_OT_invoke_pie_menu_ui,\n\n    ATOMIC_OT_nuke_all,",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Worlds Operator",
            "lineNumber": 725
          },
          {
            "text": "class ATOMIC_OT_clean_worlds(bpy.types.Operator):",
            "lineNumber": 726,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused worlds from this project\"\"\"",
            "lineNumber": 727
          },
          {
            "text": "    bl_idname = \"atomic.clean_worlds\"",
            "lineNumber": 728
          },
          {
            "text": "    bl_label = \"Clean Worlds\"",
            "lineNumber": 729
          },
          {
            "lineNumber": 730
          },
          {
            "text": "    unused_worlds = []",
            "lineNumber": 731
          },
          {
            "lineNumber": 732
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 733
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 734
          },
          {
            "lineNumber": 735
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 736
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 737
          },
          {
            "lineNumber": 738
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 739
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 740
          },
          {
            "text": "            items=self.unused_worlds,",
            "lineNumber": 741
          },
          {
            "text": "            icon=\"WORLD\"",
            "lineNumber": 742
          },
          {
            "text": "        )",
            "lineNumber": 743
          },
          {
            "lineNumber": 744
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 745
          },
          {
            "lineNumber": 746
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 747
          },
          {
            "text": "        clean.worlds()",
            "lineNumber": 748
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 749
          },
          {
            "lineNumber": 750
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 751
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 752
          },
          {
            "text": "        self.unused_worlds = unused.worlds()",
            "lineNumber": 753
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 754,
            "isSignature": true
          },
          {
            "lineNumber": 755
          },
          {
            "lineNumber": 756
          },
          {
            "text": "reg_list = [",
            "lineNumber": 757
          },
          {
            "text": "    ATOMIC_OT_invoke_pie_menu_ui,",
            "lineNumber": 758
          },
          {
            "lineNumber": 759
          },
          {
            "text": "    ATOMIC_OT_nuke_all,",
            "lineNumber": 760
          }
        ]
      },
      "score": 0.36205583810806274
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 497,
            "column": 43
          },
          "endPosition": {
            "line": 561
          }
        },
        "contents": "# Atomic Data Manager Clean Collections Operator\nclass ATOMIC_OT_clean_collections(bpy.types.Operator):\n    \"\"\"Remove all unused collections from this project\"\"\"\n    bl_idname = \"atomic.clean_collections\"\n    bl_label = \"Clean Collections\"\n\n    unused_collections = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_collections,\n            icon=\"OUTLINER_OB_GROUP_INSTANCE\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.collections()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_collections = unused.collections_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Images Operator\nclass ATOMIC_OT_clean_images(bpy.types.Operator):\n    \"\"\"Remove all unused images from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Collections Operator",
            "lineNumber": 501
          },
          {
            "text": "class ATOMIC_OT_clean_collections(bpy.types.Operator):",
            "lineNumber": 502,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused collections from this project\"\"\"",
            "lineNumber": 503
          },
          {
            "text": "    bl_idname = \"atomic.clean_collections\"",
            "lineNumber": 504
          },
          {
            "text": "    bl_label = \"Clean Collections\"",
            "lineNumber": 505
          },
          {
            "lineNumber": 506
          },
          {
            "text": "    unused_collections = []",
            "lineNumber": 507
          },
          {
            "lineNumber": 508
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 509
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 510
          },
          {
            "lineNumber": 511
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 512
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 513
          },
          {
            "lineNumber": 514
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 515
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 516
          },
          {
            "text": "            items=self.unused_collections,",
            "lineNumber": 517
          },
          {
            "text": "            icon=\"OUTLINER_OB_GROUP_INSTANCE\"",
            "lineNumber": 518
          },
          {
            "text": "        )",
            "lineNumber": 519
          },
          {
            "lineNumber": 520
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 521
          },
          {
            "lineNumber": 522
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 523
          },
          {
            "text": "        clean.collections()",
            "lineNumber": 524
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 525
          },
          {
            "lineNumber": 526
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 527
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 528
          },
          {
            "text": "        self.unused_collections = unused.collections_deep()",
            "lineNumber": 529
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 530,
            "isSignature": true
          },
          {
            "lineNumber": 531
          },
          {
            "lineNumber": 532
          },
          {
            "text": "# Atomic Data Manager Clean Images Operator",
            "lineNumber": 533
          },
          {
            "text": "class ATOMIC_OT_clean_images(bpy.types.Operator):",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused images from this project\"\"\"",
            "lineNumber": 535
          }
        ]
      },
      "score": 0.3577030897140503
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {
            "line": 370,
            "column": 27
          },
          "endPosition": {
            "line": 411
          }
        },
        "contents": "# Atomic Data Manager Smart Select Operator\nclass ATOMIC_OT_smart_select(bpy.types.Operator):\n    \"\"\"Auto-select categories with unused data\"\"\"\n    bl_idname = \"atomic.smart_select\"\n    bl_label = \"Smart Select\"\n\n    def execute(self, context):\n        # Use parallel execution for better performance\n        unused_flags = unused_parallel.get_unused_for_smart_select()\n        \n        atom = bpy.context.scene.atomic\n        atom.collections = unused_flags['collections']\n        atom.images = unused_flags['images']\n        atom.lights = unused_flags['lights']\n        atom.materials = unused_flags['materials']\n        atom.node_groups = unused_flags['node_groups']\n        atom.particles = unused_flags['particles']\n        atom.textures = unused_flags['textures']\n        atom.worlds = unused_flags['worlds']\n\n        return {'FINISHED'}\n\n\n# Atomic Data Manager Select All Operator\nclass ATOMIC_OT_select_all(bpy.types.Operator):\n    \"\"\"Select all categories\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Smart Select Operator",
            "lineNumber": 374
          },
          {
            "text": "class ATOMIC_OT_smart_select(bpy.types.Operator):",
            "lineNumber": 375,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Auto-select categories with unused data\"\"\"",
            "lineNumber": 376
          },
          {
            "text": "    bl_idname = \"atomic.smart_select\"",
            "lineNumber": 377
          },
          {
            "text": "    bl_label = \"Smart Select\"",
            "lineNumber": 378
          },
          {
            "lineNumber": 379
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 380
          },
          {
            "text": "        # Use parallel execution for better performance",
            "lineNumber": 381
          },
          {
            "text": "        unused_flags = unused_parallel.get_unused_for_smart_select()",
            "lineNumber": 382
          },
          {
            "text": "        ",
            "lineNumber": 383
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 384
          },
          {
            "text": "        atom.collections = unused_flags['collections']",
            "lineNumber": 385
          },
          {
            "text": "        atom.images = unused_flags['images']",
            "lineNumber": 386
          },
          {
            "text": "        atom.lights = unused_flags['lights']",
            "lineNumber": 387
          },
          {
            "text": "        atom.materials = unused_flags['materials']",
            "lineNumber": 388
          },
          {
            "text": "        atom.node_groups = unused_flags['node_groups']",
            "lineNumber": 389
          },
          {
            "text": "        atom.particles = unused_flags['particles']",
            "lineNumber": 390
          },
          {
            "text": "        atom.textures = unused_flags['textures']",
            "lineNumber": 391
          },
          {
            "text": "        atom.worlds = unused_flags['worlds']",
            "lineNumber": 392
          },
          {
            "lineNumber": 393
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 394,
            "isSignature": true
          },
          {
            "lineNumber": 395
          },
          {
            "lineNumber": 396
          },
          {
            "text": "# Atomic Data Manager Select All Operator",
            "lineNumber": 397
          },
          {
            "text": "class ATOMIC_OT_select_all(bpy.types.Operator):",
            "lineNumber": 398,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Select all categories\"\"\"",
            "lineNumber": 399
          }
        ]
      },
      "score": 0.3508028984069824
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 561,
            "column": 43
          },
          "endPosition": {
            "line": 625
          }
        },
        "contents": "# Atomic Data Manager Clean Lights Operator\nclass ATOMIC_OT_clean_lights(bpy.types.Operator):\n    \"\"\"Remove all unused lights from this project\"\"\"\n    bl_idname = \"atomic.clean_lights\"\n    bl_label = \"Clean Lights\"\n\n    unused_lights = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_lights,\n            icon=\"OUTLINER_OB_LIGHT\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.lights()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_lights = unused.lights_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Materials Operator\nclass ATOMIC_OT_clean_materials(bpy.types.Operator):\n    \"\"\"Remove all unused materials from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Lights Operator",
            "lineNumber": 565
          },
          {
            "text": "class ATOMIC_OT_clean_lights(bpy.types.Operator):",
            "lineNumber": 566,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused lights from this project\"\"\"",
            "lineNumber": 567
          },
          {
            "text": "    bl_idname = \"atomic.clean_lights\"",
            "lineNumber": 568
          },
          {
            "text": "    bl_label = \"Clean Lights\"",
            "lineNumber": 569
          },
          {
            "lineNumber": 570
          },
          {
            "text": "    unused_lights = []",
            "lineNumber": 571
          },
          {
            "lineNumber": 572
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 573
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 574
          },
          {
            "lineNumber": 575
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 576
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 577
          },
          {
            "lineNumber": 578
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 579
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 580
          },
          {
            "text": "            items=self.unused_lights,",
            "lineNumber": 581
          },
          {
            "text": "            icon=\"OUTLINER_OB_LIGHT\"",
            "lineNumber": 582
          },
          {
            "text": "        )",
            "lineNumber": 583
          },
          {
            "lineNumber": 584
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 585
          },
          {
            "lineNumber": 586
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 587
          },
          {
            "text": "        clean.lights()",
            "lineNumber": 588
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 589
          },
          {
            "lineNumber": 590
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 591
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 592
          },
          {
            "text": "        self.unused_lights = unused.lights_deep()",
            "lineNumber": 593
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 594,
            "isSignature": true
          },
          {
            "lineNumber": 595
          },
          {
            "lineNumber": 596
          },
          {
            "text": "# Atomic Data Manager Clean Materials Operator",
            "lineNumber": 597
          },
          {
            "text": "class ATOMIC_OT_clean_materials(bpy.types.Operator):",
            "lineNumber": 598,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused materials from this project\"\"\"",
            "lineNumber": 599
          }
        ]
      },
      "score": 0.3467698097229004
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {
            "line": 193
          },
          "endPosition": {
            "line": 359
          }
        },
        "contents": "class ATOMIC_OT_clean(bpy.types.Operator):\ndef draw(self, context):\n\n            )\n\n        # display when the main panel materials property is toggled\n        if atom.materials:\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Materials\",\n                items=self.unused_materials,\n                icon=\"MATERIAL\"\n            )\n\n        # display when the main panel node groups property is toggled\n        if atom.node_groups:\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Node Groups\",\n                items=self.unused_node_groups,\n                icon=\"NODETREE\"\n            )\n\n        # display when the main panel particle systems property is toggled\n        if atom.particles:\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Particle Systems\",\n                items=self.unused_particles,\n                icon=\"PARTICLES\"\n            )\n\n        # display when the main panel textures property is toggled\n        if atom.textures:\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Textures\",\n                items=self.unused_textures,\n                icon=\"TEXTURE\"\n            )\n\n        # display when the main panel worlds property is toggled\n        if atom.worlds:\n            ui_layouts.box_list(\n                layout=layout,\n                title=\"Worlds\",\n                items=self.unused_worlds,\n                icon=\"WORLD\"\n            )\n\n        row = layout.row()  # extra spacing\n\n    def execute(self, context):\n        atom = bpy.context.scene.atomic",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 194,
                "column": 1
              },
              "endPosition": {
                "line": 195,
                "column": 5
              }
            },
            {
              "startPosition": {
                "line": 208,
                "column": 5
              },
              "endPosition": {
                "line": 209,
                "column": 9
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_OT_clean(bpy.types.Operator):",
            "lineNumber": 194,
            "isSignature": true
          },
          {
            "text": "def draw(self, context):",
            "lineNumber": 208
          },
          {
            "lineNumber": 248
          },
          {
            "text": "            )",
            "lineNumber": 249
          },
          {
            "lineNumber": 250
          },
          {
            "text": "        # display when the main panel materials property is toggled",
            "lineNumber": 251
          },
          {
            "text": "        if atom.materials:",
            "lineNumber": 252
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 253
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 254
          },
          {
            "text": "                title=\"Materials\",",
            "lineNumber": 255
          },
          {
            "text": "                items=self.unused_materials,",
            "lineNumber": 256
          },
          {
            "text": "                icon=\"MATERIAL\"",
            "lineNumber": 257
          },
          {
            "text": "            )",
            "lineNumber": 258
          },
          {
            "lineNumber": 259
          },
          {
            "text": "        # display when the main panel node groups property is toggled",
            "lineNumber": 260
          },
          {
            "text": "        if atom.node_groups:",
            "lineNumber": 261
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 262
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 263
          },
          {
            "text": "                title=\"Node Groups\",",
            "lineNumber": 264
          },
          {
            "text": "                items=self.unused_node_groups,",
            "lineNumber": 265
          },
          {
            "text": "                icon=\"NODETREE\"",
            "lineNumber": 266
          },
          {
            "text": "            )",
            "lineNumber": 267
          },
          {
            "lineNumber": 268
          },
          {
            "text": "        # display when the main panel particle systems property is toggled",
            "lineNumber": 269
          },
          {
            "text": "        if atom.particles:",
            "lineNumber": 270
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 271
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 272
          },
          {
            "text": "                title=\"Particle Systems\",",
            "lineNumber": 273
          },
          {
            "text": "                items=self.unused_particles,",
            "lineNumber": 274
          },
          {
            "text": "                icon=\"PARTICLES\"",
            "lineNumber": 275
          },
          {
            "text": "            )",
            "lineNumber": 276
          },
          {
            "lineNumber": 277
          },
          {
            "text": "        # display when the main panel textures property is toggled",
            "lineNumber": 278
          },
          {
            "text": "        if atom.textures:",
            "lineNumber": 279
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 280
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 281
          },
          {
            "text": "                title=\"Textures\",",
            "lineNumber": 282
          },
          {
            "text": "                items=self.unused_textures,",
            "lineNumber": 283
          },
          {
            "text": "                icon=\"TEXTURE\"",
            "lineNumber": 284
          },
          {
            "text": "            )",
            "lineNumber": 285
          },
          {
            "lineNumber": 286
          },
          {
            "text": "        # display when the main panel worlds property is toggled",
            "lineNumber": 287
          },
          {
            "text": "        if atom.worlds:",
            "lineNumber": 288
          },
          {
            "text": "            ui_layouts.box_list(",
            "lineNumber": 289
          },
          {
            "text": "                layout=layout,",
            "lineNumber": 290
          },
          {
            "text": "                title=\"Worlds\",",
            "lineNumber": 291
          },
          {
            "text": "                items=self.unused_worlds,",
            "lineNumber": 292
          },
          {
            "text": "                icon=\"WORLD\"",
            "lineNumber": 293
          },
          {
            "text": "            )",
            "lineNumber": 294
          },
          {
            "lineNumber": 295
          },
          {
            "text": "        row = layout.row()  # extra spacing",
            "lineNumber": 296
          },
          {
            "lineNumber": 297
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 298
          },
          {
            "text": "        atom = bpy.context.scene.atomic",
            "lineNumber": 299
          }
        ]
      },
      "score": 0.32836246490478516
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 625,
            "column": 43
          },
          "endPosition": {
            "line": 689
          }
        },
        "contents": "# Atomic Data Manager Clean Node Groups Operator\nclass ATOMIC_OT_clean_node_groups(bpy.types.Operator):\n    \"\"\"Remove all unused node groups from this project\"\"\"\n    bl_idname = \"atomic.clean_node_groups\"\n    bl_label = \"Clean Node Groups\"\n\n    unused_node_groups = []\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        ui_layouts.box_list(\n            layout=layout,\n            items=self.unused_node_groups,\n            icon=\"NODETREE\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        clean.node_groups()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        self.unused_node_groups = unused.node_groups_deep()\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Clean Particles Operator\nclass ATOMIC_OT_clean_particles(bpy.types.Operator):\n    \"\"\"Remove all unused particle systems from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Clean Node Groups Operator",
            "lineNumber": 629
          },
          {
            "text": "class ATOMIC_OT_clean_node_groups(bpy.types.Operator):",
            "lineNumber": 630,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused node groups from this project\"\"\"",
            "lineNumber": 631
          },
          {
            "text": "    bl_idname = \"atomic.clean_node_groups\"",
            "lineNumber": 632
          },
          {
            "text": "    bl_label = \"Clean Node Groups\"",
            "lineNumber": 633
          },
          {
            "lineNumber": 634
          },
          {
            "text": "    unused_node_groups = []",
            "lineNumber": 635
          },
          {
            "lineNumber": 636
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 637
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 638
          },
          {
            "lineNumber": 639
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 640
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 641
          },
          {
            "lineNumber": 642
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 643
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 644
          },
          {
            "text": "            items=self.unused_node_groups,",
            "lineNumber": 645
          },
          {
            "text": "            icon=\"NODETREE\"",
            "lineNumber": 646
          },
          {
            "text": "        )",
            "lineNumber": 647
          },
          {
            "lineNumber": 648
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 649
          },
          {
            "lineNumber": 650
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 651
          },
          {
            "text": "        clean.node_groups()",
            "lineNumber": 652
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 653
          },
          {
            "lineNumber": 654
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 655
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 656
          },
          {
            "text": "        self.unused_node_groups = unused.node_groups_deep()",
            "lineNumber": 657
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 658,
            "isSignature": true
          },
          {
            "lineNumber": 659
          },
          {
            "lineNumber": 660
          },
          {
            "text": "# Atomic Data Manager Clean Particles Operator",
            "lineNumber": 661
          },
          {
            "text": "class ATOMIC_OT_clean_particles(bpy.types.Operator):",
            "lineNumber": 662,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all unused particle systems from this project\"\"\"",
            "lineNumber": 663
          }
        ]
      },
      "score": 0.3277449607849121
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\utils\\clean.py",
        "range": {
          "startPosition": {
            "line": 61,
            "column": 67
          },
          "endPosition": {
            "line": 73
          }
        },
        "contents": "def textures():\n    # removes all unused textures from the project\n    for texture_key in unused.textures_deep():\n        bpy.data.textures.remove(bpy.data.textures[texture_key])\n\n\ndef worlds():\n    # removes all unused worlds from the project\n    for",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def textures():",
            "lineNumber": 65,
            "isSignature": true
          },
          {
            "text": "    # removes all unused textures from the project",
            "lineNumber": 66,
            "isSignature": true
          },
          {
            "text": "    for texture_key in unused.textures_deep():",
            "lineNumber": 67
          },
          {
            "text": "        bpy.data.textures.remove(bpy.data.textures[texture_key])",
            "lineNumber": 68,
            "isSignature": true
          },
          {
            "lineNumber": 69
          },
          {
            "lineNumber": 70
          },
          {
            "text": "def worlds():",
            "lineNumber": 71,
            "isSignature": true
          },
          {
            "text": "    # removes all unused worlds from the project",
            "lineNumber": 72,
            "isSignature": true
          },
          {
            "text": "    for",
            "lineNumber": 73
          }
        ]
      },
      "score": 0.3223100006580353
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\utils\\clean.py",
        "range": {
          "startPosition": {
            "line": 67,
            "column": 64
          },
          "endPosition": {
            "line": 73,
            "column": 58
          }
        },
        "contents": "def worlds():\n    # removes all unused worlds from the project\n    for world_key in unused.worlds():\n        bpy.data.worlds.remove(bpy.data.worlds[world_key])",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def worlds():",
            "lineNumber": 71,
            "isSignature": true
          },
          {
            "text": "    # removes all unused worlds from the project",
            "lineNumber": 72,
            "isSignature": true
          },
          {
            "text": "    for world_key in unused.worlds():",
            "lineNumber": 73
          },
          {
            "text": "        bpy.data.worlds.remove(bpy.data.worlds[world_key])",
            "lineNumber": 74,
            "isSignature": true
          }
        ]
      },
      "score": 0.29689157009124756
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\utils\\clean.py",
        "range": {
          "startPosition": {
            "line": 55,
            "column": 73
          },
          "endPosition": {
            "line": 67
          }
        },
        "contents": "def particles():\n    # removes all unused particle systems from the project\n    for particle_key in unused.particles_deep():\n        bpy.data.particles.remove(bpy.data.particles[particle_key])\n\n\ndef textures():\n    # removes all unused textures from the project\n    for",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def particles():",
            "lineNumber": 59,
            "isSignature": true
          },
          {
            "text": "    # removes all unused particle systems from the project",
            "lineNumber": 60,
            "isSignature": true
          },
          {
            "text": "    for particle_key in unused.particles_deep():",
            "lineNumber": 61
          },
          {
            "text": "        bpy.data.particles.remove(bpy.data.particles[particle_key])",
            "lineNumber": 62,
            "isSignature": true
          },
          {
            "lineNumber": 63
          },
          {
            "lineNumber": 64
          },
          {
            "text": "def textures():",
            "lineNumber": 65,
            "isSignature": true
          },
          {
            "text": "    # removes all unused textures from the project",
            "lineNumber": 66,
            "isSignature": true
          },
          {
            "text": "    for",
            "lineNumber": 67
          }
        ]
      },
      "score": 0.29104259610176086
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\utils\\clean.py",
        "range": {
          "startPosition": {
            "line": 37,
            "column": 58
          },
          "endPosition": {
            "line": 49
          }
        },
        "contents": "def lights():\n    # removes all unused lights from the project\n    for light_key in unused.lights_deep():\n        bpy.data.lights.remove(bpy.data.lights[light_key])\n\n\ndef materials():\n    # removes all unused materials from the project\n    for",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def lights():",
            "lineNumber": 41,
            "isSignature": true
          },
          {
            "text": "    # removes all unused lights from the project",
            "lineNumber": 42,
            "isSignature": true
          },
          {
            "text": "    for light_key in unused.lights_deep():",
            "lineNumber": 43
          },
          {
            "text": "        bpy.data.lights.remove(bpy.data.lights[light_key])",
            "lineNumber": 44,
            "isSignature": true
          },
          {
            "lineNumber": 45
          },
          {
            "lineNumber": 46
          },
          {
            "text": "def materials():",
            "lineNumber": 47,
            "isSignature": true
          },
          {
            "text": "    # removes all unused materials from the project",
            "lineNumber": 48,
            "isSignature": true
          },
          {
            "text": "    for",
            "lineNumber": 49
          }
        ]
      },
      "score": 0.2897486090660095
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\utils\\clean.py",
        "range": {
          "startPosition": {
            "line": 31,
            "column": 73
          },
          "endPosition": {
            "line": 43
          }
        },
        "contents": "def images():\n    # removes all unused images from the project\n    for image_key in unused.images_deep():\n        bpy.data.images.remove(bpy.data.images[image_key])\n\n\ndef lights():\n    # removes all unused lights from the project\n    for",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def images():",
            "lineNumber": 35,
            "isSignature": true
          },
          {
            "text": "    # removes all unused images from the project",
            "lineNumber": 36,
            "isSignature": true
          },
          {
            "text": "    for image_key in unused.images_deep():",
            "lineNumber": 37
          },
          {
            "text": "        bpy.data.images.remove(bpy.data.images[image_key])",
            "lineNumber": 38,
            "isSignature": true
          },
          {
            "lineNumber": 39
          },
          {
            "lineNumber": 40
          },
          {
            "text": "def lights():",
            "lineNumber": 41,
            "isSignature": true
          },
          {
            "text": "    # removes all unused lights from the project",
            "lineNumber": 42,
            "isSignature": true
          },
          {
            "text": "    for",
            "lineNumber": 43
          }
        ]
      },
      "score": 0.28730809688568115
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\utils\\clean.py",
        "range": {
          "startPosition": {
            "line": 49,
            "column": 64
          },
          "endPosition": {
            "line": 61
          }
        },
        "contents": "def node_groups():\n    # removes all unused node groups from the project\n    for node_group_key in unused.node_groups_deep():\n        bpy.data.node_groups.remove(bpy.data.node_groups[node_group_key])\n\n\ndef particles():\n    # removes all unused particle systems from the project\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_groups():",
            "lineNumber": 53,
            "isSignature": true
          },
          {
            "text": "    # removes all unused node groups from the project",
            "lineNumber": 54,
            "isSignature": true
          },
          {
            "text": "    for node_group_key in unused.node_groups_deep():",
            "lineNumber": 55
          },
          {
            "text": "        bpy.data.node_groups.remove(bpy.data.node_groups[node_group_key])",
            "lineNumber": 56,
            "isSignature": true
          },
          {
            "lineNumber": 57
          },
          {
            "lineNumber": 58
          },
          {
            "text": "def particles():",
            "lineNumber": 59,
            "isSignature": true
          },
          {
            "text": "    # removes all unused particle systems from the project",
            "lineNumber": 60,
            "isSignature": true
          },
          {
            "text": "    ",
            "lineNumber": 61
          }
        ]
      },
      "score": 0.28281280398368835
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\direct_use_ops.py",
        "range": {
          "startPosition": {
            "line": 347,
            "column": 43
          },
          "endPosition": {
            "line": 407
          }
        },
        "contents": "# Atomic Data Manager Nuke Materials Operator\nclass ATOMIC_OT_nuke_materials(bpy.types.Operator):\n    \"\"\"Remove all materials from this project\"\"\"\n    bl_idname = \"atomic.nuke_materials\"\n    bl_label = \"Nuke Materials\"\n\n    def draw(self, context):\n        layout = self.layout\n\n        row = layout.row()\n        row.label(text=\"Remove the following data-blocks?\")\n\n        materials = bpy.data.materials.keys()\n        ui_layouts.box_list(\n            layout=layout,\n            items=materials,\n            icon=\"MATERIAL\"\n        )\n\n        row = layout.row()  # extra space\n\n    def execute(self, context):\n        nuke.materials()\n        return {'FINISHED'}\n\n    def invoke(self, context, event):\n        wm = context.window_manager\n        return wm.invoke_props_dialog(self)\n\n\n# Atomic Data Manager Nuke Node Groups Operator\nclass ATOMIC_OT_nuke_node_groups(bpy.types.Operator):\n    \"\"\"Remove all node groups from this project\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Atomic Data Manager Nuke Materials Operator",
            "lineNumber": 351
          },
          {
            "text": "class ATOMIC_OT_nuke_materials(bpy.types.Operator):",
            "lineNumber": 352,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all materials from this project\"\"\"",
            "lineNumber": 353
          },
          {
            "text": "    bl_idname = \"atomic.nuke_materials\"",
            "lineNumber": 354
          },
          {
            "text": "    bl_label = \"Nuke Materials\"",
            "lineNumber": 355
          },
          {
            "lineNumber": 356
          },
          {
            "text": "    def draw(self, context):",
            "lineNumber": 357
          },
          {
            "text": "        layout = self.layout",
            "lineNumber": 358
          },
          {
            "lineNumber": 359
          },
          {
            "text": "        row = layout.row()",
            "lineNumber": 360
          },
          {
            "text": "        row.label(text=\"Remove the following data-blocks?\")",
            "lineNumber": 361
          },
          {
            "lineNumber": 362
          },
          {
            "text": "        materials = bpy.data.materials.keys()",
            "lineNumber": 363
          },
          {
            "text": "        ui_layouts.box_list(",
            "lineNumber": 364
          },
          {
            "text": "            layout=layout,",
            "lineNumber": 365
          },
          {
            "text": "            items=materials,",
            "lineNumber": 366
          },
          {
            "text": "            icon=\"MATERIAL\"",
            "lineNumber": 367
          },
          {
            "text": "        )",
            "lineNumber": 368
          },
          {
            "lineNumber": 369
          },
          {
            "text": "        row = layout.row()  # extra space",
            "lineNumber": 370
          },
          {
            "lineNumber": 371
          },
          {
            "text": "    def execute(self, context):",
            "lineNumber": 372
          },
          {
            "text": "        nuke.materials()",
            "lineNumber": 373
          },
          {
            "text": "        return {'FINISHED'}",
            "lineNumber": 374
          },
          {
            "lineNumber": 375
          },
          {
            "text": "    def invoke(self, context, event):",
            "lineNumber": 376
          },
          {
            "text": "        wm = context.window_manager",
            "lineNumber": 377
          },
          {
            "text": "        return wm.invoke_props_dialog(self)",
            "lineNumber": 378,
            "isSignature": true
          },
          {
            "lineNumber": 379
          },
          {
            "lineNumber": 380
          },
          {
            "text": "# Atomic Data Manager Nuke Node Groups Operator",
            "lineNumber": 381
          },
          {
            "text": "class ATOMIC_OT_nuke_node_groups(bpy.types.Operator):",
            "lineNumber": 382,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Remove all node groups from this project\"\"\"",
            "lineNumber": 383
          }
        ]
      },
      "score": 0.269151896238327
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\inspect_ops.py",
        "range": {
          "startPosition": {
            "line": 484
          },
          "endPosition": {
            "line": 596
          }
        },
        "contents": "class ATOMIC_OT_inspection_delete(bpy.types.Operator):\ndef execute(self, context):\n\n                atom.lights_field = \"\"\n\n        elif inspection == 'MATERIALS':\n            key = atom.materials_field\n            materials = bpy.data.materials\n\n            if key in materials.keys():\n                material = materials[key]\n                error = _check_library_or_override(material)\n                if error:\n                    self.report({'ERROR'}, error)\n                    return {'CANCELLED'}\n                delete.material(key)\n                atom.materials_field = \"\"\n\n        elif inspection == 'NODE_GROUPS':\n            key = atom.node_groups_field\n            node_groups = bpy.data.node_groups\n\n            if key in node_groups.keys():\n                node_group = node_groups[key]\n                error = _check_library_or_override(node_group)\n                if error:\n                    self.report({'ERROR'}, error)\n                    return {'CANCELLED'}\n                delete.node_group(key)\n                atom.node_groups_field = \"\"\n\n        elif inspection == 'PARTICLES':\n            key = atom.particles_field\n            particles = bpy.data.particles\n            if key in particles.keys():\n                particle = particles[key]\n                error = _check_library_or_override(particle)\n                if error:\n                    self.report({'ERROR'}, error)\n                    return {'CANCELLED'}\n                delete.particle(key)\n                atom.particles_field = \"\"\n\n        elif inspection == 'TEXTURES':\n            key = atom.textures_field\n            textures = bpy.data.textures\n\n            if key in textures.keys():\n                texture = textures[key]\n                error = _check_library_or_override(texture)\n                if error:\n                    self.report({'ERROR'}, error)\n                    return {'CANCELLED'}\n                delete.texture(key)\n                atom.textures_field = \"\"\n\n        elif inspection == 'WORLDS':\n            key = atom.worlds_field",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 485,
                "column": 1
              },
              "endPosition": {
                "line": 486,
                "column": 5
              }
            },
            {
              "startPosition": {
                "line": 490,
                "column": 5
              },
              "endPosition": {
                "line": 491,
                "column": 9
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class ATOMIC_OT_inspection_delete(bpy.types.Operator):",
            "lineNumber": 485,
            "isSignature": true
          },
          {
            "text": "def execute(self, context):",
            "lineNumber": 490
          },
          {
            "lineNumber": 530
          },
          {
            "text": "                atom.lights_field = \"\"",
            "lineNumber": 531
          },
          {
            "lineNumber": 532
          },
          {
            "text": "        elif inspection == 'MATERIALS':",
            "lineNumber": 533
          },
          {
            "text": "            key = atom.materials_field",
            "lineNumber": 534
          },
          {
            "text": "            materials = bpy.data.materials",
            "lineNumber": 535
          },
          {
            "lineNumber": 536
          },
          {
            "text": "            if key in materials.keys():",
            "lineNumber": 537
          },
          {
            "text": "                material = materials[key]",
            "lineNumber": 538
          },
          {
            "text": "                error = _check_library_or_override(material)",
            "lineNumber": 539
          },
          {
            "text": "                if error:",
            "lineNumber": 540
          },
          {
            "text": "                    self.report({'ERROR'}, error)",
            "lineNumber": 541
          },
          {
            "text": "                    return {'CANCELLED'}",
            "lineNumber": 542
          },
          {
            "text": "                delete.material(key)",
            "lineNumber": 543
          },
          {
            "text": "                atom.materials_field = \"\"",
            "lineNumber": 544
          },
          {
            "lineNumber": 545
          },
          {
            "text": "        elif inspection == 'NODE_GROUPS':",
            "lineNumber": 546
          },
          {
            "text": "            key = atom.node_groups_field",
            "lineNumber": 547
          },
          {
            "text": "            node_groups = bpy.data.node_groups",
            "lineNumber": 548
          },
          {
            "lineNumber": 549
          },
          {
            "text": "            if key in node_groups.keys():",
            "lineNumber": 550
          },
          {
            "text": "                node_group = node_groups[key]",
            "lineNumber": 551
          },
          {
            "text": "                error = _check_library_or_override(node_group)",
            "lineNumber": 552
          },
          {
            "text": "                if error:",
            "lineNumber": 553
          },
          {
            "text": "                    self.report({'ERROR'}, error)",
            "lineNumber": 554
          },
          {
            "text": "                    return {'CANCELLED'}",
            "lineNumber": 555
          },
          {
            "text": "                delete.node_group(key)",
            "lineNumber": 556
          },
          {
            "text": "                atom.node_groups_field = \"\"",
            "lineNumber": 557
          },
          {
            "lineNumber": 558
          },
          {
            "text": "        elif inspection == 'PARTICLES':",
            "lineNumber": 559
          },
          {
            "text": "            key = atom.particles_field",
            "lineNumber": 560
          },
          {
            "text": "            particles = bpy.data.particles",
            "lineNumber": 561
          },
          {
            "text": "            if key in particles.keys():",
            "lineNumber": 562
          },
          {
            "text": "                particle = particles[key]",
            "lineNumber": 563
          },
          {
            "text": "                error = _check_library_or_override(particle)",
            "lineNumber": 564
          },
          {
            "text": "                if error:",
            "lineNumber": 565
          },
          {
            "text": "                    self.report({'ERROR'}, error)",
            "lineNumber": 566
          },
          {
            "text": "                    return {'CANCELLED'}",
            "lineNumber": 567
          },
          {
            "text": "                delete.particle(key)",
            "lineNumber": 568
          },
          {
            "text": "                atom.particles_field = \"\"",
            "lineNumber": 569
          },
          {
            "lineNumber": 570
          },
          {
            "text": "        elif inspection == 'TEXTURES':",
            "lineNumber": 571
          },
          {
            "text": "            key = atom.textures_field",
            "lineNumber": 572
          },
          {
            "text": "            textures = bpy.data.textures",
            "lineNumber": 573
          },
          {
            "lineNumber": 574
          },
          {
            "text": "            if key in textures.keys():",
            "lineNumber": 575
          },
          {
            "text": "                texture = textures[key]",
            "lineNumber": 576
          },
          {
            "text": "                error = _check_library_or_override(texture)",
            "lineNumber": 577
          },
          {
            "text": "                if error:",
            "lineNumber": 578
          },
          {
            "text": "                    self.report({'ERROR'}, error)",
            "lineNumber": 579
          },
          {
            "text": "                    return {'CANCELLED'}",
            "lineNumber": 580
          },
          {
            "text": "                delete.texture(key)",
            "lineNumber": 581
          },
          {
            "text": "                atom.textures_field = \"\"",
            "lineNumber": 582
          },
          {
            "lineNumber": 583
          },
          {
            "text": "        elif inspection == 'WORLDS':",
            "lineNumber": 584
          },
          {
            "text": "            key = atom.worlds_field",
            "lineNumber": 585
          }
        ]
      },
      "score": 0.2654959559440613
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\ops\\main_ops.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 189
          }
        },
        "contents": "\"\"\"\nCopyright (C) 2019 Remington Creative\n\nThis file is part of Atomic Data Manager.\n\nAtomic Data Manager is free software: you can redistribute\nit and/or modify it under the terms of the GNU General Public License\nas published by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nAtomic Data Manager is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\n---\n\nThis file contains the main operators found in the main panel of the\nAtomic Data Manager interface. This includes nuke, clean, undo, and the\nvarious selection operations.\n\n\"\"\"\n\nimport bpy\nfrom bpy.utils import register_class\nfrom ..utils import compat\nfrom ..stats import unused\nfrom ..stats import unused_parallel\nfrom .utils import clean\nfrom .utils import nuke\nfrom ..ui.utils import ui_layouts\n\n\n# Atomic Data Manager Nuke Operator\nclass ATOMIC_OT_nuke(bpy.types.Operator):\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "\"\"\"",
            "lineNumber": 1
          },
          {
            "text": "Copyright (C) 2019 Remington Creative",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "This file is part of Atomic Data Manager.",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "Atomic Data Manager is free software: you can redistribute",
            "lineNumber": 6
          },
          {
            "text": "it and/or modify it under the terms of the GNU General Public License",
            "lineNumber": 7
          },
          {
            "text": "as published by the Free Software Foundation, either version 3 of the",
            "lineNumber": 8
          },
          {
            "text": "License, or (at your option) any later version.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "Atomic Data Manager is distributed in the hope that it will",
            "lineNumber": 11
          },
          {
            "text": "be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
            "lineNumber": 12
          },
          {
            "text": "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",
            "lineNumber": 13
          },
          {
            "text": "General Public License for more details.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "You should have received a copy of the GNU General Public License along",
            "lineNumber": 16
          },
          {
            "text": "with Atomic Data Manager.  If not, see &lt;https://www.gnu.org/licenses/&gt;.",
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "---",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "text": "This file contains the main operators found in the main panel of the",
            "lineNumber": 21
          },
          {
            "text": "Atomic Data Manager interface. This includes nuke, clean, undo, and the",
            "lineNumber": 22
          },
          {
            "text": "various selection operations.",
            "lineNumber": 23
          },
          {
            "lineNumber": 24
          },
          {
            "text": "\"\"\"",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "import bpy",
            "lineNumber": 27
          },
          {
            "text": "from bpy.utils import register_class",
            "lineNumber": 28
          },
          {
            "text": "from ..utils import compat",
            "lineNumber": 29
          },
          {
            "text": "from ..stats import unused",
            "lineNumber": 30
          },
          {
            "text": "from ..stats import unused_parallel",
            "lineNumber": 31
          },
          {
            "text": "from .utils import clean",
            "lineNumber": 32
          },
          {
            "text": "from .utils import nuke",
            "lineNumber": 33
          },
          {
            "text": "from ..ui.utils import ui_layouts",
            "lineNumber": 34
          },
          {
            "lineNumber": 35
          },
          {
            "lineNumber": 36
          },
          {
            "text": "# Atomic Data Manager Nuke Operator",
            "lineNumber": 37
          },
          {
            "text": "class ATOMIC_OT_nuke(bpy.types.Operator):",
            "lineNumber": 38,
            "isSignature": true
          },
          {
            "text": "    ",
            "lineNumber": 39
          }
        ]
      },
      "score": 0.2637101113796234
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


Reviewing the `material_node_groups` function and testing the logic:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\unused.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "def material_node_groups",
  "contextAfter": 15,
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "def material_node_groups",
    "outputMode": "content",
    "workspaceResults": {
      "e:\\atomic_data_manager": {
        "content": {
          "matches": [
            {
              "file": "stats\\users.py",
              "matches": [
                {
                  "lineNumber": 455,
                  "content": "def material_node_groups(material_key):"
                },
                {
                  "lineNumber": 456,
                  "content": "    # returns a list of keys indicating where the material is used via node groups",
                  "isContextLine": true
                },
                {
                  "lineNumber": 457,
                  "content": "    # This checks if the material is used in any node group, and if that node group",
                  "isContextLine": true
                },
                {
                  "lineNumber": 458,
                  "content": "    # is itself used anywhere (materials, other node groups, compositor, etc.)",
                  "isContextLine": true
                },
                {
                  "lineNumber": 459,
                  "isContextLine": true
                },
                {
                  "lineNumber": 460,
                  "content": "    users = []",
                  "isContextLine": true
                },
                {
                  "lineNumber": 461,
                  "content": "    material = bpy.data.materials[material_key]",
                  "isContextLine": true
                },
                {
                  "lineNumber": 462,
                  "isContextLine": true
                },
                {
                  "lineNumber": 463,
                  "content": "    # Check all node groups to see if they contain this material",
                  "isContextLine": true
                },
                {
                  "lineNumber": 464,
                  "content": "    for node_group in bpy.data.node_groups:",
                  "isContextLine": true
                },
                {
                  "lineNumber": 465,
                  "content": "        if node_group_has_material(node_group.name, material.name):",
                  "isContextLine": true
                },
                {
                  "lineNumber": 466,
                  "content": "            # This node group contains the material, now check if the node group is used",
                  "isContextLine": true
                },
                {
                  "lineNumber": 467,
                  "content": "            node_group_users = node_group_all(node_group.name)",
                  "isContextLine": true
                },
                {
                  "lineNumber": 468,
                  "content": "            if node_group_users:",
                  "isContextLine": true
                },
                {
                  "lineNumber": 469,
                  "content": "                # The node group is used, so the material is used",
                  "isContextLine": true
                },
                {
                  "lineNumber": 470,
                  "content": "                # Add a generic identifier to indicate the material is used via node groups",
                  "isContextLine": true
                }
              ]
            }
          ],
          "totalLines": 16,
          "totalMatchedLines": 1
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---


The `material_node_groups()` function is too slow because it calls `node_group_all()` for every material in every node group. Also, `material_geometry_nodes()` should already catch this case. Optimizing and fixing the detection:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\stats\\users.py"
}
```
Additional data:

```json
{
  "codeblockId": "d0e92dcd-28d3-47c2-9ecc-72cd44d0b2bc"
}
```
Status: **completed**


</details>
</tool-use>

---


Simplifying and optimizing the function. The current approach is too slow. Also verifying that `material_geometry_nodes()` correctly detects this case:


---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\stats\\users.py"
}
```
Additional data:

```json
{
  "codeblockId": "eadec9e1-2e84-4edc-9851-6b864d35ee0f"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "stats/users.py"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "stats/users.py"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


Verifying that `material_geometry_nodes()` correctly detects this case. Adding debug output and ensuring `node_group_has_material()` correctly identifies "Set Material" nodes. Also checking if the performance issue is due to redundant checks:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "How does node_group_has_material detect Set Material nodes in Geometry Nodes?",
  "includePattern": "stats",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 748
          },
          "endPosition": {
            "line": 813
          }
        },
        "contents": "def node_group_has_node_group(search_group_key, node_group_key):\n    # returns true if a node group contains this node group\n\n        if has_node_group:\n            break\n\n    return has_node_group\n\n\ndef node_group_has_texture(node_group_key, texture_key):\n    # returns true if a node group contains this image\n\n    has_texture = False\n    if not hasattr(bpy.data, 'textures'):\n        return has_texture\n    node_group = bpy.data.node_groups[node_group_key]\n    texture = bpy.data.textures[texture_key]\n\n    # for each node in our search group\n    for node in node_group.nodes:\n\n        # base case\n        # if node has a not none image attribute\n        if hasattr(node, 'texture') and node.texture:\n\n            # if the node group is our node group\n            if node.texture.name == texture.name:\n                has_texture = True\n\n        # recurse case\n        # if node is a node group and has a valid node tree\n        elif",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_group_has_node_group(search_group_key, node_group_key):",
            "lineNumber": 749,
            "isSignature": true
          },
          {
            "text": "    # returns true if a node group contains this node group",
            "lineNumber": 750,
            "isSignature": true
          },
          {
            "lineNumber": 777
          },
          {
            "text": "        if has_node_group:",
            "lineNumber": 778
          },
          {
            "text": "            break",
            "lineNumber": 779
          },
          {
            "lineNumber": 780
          },
          {
            "text": "    return has_node_group",
            "lineNumber": 781,
            "isSignature": true
          },
          {
            "lineNumber": 782
          },
          {
            "lineNumber": 783
          },
          {
            "text": "def node_group_has_texture(node_group_key, texture_key):",
            "lineNumber": 784,
            "isSignature": true
          },
          {
            "text": "    # returns true if a node group contains this image",
            "lineNumber": 785,
            "isSignature": true
          },
          {
            "lineNumber": 786
          },
          {
            "text": "    has_texture = False",
            "lineNumber": 787
          },
          {
            "text": "    if not hasattr(bpy.data, 'textures'):",
            "lineNumber": 788
          },
          {
            "text": "        return has_texture",
            "lineNumber": 789
          },
          {
            "text": "    node_group = bpy.data.node_groups[node_group_key]",
            "lineNumber": 790
          },
          {
            "text": "    texture = bpy.data.textures[texture_key]",
            "lineNumber": 791
          },
          {
            "lineNumber": 792
          },
          {
            "text": "    # for each node in our search group",
            "lineNumber": 793
          },
          {
            "text": "    for node in node_group.nodes:",
            "lineNumber": 794
          },
          {
            "lineNumber": 795
          },
          {
            "text": "        # base case",
            "lineNumber": 796
          },
          {
            "text": "        # if node has a not none image attribute",
            "lineNumber": 797
          },
          {
            "text": "        if hasattr(node, 'texture') and node.texture:",
            "lineNumber": 798
          },
          {
            "lineNumber": 799
          },
          {
            "text": "            # if the node group is our node group",
            "lineNumber": 800
          },
          {
            "text": "            if node.texture.name == texture.name:",
            "lineNumber": 801
          },
          {
            "text": "                has_texture = True",
            "lineNumber": 802
          },
          {
            "lineNumber": 803
          },
          {
            "text": "        # recurse case",
            "lineNumber": 804
          },
          {
            "text": "        # if node is a node group and has a valid node tree",
            "lineNumber": 805
          },
          {
            "text": "        elif",
            "lineNumber": 806
          }
        ]
      },
      "score": 0.5566858053207397
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 430,
            "column": 45
          },
          "endPosition": {
            "line": 508
          }
        },
        "contents": "def material_geometry_nodes(material_key):\n    # returns a list of object keys that use the material via Geometry Nodes\n\n    users = []\n    material = bpy.data.materials[material_key]\n\n    # Import compat module for version-safe geometry nodes access\n    from ..utils import compat\n\n    for obj in bpy.data.objects:\n        if hasattr(obj, 'modifiers'):\n            for modifier in obj.modifiers:\n                if compat.is_geometry_nodes_modifier(modifier):\n                    ng = compat.get_geometry_nodes_modifier_node_group(modifier)\n                    if ng:\n                        if node_group_has_material(ng.name, material.name):\n                            users.append(obj.name)\n\n    return distinct(users)\n\n\ndef material_node_groups(material_key):\n    # returns a list of keys indicating where the material is used via node groups\n    # This checks if the material is used in any node group, and if that node group\n    # is itself used anywhere. This is a fallback for cases where material_geometry_nodes()\n    # might miss usage (e.g., node groups used in materials, other node groups, etc.)\n    \n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def material_geometry_nodes(material_key):",
            "lineNumber": 434,
            "isSignature": true
          },
          {
            "text": "    # returns a list of object keys that use the material via Geometry Nodes",
            "lineNumber": 435,
            "isSignature": true
          },
          {
            "lineNumber": 436
          },
          {
            "text": "    users = []",
            "lineNumber": 437
          },
          {
            "text": "    material = bpy.data.materials[material_key]",
            "lineNumber": 438
          },
          {
            "lineNumber": 439
          },
          {
            "text": "    # Import compat module for version-safe geometry nodes access",
            "lineNumber": 440
          },
          {
            "text": "    from ..utils import compat",
            "lineNumber": 441
          },
          {
            "lineNumber": 442
          },
          {
            "text": "    for obj in bpy.data.objects:",
            "lineNumber": 443
          },
          {
            "text": "        if hasattr(obj, 'modifiers'):",
            "lineNumber": 444
          },
          {
            "text": "            for modifier in obj.modifiers:",
            "lineNumber": 445
          },
          {
            "text": "                if compat.is_geometry_nodes_modifier(modifier):",
            "lineNumber": 446
          },
          {
            "text": "                    ng = compat.get_geometry_nodes_modifier_node_group(modifier)",
            "lineNumber": 447
          },
          {
            "text": "                    if ng:",
            "lineNumber": 448
          },
          {
            "text": "                        if node_group_has_material(ng.name, material.name):",
            "lineNumber": 449
          },
          {
            "text": "                            users.append(obj.name)",
            "lineNumber": 450
          },
          {
            "lineNumber": 451
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 452,
            "isSignature": true
          },
          {
            "lineNumber": 453
          },
          {
            "lineNumber": 454
          },
          {
            "text": "def material_node_groups(material_key):",
            "lineNumber": 455,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys indicating where the material is used via node groups",
            "lineNumber": 456,
            "isSignature": true
          },
          {
            "text": "    # This checks if the material is used in any node group, and if that node group",
            "lineNumber": 457,
            "isSignature": true
          },
          {
            "text": "    # is itself used anywhere. This is a fallback for cases where material_geometry_nodes()",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "    # might miss usage (e.g., node groups used in materials, other node groups, etc.)",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "text": "    ",
            "lineNumber": 460
          },
          {
            "text": "    ",
            "lineNumber": 461
          }
        ]
      },
      "score": 0.456953763961792
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 451,
            "column": 26
          },
          "endPosition": {
            "line": 508
          }
        },
        "contents": "def material_node_groups(material_key):\n    # returns a list of keys indicating where the material is used via node groups\n    # This checks if the material is used in any node group, and if that node group\n    # is itself used anywhere. This is a fallback for cases where material_geometry_nodes()\n    # might miss usage (e.g., node groups used in materials, other node groups, etc.)\n    \n    users = []\n    material = bpy.data.materials[material_key]\n\n    # Check all node groups to see if they contain this material\n    for node_group in bpy.data.node_groups:\n        if node_group_has_material(node_group.name, material.name):\n            # This node group contains the material, now check if the node group is used\n            # Check various usage contexts efficiently\n            \n            # Check if used in materials (quick check)\n            for mat in bpy.data.materials:\n                if mat.use_nodes and mat.node_tree:\n                    for node in mat.node_tree.nodes:\n                        if hasattr(node, 'node_tree') and node.node_tree:\n                            if node.node_tree.name == node_group.name:",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def material_node_groups(material_key):",
            "lineNumber": 455,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys indicating where the material is used via node groups",
            "lineNumber": 456,
            "isSignature": true
          },
          {
            "text": "    # This checks if the material is used in any node group, and if that node group",
            "lineNumber": 457,
            "isSignature": true
          },
          {
            "text": "    # is itself used anywhere. This is a fallback for cases where material_geometry_nodes()",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "    # might miss usage (e.g., node groups used in materials, other node groups, etc.)",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "text": "    ",
            "lineNumber": 460
          },
          {
            "text": "    users = []",
            "lineNumber": 461
          },
          {
            "text": "    material = bpy.data.materials[material_key]",
            "lineNumber": 462
          },
          {
            "lineNumber": 463
          },
          {
            "text": "    # Check all node groups to see if they contain this material",
            "lineNumber": 464
          },
          {
            "text": "    for node_group in bpy.data.node_groups:",
            "lineNumber": 465
          },
          {
            "text": "        if node_group_has_material(node_group.name, material.name):",
            "lineNumber": 466
          },
          {
            "text": "            # This node group contains the material, now check if the node group is used",
            "lineNumber": 467
          },
          {
            "text": "            # Check various usage contexts efficiently",
            "lineNumber": 468
          },
          {
            "text": "            ",
            "lineNumber": 469
          },
          {
            "text": "            # Check if used in materials (quick check)",
            "lineNumber": 470
          },
          {
            "text": "            for mat in bpy.data.materials:",
            "lineNumber": 471
          },
          {
            "text": "                if mat.use_nodes and mat.node_tree:",
            "lineNumber": 472
          },
          {
            "text": "                    for node in mat.node_tree.nodes:",
            "lineNumber": 473
          },
          {
            "text": "                        if hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 474
          },
          {
            "text": "                            if node.node_tree.name == node_group.name:",
            "lineNumber": 475
          }
        ]
      },
      "score": 0.4116837978363037
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 533
          },
          "endPosition": {
            "line": 576
          }
        },
        "contents": "def node_group_all(node_group_key):\n    # returns a list of keys of every data-block that uses this node group\n           node_group_worlds(node_group_key) + \\\n           node_group_objects(node_group_key)\n\n\ndef node_group_compositors(node_group_key):\n    # returns a list containing \"Compositor\" if the node group is used in\n    # the scene's compositor\n\n    users = []\n    node_group = bpy.data.node_groups[node_group_key]\n\n    # a list of node groups that use our node group\n    node_group_users = node_group_node_groups(node_group_key)\n\n    # Import compat module for version-safe compositor access\n    from ..utils import compat\n\n    # if our compositor uses nodes and has a valid node tree\n    scene = bpy.context.scene\n    if scene.use_nodes:\n        node_tree = compat.get_scene_compositor_node_tree(scene)\n        if node_tree:\n            # check each node in the compositor\n            for node in node_tree.nodes:\n\n                # if the node is a group and has a valid node tree\n                if hasattr(node, 'node_tree') and node.node_tree:\n\n                    # if the node group is our node group\n                    if node.node_tree.name == node_group.name:\n                        users.append(\"Compositor\")\n\n                    # if the node group is in our list of node group users",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_group_all(node_group_key):",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of every data-block that uses this node group",
            "lineNumber": 535,
            "isSignature": true
          },
          {
            "text": "           node_group_worlds(node_group_key) + \\",
            "lineNumber": 541
          },
          {
            "text": "           node_group_objects(node_group_key)",
            "lineNumber": 542,
            "isSignature": true
          },
          {
            "lineNumber": 543
          },
          {
            "lineNumber": 544
          },
          {
            "text": "def node_group_compositors(node_group_key):",
            "lineNumber": 545,
            "isSignature": true
          },
          {
            "text": "    # returns a list containing \"Compositor\" if the node group is used in",
            "lineNumber": 546,
            "isSignature": true
          },
          {
            "text": "    # the scene's compositor",
            "lineNumber": 547,
            "isSignature": true
          },
          {
            "lineNumber": 548
          },
          {
            "text": "    users = []",
            "lineNumber": 549
          },
          {
            "text": "    node_group = bpy.data.node_groups[node_group_key]",
            "lineNumber": 550
          },
          {
            "lineNumber": 551
          },
          {
            "text": "    # a list of node groups that use our node group",
            "lineNumber": 552
          },
          {
            "text": "    node_group_users = node_group_node_groups(node_group_key)",
            "lineNumber": 553
          },
          {
            "lineNumber": 554
          },
          {
            "text": "    # Import compat module for version-safe compositor access",
            "lineNumber": 555
          },
          {
            "text": "    from ..utils import compat",
            "lineNumber": 556
          },
          {
            "lineNumber": 557
          },
          {
            "text": "    # if our compositor uses nodes and has a valid node tree",
            "lineNumber": 558
          },
          {
            "text": "    scene = bpy.context.scene",
            "lineNumber": 559
          },
          {
            "text": "    if scene.use_nodes:",
            "lineNumber": 560
          },
          {
            "text": "        node_tree = compat.get_scene_compositor_node_tree(scene)",
            "lineNumber": 561
          },
          {
            "text": "        if node_tree:",
            "lineNumber": 562
          },
          {
            "text": "            # check each node in the compositor",
            "lineNumber": 563
          },
          {
            "text": "            for node in node_tree.nodes:",
            "lineNumber": 564
          },
          {
            "lineNumber": 565
          },
          {
            "text": "                # if the node is a group and has a valid node tree",
            "lineNumber": 566
          },
          {
            "text": "                if hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 567
          },
          {
            "lineNumber": 568
          },
          {
            "text": "                    # if the node group is our node group",
            "lineNumber": 569
          },
          {
            "text": "                    if node.node_tree.name == node_group.name:",
            "lineNumber": 570
          },
          {
            "text": "                        users.append(\"Compositor\")",
            "lineNumber": 571
          },
          {
            "lineNumber": 572
          },
          {
            "text": "                    # if the node group is in our list of node group users",
            "lineNumber": 573
          }
        ]
      },
      "score": 0.3970930576324463
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 691
          },
          "endPosition": {
            "line": 780
          }
        },
        "contents": "def node_group_objects(node_group_key):\n    # returns a list of object keys that use this node group via Geometry Nodes modifiers\n\n                            users.append(obj.name)\n\n    return distinct(users)\n\n\ndef node_group_has_image(node_group_key, image_key):\n    # recursively returns true if the node group contains this image\n    # directly or if it contains a node group a node group that contains\n    # the image indirectly\n\n    has_image = False\n    node_group = bpy.data.node_groups[node_group_key]\n    image = bpy.data.images[image_key]\n\n    # for each node in our search group\n    for node in node_group.nodes:\n\n        # base case\n        # if node has a not none image attribute\n        if hasattr(node, 'image') and node.image:\n\n            # if the node group is our node group\n            if node.image.name == image.name:\n                has_image = True\n\n        # recurse case\n        # if node is a node group and has a valid node tree\n        elif hasattr(node, 'node_tree') and node.node_tree:\n            has_image = node_group_has_image(\n                node.node_tree.name, image.name)\n\n        # break the loop if the image is found\n        if has_image:\n            break\n\n    return has_image\n\n\ndef node_group_has_node_group(search_group_key, node_group_key):\n    # returns true if a node group contains this node group\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_group_objects(node_group_key):",
            "lineNumber": 692,
            "isSignature": true
          },
          {
            "text": "    # returns a list of object keys that use this node group via Geometry Nodes modifiers",
            "lineNumber": 693,
            "isSignature": true
          },
          {
            "lineNumber": 710
          },
          {
            "text": "                            users.append(obj.name)",
            "lineNumber": 711
          },
          {
            "lineNumber": 712
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 713,
            "isSignature": true
          },
          {
            "lineNumber": 714
          },
          {
            "lineNumber": 715
          },
          {
            "text": "def node_group_has_image(node_group_key, image_key):",
            "lineNumber": 716,
            "isSignature": true
          },
          {
            "text": "    # recursively returns true if the node group contains this image",
            "lineNumber": 717,
            "isSignature": true
          },
          {
            "text": "    # directly or if it contains a node group a node group that contains",
            "lineNumber": 718,
            "isSignature": true
          },
          {
            "text": "    # the image indirectly",
            "lineNumber": 719,
            "isSignature": true
          },
          {
            "lineNumber": 720
          },
          {
            "text": "    has_image = False",
            "lineNumber": 721
          },
          {
            "text": "    node_group = bpy.data.node_groups[node_group_key]",
            "lineNumber": 722
          },
          {
            "text": "    image = bpy.data.images[image_key]",
            "lineNumber": 723
          },
          {
            "lineNumber": 724
          },
          {
            "text": "    # for each node in our search group",
            "lineNumber": 725
          },
          {
            "text": "    for node in node_group.nodes:",
            "lineNumber": 726
          },
          {
            "lineNumber": 727
          },
          {
            "text": "        # base case",
            "lineNumber": 728
          },
          {
            "text": "        # if node has a not none image attribute",
            "lineNumber": 729
          },
          {
            "text": "        if hasattr(node, 'image') and node.image:",
            "lineNumber": 730
          },
          {
            "lineNumber": 731
          },
          {
            "text": "            # if the node group is our node group",
            "lineNumber": 732
          },
          {
            "text": "            if node.image.name == image.name:",
            "lineNumber": 733
          },
          {
            "text": "                has_image = True",
            "lineNumber": 734
          },
          {
            "lineNumber": 735
          },
          {
            "text": "        # recurse case",
            "lineNumber": 736
          },
          {
            "text": "        # if node is a node group and has a valid node tree",
            "lineNumber": 737
          },
          {
            "text": "        elif hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 738
          },
          {
            "text": "            has_image = node_group_has_image(",
            "lineNumber": 739
          },
          {
            "text": "                node.node_tree.name, image.name)",
            "lineNumber": 740
          },
          {
            "lineNumber": 741
          },
          {
            "text": "        # break the loop if the image is found",
            "lineNumber": 742
          },
          {
            "text": "        if has_image:",
            "lineNumber": 743
          },
          {
            "text": "            break",
            "lineNumber": 744
          },
          {
            "lineNumber": 745
          },
          {
            "text": "    return has_image",
            "lineNumber": 746,
            "isSignature": true
          },
          {
            "lineNumber": 747
          },
          {
            "lineNumber": 748
          },
          {
            "text": "def node_group_has_node_group(search_group_key, node_group_key):",
            "lineNumber": 749,
            "isSignature": true
          },
          {
            "text": "    # returns true if a node group contains this node group",
            "lineNumber": 750,
            "isSignature": true
          },
          {
            "lineNumber": 751
          },
          {
            "text": "    ",
            "lineNumber": 752
          }
        ]
      },
      "score": 0.3897285461425781
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 715
          },
          "endPosition": {
            "line": 780,
            "column": 25
          }
        },
        "contents": "def node_group_has_image(node_group_key, image_key):\n    # recursively returns true if the node group contains this image\n    # directly or if it contains a node group a node group that contains\n    # the image indirectly\n\n\n    return has_image\n\n\ndef node_group_has_node_group(search_group_key, node_group_key):\n    # returns true if a node group contains this node group\n\n    has_node_group = False\n    search_group = bpy.data.node_groups[search_group_key]\n    node_group = bpy.data.node_groups[node_group_key]\n\n    # for each node in our search group\n    for node in search_group.nodes:\n\n        # if node is a node group and has a valid node tree\n        if hasattr(node, 'node_tree') and node.node_tree:\n\n            if node.node_tree.name == \"RG_MetallicMap\":\n                print(node.node_tree.name)\n                print(node_group.name)\n\n            # base case\n            # if node group is our node group\n            if node.node_tree.name == node_group.name:\n                has_node_group = True\n\n            # recurse case\n            # if node group is any other node group\n            else:\n                has_node_group = node_group_has_node_group(\n                    node.node_tree.name, node_group.name)\n\n        # break the loop if the node group is found\n        if has_node_group:\n            break\n\n    return has_node_group",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_group_has_image(node_group_key, image_key):",
            "lineNumber": 716,
            "isSignature": true
          },
          {
            "text": "    # recursively returns true if the node group contains this image",
            "lineNumber": 717,
            "isSignature": true
          },
          {
            "text": "    # directly or if it contains a node group a node group that contains",
            "lineNumber": 718,
            "isSignature": true
          },
          {
            "text": "    # the image indirectly",
            "lineNumber": 719,
            "isSignature": true
          },
          {
            "lineNumber": 744
          },
          {
            "lineNumber": 745
          },
          {
            "text": "    return has_image",
            "lineNumber": 746,
            "isSignature": true
          },
          {
            "lineNumber": 747
          },
          {
            "lineNumber": 748
          },
          {
            "text": "def node_group_has_node_group(search_group_key, node_group_key):",
            "lineNumber": 749,
            "isSignature": true
          },
          {
            "text": "    # returns true if a node group contains this node group",
            "lineNumber": 750,
            "isSignature": true
          },
          {
            "lineNumber": 751
          },
          {
            "text": "    has_node_group = False",
            "lineNumber": 752
          },
          {
            "text": "    search_group = bpy.data.node_groups[search_group_key]",
            "lineNumber": 753
          },
          {
            "text": "    node_group = bpy.data.node_groups[node_group_key]",
            "lineNumber": 754
          },
          {
            "lineNumber": 755
          },
          {
            "text": "    # for each node in our search group",
            "lineNumber": 756
          },
          {
            "text": "    for node in search_group.nodes:",
            "lineNumber": 757
          },
          {
            "lineNumber": 758
          },
          {
            "text": "        # if node is a node group and has a valid node tree",
            "lineNumber": 759
          },
          {
            "text": "        if hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 760
          },
          {
            "lineNumber": 761
          },
          {
            "text": "            if node.node_tree.name == \"RG_MetallicMap\":",
            "lineNumber": 762
          },
          {
            "text": "                print(node.node_tree.name)",
            "lineNumber": 763
          },
          {
            "text": "                print(node_group.name)",
            "lineNumber": 764
          },
          {
            "lineNumber": 765
          },
          {
            "text": "            # base case",
            "lineNumber": 766
          },
          {
            "text": "            # if node group is our node group",
            "lineNumber": 767
          },
          {
            "text": "            if node.node_tree.name == node_group.name:",
            "lineNumber": 768
          },
          {
            "text": "                has_node_group = True",
            "lineNumber": 769
          },
          {
            "lineNumber": 770
          },
          {
            "text": "            # recurse case",
            "lineNumber": 771
          },
          {
            "text": "            # if node group is any other node group",
            "lineNumber": 772
          },
          {
            "text": "            else:",
            "lineNumber": 773
          },
          {
            "text": "                has_node_group = node_group_has_node_group(",
            "lineNumber": 774
          },
          {
            "text": "                    node.node_tree.name, node_group.name)",
            "lineNumber": 775
          },
          {
            "lineNumber": 776
          },
          {
            "text": "        # break the loop if the node group is found",
            "lineNumber": 777
          },
          {
            "text": "        if has_node_group:",
            "lineNumber": 778
          },
          {
            "text": "            break",
            "lineNumber": 779
          },
          {
            "lineNumber": 780
          },
          {
            "text": "    return has_node_group",
            "lineNumber": 781,
            "isSignature": true
          }
        ]
      },
      "score": 0.37377774715423584
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 660
          },
          "endPosition": {
            "line": 712,
            "column": 26
          }
        },
        "contents": "def node_group_worlds(node_group_key):\n    # returns a list of world keys that use the node group in their node\n    # trees\n\n                if hasattr(node, 'node_tree') and node.node_tree:\n\n                    # if this node is our node group\n                    if node.node_tree.name == node_group.name:\n                        users.append(world.name)\n\n                    # if this node is one of the node groups that use\n                    # our node group\n                    elif node.node_tree.name in node_group_users:\n                        users.append(world.name)\n\n    return distinct(users)\n\n\ndef node_group_objects(node_group_key):\n    # returns a list of object keys that use this node group via Geometry Nodes modifiers\n\n    users = []\n    node_group = bpy.data.node_groups[node_group_key]\n\n    # node groups that use this node group\n    node_group_users = node_group_node_groups(node_group_key)\n\n    # Import compat module for version-safe geometry nodes access\n    from ..utils import compat\n\n    for obj in bpy.data.objects:\n        if hasattr(obj, 'modifiers'):\n            for modifier in obj.modifiers:\n                if compat.is_geometry_nodes_modifier(modifier):\n                    ng = compat.get_geometry_nodes_modifier_node_group(modifier)\n                    if ng:\n                        if ng.name == node_group.name or ng.name in node_group_users:\n                            users.append(obj.name)\n\n    return distinct(users)",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_group_worlds(node_group_key):",
            "lineNumber": 661,
            "isSignature": true
          },
          {
            "text": "    # returns a list of world keys that use the node group in their node",
            "lineNumber": 662,
            "isSignature": true
          },
          {
            "text": "    # trees",
            "lineNumber": 663,
            "isSignature": true
          },
          {
            "lineNumber": 677
          },
          {
            "text": "                if hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 678
          },
          {
            "lineNumber": 679
          },
          {
            "text": "                    # if this node is our node group",
            "lineNumber": 680
          },
          {
            "text": "                    if node.node_tree.name == node_group.name:",
            "lineNumber": 681
          },
          {
            "text": "                        users.append(world.name)",
            "lineNumber": 682
          },
          {
            "lineNumber": 683
          },
          {
            "text": "                    # if this node is one of the node groups that use",
            "lineNumber": 684
          },
          {
            "text": "                    # our node group",
            "lineNumber": 685
          },
          {
            "text": "                    elif node.node_tree.name in node_group_users:",
            "lineNumber": 686
          },
          {
            "text": "                        users.append(world.name)",
            "lineNumber": 687
          },
          {
            "lineNumber": 688
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 689,
            "isSignature": true
          },
          {
            "lineNumber": 690
          },
          {
            "lineNumber": 691
          },
          {
            "text": "def node_group_objects(node_group_key):",
            "lineNumber": 692,
            "isSignature": true
          },
          {
            "text": "    # returns a list of object keys that use this node group via Geometry Nodes modifiers",
            "lineNumber": 693,
            "isSignature": true
          },
          {
            "lineNumber": 694
          },
          {
            "text": "    users = []",
            "lineNumber": 695
          },
          {
            "text": "    node_group = bpy.data.node_groups[node_group_key]",
            "lineNumber": 696
          },
          {
            "lineNumber": 697
          },
          {
            "text": "    # node groups that use this node group",
            "lineNumber": 698
          },
          {
            "text": "    node_group_users = node_group_node_groups(node_group_key)",
            "lineNumber": 699
          },
          {
            "lineNumber": 700
          },
          {
            "text": "    # Import compat module for version-safe geometry nodes access",
            "lineNumber": 701
          },
          {
            "text": "    from ..utils import compat",
            "lineNumber": 702
          },
          {
            "lineNumber": 703
          },
          {
            "text": "    for obj in bpy.data.objects:",
            "lineNumber": 704
          },
          {
            "text": "        if hasattr(obj, 'modifiers'):",
            "lineNumber": 705
          },
          {
            "text": "            for modifier in obj.modifiers:",
            "lineNumber": 706
          },
          {
            "text": "                if compat.is_geometry_nodes_modifier(modifier):",
            "lineNumber": 707
          },
          {
            "text": "                    ng = compat.get_geometry_nodes_modifier_node_group(modifier)",
            "lineNumber": 708
          },
          {
            "text": "                    if ng:",
            "lineNumber": 709
          },
          {
            "text": "                        if ng.name == node_group.name or ng.name in node_group_users:",
            "lineNumber": 710
          },
          {
            "text": "                            users.append(obj.name)",
            "lineNumber": 711
          },
          {
            "lineNumber": 712
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 713,
            "isSignature": true
          }
        ]
      },
      "score": 0.3655143976211548
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 627
          },
          "endPosition": {
            "line": 688
          }
        },
        "contents": "def node_group_textures(node_group_key):\n    # returns a list of texture keys that use this node group in their\n    # node trees\n\n\n                    # if node is a node group that contains our node group\n                    if node.node_tree.name in node_group_users:\n                        users.append(texture.name)\n\n    return distinct(users)\n\n\ndef node_group_worlds(node_group_key):\n    # returns a list of world keys that use the node group in their node\n    # trees\n\n    users = []\n    node_group = bpy.data.node_groups[node_group_key]\n\n    # node groups that use this node group\n    node_group_users = node_group_node_groups(node_group_key)\n\n    for world in bpy.data.worlds:\n\n        # if world uses nodes and has a valid node tree\n        if world.use_nodes and world.node_tree:\n            for node in world.node_tree.nodes:\n\n                # if node is a node group and has a valid node tree\n                if hasattr(node, 'node_tree') and node.node_tree:\n\n                    # if this node is our node group\n                    if",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_group_textures(node_group_key):",
            "lineNumber": 628,
            "isSignature": true
          },
          {
            "text": "    # returns a list of texture keys that use this node group in their",
            "lineNumber": 629,
            "isSignature": true
          },
          {
            "text": "    # node trees",
            "lineNumber": 630,
            "isSignature": true
          },
          {
            "lineNumber": 652
          },
          {
            "lineNumber": 653
          },
          {
            "text": "                    # if node is a node group that contains our node group",
            "lineNumber": 654
          },
          {
            "text": "                    if node.node_tree.name in node_group_users:",
            "lineNumber": 655
          },
          {
            "text": "                        users.append(texture.name)",
            "lineNumber": 656
          },
          {
            "lineNumber": 657
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 658,
            "isSignature": true
          },
          {
            "lineNumber": 659
          },
          {
            "lineNumber": 660
          },
          {
            "text": "def node_group_worlds(node_group_key):",
            "lineNumber": 661,
            "isSignature": true
          },
          {
            "text": "    # returns a list of world keys that use the node group in their node",
            "lineNumber": 662,
            "isSignature": true
          },
          {
            "text": "    # trees",
            "lineNumber": 663,
            "isSignature": true
          },
          {
            "lineNumber": 664
          },
          {
            "text": "    users = []",
            "lineNumber": 665
          },
          {
            "text": "    node_group = bpy.data.node_groups[node_group_key]",
            "lineNumber": 666
          },
          {
            "lineNumber": 667
          },
          {
            "text": "    # node groups that use this node group",
            "lineNumber": 668
          },
          {
            "text": "    node_group_users = node_group_node_groups(node_group_key)",
            "lineNumber": 669
          },
          {
            "lineNumber": 670
          },
          {
            "text": "    for world in bpy.data.worlds:",
            "lineNumber": 671
          },
          {
            "lineNumber": 672
          },
          {
            "text": "        # if world uses nodes and has a valid node tree",
            "lineNumber": 673
          },
          {
            "text": "        if world.use_nodes and world.node_tree:",
            "lineNumber": 674
          },
          {
            "text": "            for node in world.node_tree.nodes:",
            "lineNumber": 675
          },
          {
            "lineNumber": 676
          },
          {
            "text": "                # if node is a node group and has a valid node tree",
            "lineNumber": 677
          },
          {
            "text": "                if hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 678
          },
          {
            "lineNumber": 679
          },
          {
            "text": "                    # if this node is our node group",
            "lineNumber": 680
          },
          {
            "text": "                    if",
            "lineNumber": 681
          }
        ]
      },
      "score": 0.3342997133731842
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 346,
            "column": 26
          },
          "endPosition": {
            "line": 403
          }
        },
        "contents": "def image_geometry_nodes(image_key):\n    # returns a list of object keys that use the image through Geometry Nodes\n\n    users = []\n    image = bpy.data.images[image_key]\n\n    # list of node groups that use this image\n    node_group_users = image_node_groups(image_key)\n\n    # Import compat module for version-safe geometry nodes access\n    from ..utils import compat\n\n    for obj in bpy.data.objects:\n        # check Geometry Nodes modifiers\n        if hasattr(obj, 'modifiers'):\n            for modifier in obj.modifiers:\n                if compat.is_geometry_nodes_modifier(modifier):\n                    ng = compat.get_geometry_nodes_modifier_node_group(modifier)\n                    if ng:\n                        # direct usage in the modifier's tree\n                        if node_group_has_image(ng.name, image.name):\n                            users.append(obj.name)\n                        # usage via nested node groups\n                        elif ng.name in node_group_users:\n                            users.append(obj.name)\n\n    return distinct(users)\n\n\ndef image_worlds(image_key):\n    # returns a list of world keys that use the image\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def image_geometry_nodes(image_key):",
            "lineNumber": 350,
            "isSignature": true
          },
          {
            "text": "    # returns a list of object keys that use the image through Geometry Nodes",
            "lineNumber": 351,
            "isSignature": true
          },
          {
            "lineNumber": 352
          },
          {
            "text": "    users = []",
            "lineNumber": 353
          },
          {
            "text": "    image = bpy.data.images[image_key]",
            "lineNumber": 354
          },
          {
            "lineNumber": 355
          },
          {
            "text": "    # list of node groups that use this image",
            "lineNumber": 356
          },
          {
            "text": "    node_group_users = image_node_groups(image_key)",
            "lineNumber": 357
          },
          {
            "lineNumber": 358
          },
          {
            "text": "    # Import compat module for version-safe geometry nodes access",
            "lineNumber": 359
          },
          {
            "text": "    from ..utils import compat",
            "lineNumber": 360
          },
          {
            "lineNumber": 361
          },
          {
            "text": "    for obj in bpy.data.objects:",
            "lineNumber": 362
          },
          {
            "text": "        # check Geometry Nodes modifiers",
            "lineNumber": 363
          },
          {
            "text": "        if hasattr(obj, 'modifiers'):",
            "lineNumber": 364
          },
          {
            "text": "            for modifier in obj.modifiers:",
            "lineNumber": 365
          },
          {
            "text": "                if compat.is_geometry_nodes_modifier(modifier):",
            "lineNumber": 366
          },
          {
            "text": "                    ng = compat.get_geometry_nodes_modifier_node_group(modifier)",
            "lineNumber": 367
          },
          {
            "text": "                    if ng:",
            "lineNumber": 368
          },
          {
            "text": "                        # direct usage in the modifier's tree",
            "lineNumber": 369
          },
          {
            "text": "                        if node_group_has_image(ng.name, image.name):",
            "lineNumber": 370
          },
          {
            "text": "                            users.append(obj.name)",
            "lineNumber": 371
          },
          {
            "text": "                        # usage via nested node groups",
            "lineNumber": 372
          },
          {
            "text": "                        elif ng.name in node_group_users:",
            "lineNumber": 373
          },
          {
            "text": "                            users.append(obj.name)",
            "lineNumber": 374
          },
          {
            "lineNumber": 375
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 376,
            "isSignature": true
          },
          {
            "lineNumber": 377
          },
          {
            "lineNumber": 378
          },
          {
            "text": "def image_worlds(image_key):",
            "lineNumber": 379,
            "isSignature": true
          },
          {
            "text": "    # returns a list of world keys that use the image",
            "lineNumber": 380,
            "isSignature": true
          },
          {
            "lineNumber": 381
          },
          {
            "text": "    ",
            "lineNumber": 382
          }
        ]
      },
      "score": 0.3283148407936096
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 252,
            "column": 26
          },
          "endPosition": {
            "line": 302
          }
        },
        "contents": "def image_materials(image_key):\n    # returns a list of material keys that use the image\n\n    users = []\n    image = bpy.data.images[image_key]\n\n    # list of node groups that use this image\n    node_group_users = image_node_groups(image_key)\n\n    for mat in bpy.data.materials:\n\n        # if material uses a valid node tree, check each node\n        if mat.use_nodes and mat.node_tree:\n            for node in mat.node_tree.nodes:\n\n                # if node is has a not none image attribute\n                if hasattr(node, 'image') and node.image:\n\n                    # if the nodes image is our image\n                    if node.image.name == image.name:\n                        users.append(mat.name)\n\n                # if image in node in node group in node tree\n                elif node.type == 'GROUP':\n\n                    # if node group has a valid node tree and is in our\n                    # list of node groups that use this image\n                    if node.node_tree and \\\n                            node.node_tree.name in node_group_users:\n                        users.append(mat.name)\n\n    return distinct(users)\n\n\ndef image_node_groups(image_key):\n    # returns a list of keys of node groups that use this image\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def image_materials(image_key):",
            "lineNumber": 256,
            "isSignature": true
          },
          {
            "text": "    # returns a list of material keys that use the image",
            "lineNumber": 257,
            "isSignature": true
          },
          {
            "lineNumber": 258
          },
          {
            "text": "    users = []",
            "lineNumber": 259
          },
          {
            "text": "    image = bpy.data.images[image_key]",
            "lineNumber": 260
          },
          {
            "lineNumber": 261
          },
          {
            "text": "    # list of node groups that use this image",
            "lineNumber": 262
          },
          {
            "text": "    node_group_users = image_node_groups(image_key)",
            "lineNumber": 263
          },
          {
            "lineNumber": 264
          },
          {
            "text": "    for mat in bpy.data.materials:",
            "lineNumber": 265
          },
          {
            "lineNumber": 266
          },
          {
            "text": "        # if material uses a valid node tree, check each node",
            "lineNumber": 267
          },
          {
            "text": "        if mat.use_nodes and mat.node_tree:",
            "lineNumber": 268
          },
          {
            "text": "            for node in mat.node_tree.nodes:",
            "lineNumber": 269
          },
          {
            "lineNumber": 270
          },
          {
            "text": "                # if node is has a not none image attribute",
            "lineNumber": 271
          },
          {
            "text": "                if hasattr(node, 'image') and node.image:",
            "lineNumber": 272
          },
          {
            "lineNumber": 273
          },
          {
            "text": "                    # if the nodes image is our image",
            "lineNumber": 274
          },
          {
            "text": "                    if node.image.name == image.name:",
            "lineNumber": 275
          },
          {
            "text": "                        users.append(mat.name)",
            "lineNumber": 276
          },
          {
            "lineNumber": 277
          },
          {
            "text": "                # if image in node in node group in node tree",
            "lineNumber": 278
          },
          {
            "text": "                elif node.type == 'GROUP':",
            "lineNumber": 279
          },
          {
            "lineNumber": 280
          },
          {
            "text": "                    # if node group has a valid node tree and is in our",
            "lineNumber": 281
          },
          {
            "text": "                    # list of node groups that use this image",
            "lineNumber": 282
          },
          {
            "text": "                    if node.node_tree and \\",
            "lineNumber": 283
          },
          {
            "text": "                            node.node_tree.name in node_group_users:",
            "lineNumber": 284
          },
          {
            "text": "                        users.append(mat.name)",
            "lineNumber": 285
          },
          {
            "lineNumber": 286
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 287,
            "isSignature": true
          },
          {
            "lineNumber": 288
          },
          {
            "lineNumber": 289
          },
          {
            "text": "def image_node_groups(image_key):",
            "lineNumber": 290,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of node groups that use this image",
            "lineNumber": 291,
            "isSignature": true
          },
          {
            "lineNumber": 292
          },
          {
            "text": "    ",
            "lineNumber": 293
          }
        ]
      },
      "score": 0.3006124496459961
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 454
          },
          "endPosition": {
            "line": 508,
            "column": 26
          }
        },
        "contents": "def material_node_groups(material_key):\n    # returns a list of keys indicating where the material is used via node groups\n    # This checks if the material is used in any node group, and if that node group\n    # is itself used anywhere. This is a fallback for cases where material_geometry_nodes()\n    # might miss usage (e.g., node groups used in materials, other node groups, etc.)\n\n                    if hasattr(node, 'node_tree') and node.node_tree:\n                        if node.node_tree.name == node_group.name:\n                            # This node group is used by another node group\n                            # Check if that other node group is used (recursive)\n                            other_ng_users = node_group_all(other_ng.name)\n                            if other_ng_users:\n                                users.extend(other_ng_users)\n                            break\n            \n            # If we found any users, the material is used\n            if users:\n                return distinct(users)\n\n    return distinct(users)",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def material_node_groups(material_key):",
            "lineNumber": 455,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys indicating where the material is used via node groups",
            "lineNumber": 456,
            "isSignature": true
          },
          {
            "text": "    # This checks if the material is used in any node group, and if that node group",
            "lineNumber": 457,
            "isSignature": true
          },
          {
            "text": "    # is itself used anywhere. This is a fallback for cases where material_geometry_nodes()",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "    # might miss usage (e.g., node groups used in materials, other node groups, etc.)",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "lineNumber": 495
          },
          {
            "text": "                    if hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 496
          },
          {
            "text": "                        if node.node_tree.name == node_group.name:",
            "lineNumber": 497
          },
          {
            "text": "                            # This node group is used by another node group",
            "lineNumber": 498
          },
          {
            "text": "                            # Check if that other node group is used (recursive)",
            "lineNumber": 499
          },
          {
            "text": "                            other_ng_users = node_group_all(other_ng.name)",
            "lineNumber": 500
          },
          {
            "text": "                            if other_ng_users:",
            "lineNumber": 501
          },
          {
            "text": "                                users.extend(other_ng_users)",
            "lineNumber": 502
          },
          {
            "text": "                            break",
            "lineNumber": 503
          },
          {
            "text": "            ",
            "lineNumber": 504
          },
          {
            "text": "            # If we found any users, the material is used",
            "lineNumber": 505
          },
          {
            "text": "            if users:",
            "lineNumber": 506
          },
          {
            "text": "                return distinct(users)",
            "lineNumber": 507
          },
          {
            "lineNumber": 508
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 509,
            "isSignature": true
          }
        ]
      },
      "score": 0.27393293380737305
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 544
          },
          "endPosition": {
            "line": 606
          }
        },
        "contents": "def node_group_compositors(node_group_key):\n    # returns a list containing \"Compositor\" if the node group is used in\n    # the scene's compositor\n\n\n                    # if the node group is in our list of node group users\n                    if node.node_tree.name in node_group_users:\n                        users.append(\"Compositor\")\n\n    return distinct(users)\n\n\ndef node_group_materials(node_group_key):\n    # returns a list of material keys that use the node group in their\n    # node trees\n\n    users = []\n    node_group = bpy.data.node_groups[node_group_key]\n\n    # node groups that use this node group\n    node_group_users = node_group_node_groups(node_group_key)\n\n    for material in bpy.data.materials:\n\n        # if material uses nodes and has a valid node tree, check each node",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_group_compositors(node_group_key):",
            "lineNumber": 545,
            "isSignature": true
          },
          {
            "text": "    # returns a list containing \"Compositor\" if the node group is used in",
            "lineNumber": 546,
            "isSignature": true
          },
          {
            "text": "    # the scene's compositor",
            "lineNumber": 547,
            "isSignature": true
          },
          {
            "lineNumber": 571
          },
          {
            "lineNumber": 572
          },
          {
            "text": "                    # if the node group is in our list of node group users",
            "lineNumber": 573
          },
          {
            "text": "                    if node.node_tree.name in node_group_users:",
            "lineNumber": 574
          },
          {
            "text": "                        users.append(\"Compositor\")",
            "lineNumber": 575
          },
          {
            "lineNumber": 576
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 577,
            "isSignature": true
          },
          {
            "lineNumber": 578
          },
          {
            "lineNumber": 579
          },
          {
            "text": "def node_group_materials(node_group_key):",
            "lineNumber": 580,
            "isSignature": true
          },
          {
            "text": "    # returns a list of material keys that use the node group in their",
            "lineNumber": 581,
            "isSignature": true
          },
          {
            "text": "    # node trees",
            "lineNumber": 582,
            "isSignature": true
          },
          {
            "lineNumber": 583
          },
          {
            "text": "    users = []",
            "lineNumber": 584
          },
          {
            "text": "    node_group = bpy.data.node_groups[node_group_key]",
            "lineNumber": 585
          },
          {
            "lineNumber": 586
          },
          {
            "text": "    # node groups that use this node group",
            "lineNumber": 587
          },
          {
            "text": "    node_group_users = node_group_node_groups(node_group_key)",
            "lineNumber": 588
          },
          {
            "lineNumber": 589
          },
          {
            "text": "    for material in bpy.data.materials:",
            "lineNumber": 590
          },
          {
            "lineNumber": 591
          },
          {
            "text": "        # if material uses nodes and has a valid node tree, check each node",
            "lineNumber": 592
          }
        ]
      },
      "score": 0.27359500527381897
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 454
          },
          "endPosition": {
            "line": 576
          }
        },
        "contents": "def material_node_groups(material_key):\n    # returns a list of keys indicating where the material is used via node groups\n    # This checks if the material is used in any node group, and if that node group\n    # is itself used anywhere. This is a fallback for cases where material_geometry_nodes()\n    # might miss usage (e.g., node groups used in materials, other node groups, etc.)\n users:\n                return distinct(users)\n\n    return distinct(users)\n\n\ndef material_objects(material_key):\n    # returns a list of object keys that use this material\n\n    users = []\n    material = bpy.data.materials[material_key]\n\n    for obj in bpy.data.objects:\n\n        # if the object has the option to add materials\n        if hasattr(obj, 'material_slots'):\n\n            # for each material slot\n            for slot in obj.material_slots:\n\n                # if material slot has a valid material and it is our\n                # material\n                if slot.material and slot.material.name == material.name:\n                    users.append(obj.name)\n\n    return distinct(users)\n\n\ndef node_group_all(node_group_key):\n    # returns a list of keys of every data-block that uses this node group\n\n    return node_group_compositors(node_group_key) + \\\n           node_group_materials(node_group_key) + \\\n           node_group_node_groups(node_group_key) + \\\n           node_group_textures(node_group_key) + \\\n           node_group_worlds(node_group_key) + \\\n           node_group_objects(node_group_key)\n\n\ndef node_group_compositors(node_group_key):\n    # returns a list containing \"Compositor\" if the node group is used in\n    # the scene's compositor\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def material_node_groups(material_key):",
            "lineNumber": 455,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys indicating where the material is used via node groups",
            "lineNumber": 456,
            "isSignature": true
          },
          {
            "text": "    # This checks if the material is used in any node group, and if that node group",
            "lineNumber": 457,
            "isSignature": true
          },
          {
            "text": "    # is itself used anywhere. This is a fallback for cases where material_geometry_nodes()",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "    # might miss usage (e.g., node groups used in materials, other node groups, etc.)",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "text": " users:",
            "lineNumber": 506
          },
          {
            "text": "                return distinct(users)",
            "lineNumber": 507
          },
          {
            "lineNumber": 508
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 509,
            "isSignature": true
          },
          {
            "lineNumber": 510
          },
          {
            "lineNumber": 511
          },
          {
            "text": "def material_objects(material_key):",
            "lineNumber": 512,
            "isSignature": true
          },
          {
            "text": "    # returns a list of object keys that use this material",
            "lineNumber": 513,
            "isSignature": true
          },
          {
            "lineNumber": 514
          },
          {
            "text": "    users = []",
            "lineNumber": 515
          },
          {
            "text": "    material = bpy.data.materials[material_key]",
            "lineNumber": 516
          },
          {
            "lineNumber": 517
          },
          {
            "text": "    for obj in bpy.data.objects:",
            "lineNumber": 518
          },
          {
            "lineNumber": 519
          },
          {
            "text": "        # if the object has the option to add materials",
            "lineNumber": 520
          },
          {
            "text": "        if hasattr(obj, 'material_slots'):",
            "lineNumber": 521
          },
          {
            "lineNumber": 522
          },
          {
            "text": "            # for each material slot",
            "lineNumber": 523
          },
          {
            "text": "            for slot in obj.material_slots:",
            "lineNumber": 524
          },
          {
            "lineNumber": 525
          },
          {
            "text": "                # if material slot has a valid material and it is our",
            "lineNumber": 526
          },
          {
            "text": "                # material",
            "lineNumber": 527
          },
          {
            "text": "                if slot.material and slot.material.name == material.name:",
            "lineNumber": 528
          },
          {
            "text": "                    users.append(obj.name)",
            "lineNumber": 529
          },
          {
            "lineNumber": 530
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 531,
            "isSignature": true
          },
          {
            "lineNumber": 532
          },
          {
            "lineNumber": 533
          },
          {
            "text": "def node_group_all(node_group_key):",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of every data-block that uses this node group",
            "lineNumber": 535,
            "isSignature": true
          },
          {
            "lineNumber": 536
          },
          {
            "text": "    return node_group_compositors(node_group_key) + \\",
            "lineNumber": 537
          },
          {
            "text": "           node_group_materials(node_group_key) + \\",
            "lineNumber": 538
          },
          {
            "text": "           node_group_node_groups(node_group_key) + \\",
            "lineNumber": 539
          },
          {
            "text": "           node_group_textures(node_group_key) + \\",
            "lineNumber": 540
          },
          {
            "text": "           node_group_worlds(node_group_key) + \\",
            "lineNumber": 541
          },
          {
            "text": "           node_group_objects(node_group_key)",
            "lineNumber": 542,
            "isSignature": true
          },
          {
            "lineNumber": 543
          },
          {
            "lineNumber": 544
          },
          {
            "text": "def node_group_compositors(node_group_key):",
            "lineNumber": 545,
            "isSignature": true
          },
          {
            "text": "    # returns a list containing \"Compositor\" if the node group is used in",
            "lineNumber": 546,
            "isSignature": true
          },
          {
            "text": "    # the scene's compositor",
            "lineNumber": 547,
            "isSignature": true
          },
          {
            "lineNumber": 548
          },
          {
            "text": "    ",
            "lineNumber": 549
          }
        ]
      },
      "score": 0.26933470368385315
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 609
          },
          "endPosition": {
            "line": 657
          }
        },
        "contents": "def node_group_node_groups(node_group_key):\n    # returns a list of all node groups that use this node group in\n    # their node tree\n:\n            users.append(search_group.name)\n\n    return distinct(users)\n\n\ndef node_group_textures(node_group_key):\n    # returns a list of texture keys that use this node group in their\n    # node trees\n\n    if not hasattr(bpy.data, 'textures'):\n        return []\n\n    users = []\n    node_group = bpy.data.node_groups[node_group_key]\n\n    # list of node groups that use this node group\n    node_group_users = node_group_node_groups(node_group_key)\n\n    for texture in bpy.data.textures:\n\n        # if texture uses a valid node tree, check each node\n        if texture.use_nodes and texture.node_tree:\n            for node in texture.node_tree.nodes:\n\n                # check if node is a node group and has a valid node tree\n                if hasattr(node, 'node_tree') and node.node_tree:\n\n                    # if node is our node group\n                    if node.node_tree.name == node_group.name:\n                        users.append(texture.name)\n\n                    # if node is a node group that contains our node group\n                    if",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_group_node_groups(node_group_key):",
            "lineNumber": 610,
            "isSignature": true
          },
          {
            "text": "    # returns a list of all node groups that use this node group in",
            "lineNumber": 611,
            "isSignature": true
          },
          {
            "text": "    # their node tree",
            "lineNumber": 612,
            "isSignature": true
          },
          {
            "text": ":",
            "lineNumber": 622
          },
          {
            "text": "            users.append(search_group.name)",
            "lineNumber": 623
          },
          {
            "lineNumber": 624
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 625,
            "isSignature": true
          },
          {
            "lineNumber": 626
          },
          {
            "lineNumber": 627
          },
          {
            "text": "def node_group_textures(node_group_key):",
            "lineNumber": 628,
            "isSignature": true
          },
          {
            "text": "    # returns a list of texture keys that use this node group in their",
            "lineNumber": 629,
            "isSignature": true
          },
          {
            "text": "    # node trees",
            "lineNumber": 630,
            "isSignature": true
          },
          {
            "lineNumber": 631
          },
          {
            "text": "    if not hasattr(bpy.data, 'textures'):",
            "lineNumber": 632
          },
          {
            "text": "        return []",
            "lineNumber": 633
          },
          {
            "lineNumber": 634
          },
          {
            "text": "    users = []",
            "lineNumber": 635
          },
          {
            "text": "    node_group = bpy.data.node_groups[node_group_key]",
            "lineNumber": 636
          },
          {
            "lineNumber": 637
          },
          {
            "text": "    # list of node groups that use this node group",
            "lineNumber": 638
          },
          {
            "text": "    node_group_users = node_group_node_groups(node_group_key)",
            "lineNumber": 639
          },
          {
            "lineNumber": 640
          },
          {
            "text": "    for texture in bpy.data.textures:",
            "lineNumber": 641
          },
          {
            "lineNumber": 642
          },
          {
            "text": "        # if texture uses a valid node tree, check each node",
            "lineNumber": 643
          },
          {
            "text": "        if texture.use_nodes and texture.node_tree:",
            "lineNumber": 644
          },
          {
            "text": "            for node in texture.node_tree.nodes:",
            "lineNumber": 645
          },
          {
            "lineNumber": 646
          },
          {
            "text": "                # check if node is a node group and has a valid node tree",
            "lineNumber": 647
          },
          {
            "text": "                if hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 648
          },
          {
            "lineNumber": 649
          },
          {
            "text": "                    # if node is our node group",
            "lineNumber": 650
          },
          {
            "text": "                    if node.node_tree.name == node_group.name:",
            "lineNumber": 651
          },
          {
            "text": "                        users.append(texture.name)",
            "lineNumber": 652
          },
          {
            "lineNumber": 653
          },
          {
            "text": "                    # if node is a node group that contains our node group",
            "lineNumber": 654
          },
          {
            "text": "                    if",
            "lineNumber": 655
          }
        ]
      },
      "score": 0.258154034614563
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 579
          },
          "endPosition": {
            "line": 624,
            "column": 26
          }
        },
        "contents": "def node_group_materials(node_group_key):\n    # returns a list of material keys that use the node group in their\n    # node trees\n\n\n    for material in bpy.data.materials:\n\n        # if material uses nodes and has a valid node tree, check each node\n        if material.use_nodes and material.node_tree:\n            for node in material.node_tree.nodes:\n\n                # if node is a group node\n                if hasattr(node, 'node_tree') and node.node_tree:\n\n                    # if node is the node group\n                    if node.node_tree.name == node_group.name:\n                        users.append(material.name)\n\n                    # if node is using a node group contains our node group\n                    if node.node_tree.name in node_group_users:\n                        users.append(material.name)\n\n    return distinct(users)\n\n\ndef node_group_node_groups(node_group_key):\n    # returns a list of all node groups that use this node group in\n    # their node tree\n\n    users = []\n    node_group = bpy.data.node_groups[node_group_key]\n\n    # for each search group\n    for search_group in bpy.data.node_groups:\n\n        # if the search group contains our node group\n        if node_group_has_node_group(\n                search_group.name, node_group.name):\n            users.append(search_group.name)\n\n    return distinct(users)",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_group_materials(node_group_key):",
            "lineNumber": 580,
            "isSignature": true
          },
          {
            "text": "    # returns a list of material keys that use the node group in their",
            "lineNumber": 581,
            "isSignature": true
          },
          {
            "text": "    # node trees",
            "lineNumber": 582,
            "isSignature": true
          },
          {
            "lineNumber": 588
          },
          {
            "lineNumber": 589
          },
          {
            "text": "    for material in bpy.data.materials:",
            "lineNumber": 590
          },
          {
            "lineNumber": 591
          },
          {
            "text": "        # if material uses nodes and has a valid node tree, check each node",
            "lineNumber": 592
          },
          {
            "text": "        if material.use_nodes and material.node_tree:",
            "lineNumber": 593
          },
          {
            "text": "            for node in material.node_tree.nodes:",
            "lineNumber": 594
          },
          {
            "lineNumber": 595
          },
          {
            "text": "                # if node is a group node",
            "lineNumber": 596
          },
          {
            "text": "                if hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 597
          },
          {
            "lineNumber": 598
          },
          {
            "text": "                    # if node is the node group",
            "lineNumber": 599
          },
          {
            "text": "                    if node.node_tree.name == node_group.name:",
            "lineNumber": 600
          },
          {
            "text": "                        users.append(material.name)",
            "lineNumber": 601
          },
          {
            "lineNumber": 602
          },
          {
            "text": "                    # if node is using a node group contains our node group",
            "lineNumber": 603
          },
          {
            "text": "                    if node.node_tree.name in node_group_users:",
            "lineNumber": 604
          },
          {
            "text": "                        users.append(material.name)",
            "lineNumber": 605
          },
          {
            "lineNumber": 606
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 607,
            "isSignature": true
          },
          {
            "lineNumber": 608
          },
          {
            "lineNumber": 609
          },
          {
            "text": "def node_group_node_groups(node_group_key):",
            "lineNumber": 610,
            "isSignature": true
          },
          {
            "text": "    # returns a list of all node groups that use this node group in",
            "lineNumber": 611,
            "isSignature": true
          },
          {
            "text": "    # their node tree",
            "lineNumber": 612,
            "isSignature": true
          },
          {
            "lineNumber": 613
          },
          {
            "text": "    users = []",
            "lineNumber": 614
          },
          {
            "text": "    node_group = bpy.data.node_groups[node_group_key]",
            "lineNumber": 615
          },
          {
            "lineNumber": 616
          },
          {
            "text": "    # for each search group",
            "lineNumber": 617
          },
          {
            "text": "    for search_group in bpy.data.node_groups:",
            "lineNumber": 618
          },
          {
            "lineNumber": 619
          },
          {
            "text": "        # if the search group contains our node group",
            "lineNumber": 620
          },
          {
            "text": "        if node_group_has_node_group(",
            "lineNumber": 621
          },
          {
            "text": "                search_group.name, node_group.name):",
            "lineNumber": 622
          },
          {
            "text": "            users.append(search_group.name)",
            "lineNumber": 623
          },
          {
            "lineNumber": 624
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 625,
            "isSignature": true
          }
        ]
      },
      "score": 0.25781726837158203
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 939,
            "column": 26
          },
          "endPosition": {
            "line": 981
          }
        },
        "contents": "def texture_objects(texture_key):\n    # returns a list of object keys that use the texture in one of their\n    # modifiers\n\n    if not hasattr(bpy.data, 'textures'):\n        return []\n\n    users = []\n    texture = bpy.data.textures[texture_key]\n\n    # list of particle systems that use our texture\n    particle_users = texture_particles(texture_key)\n\n    # append objects that use the texture in a modifier\n    for obj in bpy.data.objects:\n\n        # if object can have modifiers applied to it\n        if hasattr(obj, 'modifiers'):\n            for modifier in obj.modifiers:\n\n                # if the modifier has a texture attribute that is not None\n                if hasattr(modifier, 'texture') \\\n                        and modifier.texture:\n                    if modifier.texture.name == texture.name:\n                        users.append(obj.name)\n\n                # if the modifier has a mask_texture attribute that is",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def texture_objects(texture_key):",
            "lineNumber": 943,
            "isSignature": true
          },
          {
            "text": "    # returns a list of object keys that use the texture in one of their",
            "lineNumber": 944,
            "isSignature": true
          },
          {
            "text": "    # modifiers",
            "lineNumber": 945,
            "isSignature": true
          },
          {
            "lineNumber": 946
          },
          {
            "text": "    if not hasattr(bpy.data, 'textures'):",
            "lineNumber": 947
          },
          {
            "text": "        return []",
            "lineNumber": 948
          },
          {
            "lineNumber": 949
          },
          {
            "text": "    users = []",
            "lineNumber": 950
          },
          {
            "text": "    texture = bpy.data.textures[texture_key]",
            "lineNumber": 951
          },
          {
            "lineNumber": 952
          },
          {
            "text": "    # list of particle systems that use our texture",
            "lineNumber": 953
          },
          {
            "text": "    particle_users = texture_particles(texture_key)",
            "lineNumber": 954
          },
          {
            "lineNumber": 955
          },
          {
            "text": "    # append objects that use the texture in a modifier",
            "lineNumber": 956
          },
          {
            "text": "    for obj in bpy.data.objects:",
            "lineNumber": 957
          },
          {
            "lineNumber": 958
          },
          {
            "text": "        # if object can have modifiers applied to it",
            "lineNumber": 959
          },
          {
            "text": "        if hasattr(obj, 'modifiers'):",
            "lineNumber": 960
          },
          {
            "text": "            for modifier in obj.modifiers:",
            "lineNumber": 961
          },
          {
            "lineNumber": 962
          },
          {
            "text": "                # if the modifier has a texture attribute that is not None",
            "lineNumber": 963
          },
          {
            "text": "                if hasattr(modifier, 'texture') \\",
            "lineNumber": 964
          },
          {
            "text": "                        and modifier.texture:",
            "lineNumber": 965
          },
          {
            "text": "                    if modifier.texture.name == texture.name:",
            "lineNumber": 966
          },
          {
            "text": "                        users.append(obj.name)",
            "lineNumber": 967
          },
          {
            "lineNumber": 968
          },
          {
            "text": "                # if the modifier has a mask_texture attribute that is",
            "lineNumber": 969
          }
        ]
      },
      "score": 0.2559612989425659
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 423,
            "column": 26
          },
          "endPosition": {
            "line": 451
          }
        },
        "contents": "def material_all(material_key):\n    # returns a list of keys of every data-block that uses this material\n    return material_objects(material_key) + \\\n           material_geometry_nodes(material_key) + \\\n           material_node_groups(material_key)\n\n\ndef material_geometry_nodes(material_key):\n    # returns a list of object keys that use the material via Geometry Nodes\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def material_all(material_key):",
            "lineNumber": 427,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of every data-block that uses this material",
            "lineNumber": 428,
            "isSignature": true
          },
          {
            "text": "    return material_objects(material_key) + \\",
            "lineNumber": 429
          },
          {
            "text": "           material_geometry_nodes(material_key) + \\",
            "lineNumber": 430
          },
          {
            "text": "           material_node_groups(material_key)",
            "lineNumber": 431,
            "isSignature": true
          },
          {
            "lineNumber": 432
          },
          {
            "lineNumber": 433
          },
          {
            "text": "def material_geometry_nodes(material_key):",
            "lineNumber": 434,
            "isSignature": true
          },
          {
            "text": "    # returns a list of object keys that use the material via Geometry Nodes",
            "lineNumber": 435,
            "isSignature": true
          },
          {
            "lineNumber": 436
          },
          {
            "text": "    ",
            "lineNumber": 437
          }
        ]
      },
      "score": 0.25225409865379333
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 103,
            "column": 16
          },
          "endPosition": {
            "line": 117,
            "column": 16
          }
        },
        "contents": "def _has_any_unused_textures():\n    \"\"\"Check if there are any unused textures (short-circuits early).\"\"\"\n    if not hasattr(bpy.data, 'textures'):\n        return False\n    \n    for texture in bpy.data.textures:\n        if compat.is_library_or_override(texture):\n            continue\n        if not users.texture_all(texture.name):\n            if not texture.use_fake_user or config.include_fake_users:\n                return True\n    return False",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _has_any_unused_textures():",
            "lineNumber": 107,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check if there are any unused textures (short-circuits early).\"\"\"",
            "lineNumber": 108
          },
          {
            "text": "    if not hasattr(bpy.data, 'textures'):",
            "lineNumber": 109
          },
          {
            "text": "        return False",
            "lineNumber": 110
          },
          {
            "text": "    ",
            "lineNumber": 111
          },
          {
            "text": "    for texture in bpy.data.textures:",
            "lineNumber": 112
          },
          {
            "text": "        if compat.is_library_or_override(texture):",
            "lineNumber": 113
          },
          {
            "text": "            continue",
            "lineNumber": 114
          },
          {
            "text": "        if not users.texture_all(texture.name):",
            "lineNumber": 115
          },
          {
            "text": "            if not texture.use_fake_user or config.include_fake_users:",
            "lineNumber": 116
          },
          {
            "text": "                return True",
            "lineNumber": 117
          },
          {
            "text": "    return False",
            "lineNumber": 118,
            "isSignature": true
          }
        ]
      },
      "score": 0.240801602602005
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unnamed.py",
        "range": {
          "startPosition": {
            "line": 174,
            "column": 18
          },
          "endPosition": {
            "line": 204
          }
        },
        "contents": "def node_groups():\n    # returns the keys of all unnamed node groups in the project\n    unnamed = []\n\n    for node_group in bpy.data.node_groups:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(node_group):\n            continue\n        if re.match(r'.*\\.\\d\\d\\d$', node_group.name) or \\\n                node_group.name.startswith(\"NodeGroup\"):\n            unnamed.append(node_group.name)\n\n    return unnamed\n\n\ndef particles():\n    # returns the keys of all unnamed particle systems in the project\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_groups():",
            "lineNumber": 178,
            "isSignature": true
          },
          {
            "text": "    # returns the keys of all unnamed node groups in the project",
            "lineNumber": 179,
            "isSignature": true
          },
          {
            "text": "    unnamed = []",
            "lineNumber": 180
          },
          {
            "lineNumber": 181
          },
          {
            "text": "    for node_group in bpy.data.node_groups:",
            "lineNumber": 182
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 183
          },
          {
            "text": "        if compat.is_library_or_override(node_group):",
            "lineNumber": 184
          },
          {
            "text": "            continue",
            "lineNumber": 185
          },
          {
            "text": "        if re.match(r'.*\\.\\d\\d\\d$', node_group.name) or \\",
            "lineNumber": 186
          },
          {
            "text": "                node_group.name.startswith(\"NodeGroup\"):",
            "lineNumber": 187
          },
          {
            "text": "            unnamed.append(node_group.name)",
            "lineNumber": 188
          },
          {
            "lineNumber": 189
          },
          {
            "text": "    return unnamed",
            "lineNumber": 190,
            "isSignature": true
          },
          {
            "lineNumber": 191
          },
          {
            "lineNumber": 192
          },
          {
            "text": "def particles():",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "text": "    # returns the keys of all unnamed particle systems in the project",
            "lineNumber": 194,
            "isSignature": true
          },
          {
            "text": "    ",
            "lineNumber": 195
          }
        ]
      },
      "score": 0.2271147072315216
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused.py",
        "range": {
          "startPosition": {
            "line": 176,
            "column": 38
          },
          "endPosition": {
            "line": 202,
            "column": 4
          }
        },
        "contents": "def node_groups_deep():\n    # returns a list of keys of unused node_groups\n\n    unused = []\n\n    for node_group in bpy.data.node_groups:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(node_group):\n            continue\n        if not users.node_group_all(node_group.name):\n\n            # check if node group has a fake user or if ignore fake users\n            # is enabled\n            if not node_group.use_fake_user or config.include_fake_users:\n                unused.append(node_group.name)\n\n    return unused\n\n\ndef node_groups_shallow():\n    # returns a list of keys of unused node groups that may be\n    # incomplete, but is significantly faster than doing a deep search\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def node_groups_deep():",
            "lineNumber": 180,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused node_groups",
            "lineNumber": 181,
            "isSignature": true
          },
          {
            "lineNumber": 182
          },
          {
            "text": "    unused = []",
            "lineNumber": 183
          },
          {
            "lineNumber": 184
          },
          {
            "text": "    for node_group in bpy.data.node_groups:",
            "lineNumber": 185
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 186
          },
          {
            "text": "        if compat.is_library_or_override(node_group):",
            "lineNumber": 187
          },
          {
            "text": "            continue",
            "lineNumber": 188
          },
          {
            "text": "        if not users.node_group_all(node_group.name):",
            "lineNumber": 189
          },
          {
            "lineNumber": 190
          },
          {
            "text": "            # check if node group has a fake user or if ignore fake users",
            "lineNumber": 191
          },
          {
            "text": "            # is enabled",
            "lineNumber": 192
          },
          {
            "text": "            if not node_group.use_fake_user or config.include_fake_users:",
            "lineNumber": 193
          },
          {
            "text": "                unused.append(node_group.name)",
            "lineNumber": 194
          },
          {
            "lineNumber": 195
          },
          {
            "text": "    return unused",
            "lineNumber": 196,
            "isSignature": true
          },
          {
            "lineNumber": 197
          },
          {
            "lineNumber": 198
          },
          {
            "text": "def node_groups_shallow():",
            "lineNumber": 199,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of unused node groups that may be",
            "lineNumber": 200,
            "isSignature": true
          },
          {
            "text": "    # incomplete, but is significantly faster than doing a deep search",
            "lineNumber": 201,
            "isSignature": true
          },
          {
            "lineNumber": 202
          },
          {
            "text": "    ",
            "lineNumber": 203,
            "isSignature": true
          }
        ]
      },
      "score": 0.21873503923416138
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 847
          },
          "endPosition": {
            "line": 939
          }
        },
        "contents": "def particle_objects(particle_key):\n    # returns a list of object keys that use the particle system\n obj.particle_systems:\n\n                # if particle settings is our particle system\n                if particle.settings.name == particle_system.name:\n                    users.append(obj.name)\n\n    return distinct(users)\n\n\ndef texture_all(texture_key):\n    # returns a list of keys of every data-block that uses this texture\n\n    return texture_brushes(texture_key) + \\\n           texture_compositor(texture_key) + \\\n           texture_objects(texture_key) + \\\n           texture_node_groups(texture_key) + \\\n           texture_particles(texture_key)\n\n\ndef texture_brushes(texture_key):\n    # returns a list of brush keys that use the texture\n\n    if not hasattr(bpy.data, 'textures'):\n        return []\n\n    users = []\n    texture = bpy.data.textures[texture_key]\n\n    for brush in bpy.data.brushes:\n\n        # if brush has a texture\n        if brush.texture:\n\n            # if brush texture is our texture\n            if brush.texture.name == texture.name:\n                users.append(brush.name)\n\n    return distinct(users)\n\n\ndef texture_compositor(texture_key):\n    # returns a list containing \"Compositor\" if the texture is used in\n    # the scene's compositor\n\n    if not hasattr(bpy.data, 'textures'):\n        return []\n\n    users = []",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def particle_objects(particle_key):",
            "lineNumber": 848,
            "isSignature": true
          },
          {
            "text": "    # returns a list of object keys that use the particle system",
            "lineNumber": 849,
            "isSignature": true
          },
          {
            "text": " obj.particle_systems:",
            "lineNumber": 861
          },
          {
            "lineNumber": 862
          },
          {
            "text": "                # if particle settings is our particle system",
            "lineNumber": 863
          },
          {
            "text": "                if particle.settings.name == particle_system.name:",
            "lineNumber": 864
          },
          {
            "text": "                    users.append(obj.name)",
            "lineNumber": 865
          },
          {
            "lineNumber": 866
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 867,
            "isSignature": true
          },
          {
            "lineNumber": 868
          },
          {
            "lineNumber": 869
          },
          {
            "text": "def texture_all(texture_key):",
            "lineNumber": 870,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of every data-block that uses this texture",
            "lineNumber": 871,
            "isSignature": true
          },
          {
            "lineNumber": 872
          },
          {
            "text": "    return texture_brushes(texture_key) + \\",
            "lineNumber": 873
          },
          {
            "text": "           texture_compositor(texture_key) + \\",
            "lineNumber": 874
          },
          {
            "text": "           texture_objects(texture_key) + \\",
            "lineNumber": 875
          },
          {
            "text": "           texture_node_groups(texture_key) + \\",
            "lineNumber": 876
          },
          {
            "text": "           texture_particles(texture_key)",
            "lineNumber": 877,
            "isSignature": true
          },
          {
            "lineNumber": 878
          },
          {
            "lineNumber": 879
          },
          {
            "text": "def texture_brushes(texture_key):",
            "lineNumber": 880,
            "isSignature": true
          },
          {
            "text": "    # returns a list of brush keys that use the texture",
            "lineNumber": 881,
            "isSignature": true
          },
          {
            "lineNumber": 882
          },
          {
            "text": "    if not hasattr(bpy.data, 'textures'):",
            "lineNumber": 883
          },
          {
            "text": "        return []",
            "lineNumber": 884
          },
          {
            "lineNumber": 885
          },
          {
            "text": "    users = []",
            "lineNumber": 886
          },
          {
            "text": "    texture = bpy.data.textures[texture_key]",
            "lineNumber": 887
          },
          {
            "lineNumber": 888
          },
          {
            "text": "    for brush in bpy.data.brushes:",
            "lineNumber": 889
          },
          {
            "lineNumber": 890
          },
          {
            "text": "        # if brush has a texture",
            "lineNumber": 891
          },
          {
            "text": "        if brush.texture:",
            "lineNumber": 892
          },
          {
            "lineNumber": 893
          },
          {
            "text": "            # if brush texture is our texture",
            "lineNumber": 894
          },
          {
            "text": "            if brush.texture.name == texture.name:",
            "lineNumber": 895
          },
          {
            "text": "                users.append(brush.name)",
            "lineNumber": 896
          },
          {
            "lineNumber": 897
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 898,
            "isSignature": true
          },
          {
            "lineNumber": 899
          },
          {
            "lineNumber": 900
          },
          {
            "text": "def texture_compositor(texture_key):",
            "lineNumber": 901,
            "isSignature": true
          },
          {
            "text": "    # returns a list containing \"Compositor\" if the texture is used in",
            "lineNumber": 902,
            "isSignature": true
          },
          {
            "text": "    # the scene's compositor",
            "lineNumber": 903,
            "isSignature": true
          },
          {
            "lineNumber": 904
          },
          {
            "text": "    if not hasattr(bpy.data, 'textures'):",
            "lineNumber": 905
          },
          {
            "text": "        return []",
            "lineNumber": 906
          },
          {
            "lineNumber": 907
          },
          {
            "text": "    users = []",
            "lineNumber": 908
          }
        ]
      },
      "score": 0.21452105045318604
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 454
          },
          "endPosition": {
            "line": 508
          }
        },
        "contents": "def material_node_groups(material_key):\n    # returns a list of keys indicating where the material is used via node groups\n    # This checks if the material is used in any node group, and if that node group\n    # is itself used anywhere. This is a fallback for cases where material_geometry_nodes()\n    # might miss usage (e.g., node groups used in materials, other node groups, etc.)\n\n                        if hasattr(node, 'node_tree') and node.node_tree:\n                            if node.node_tree.name == node_group.name:\n                                users.append(mat.name)\n                                break\n            \n            # Check if used in compositor (quick check)\n            from ..utils import compat\n            scene = bpy.context.scene\n            if scene.use_nodes:\n                node_tree = compat.get_scene_compositor_node_tree(scene)\n                if node_tree:\n                    for node in node_tree.nodes:\n                        if hasattr(node, 'node_tree') and node.node_tree:\n                            if node.node_tree.name == node_group.name:\n                                users.append(\"Compositor\")\n                                break\n            \n            # Check if used in other node groups (recursive check)\n            for other_ng in bpy.data.node_groups:\n                if other_ng.name == node_group.name:\n                    continue\n                for node in other_ng.nodes:\n                    if hasattr(node, 'node_tree') and node.node_tree:\n                        if node.node_tree.name == node_group.name:",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def material_node_groups(material_key):",
            "lineNumber": 455,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys indicating where the material is used via node groups",
            "lineNumber": 456,
            "isSignature": true
          },
          {
            "text": "    # This checks if the material is used in any node group, and if that node group",
            "lineNumber": 457,
            "isSignature": true
          },
          {
            "text": "    # is itself used anywhere. This is a fallback for cases where material_geometry_nodes()",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "    # might miss usage (e.g., node groups used in materials, other node groups, etc.)",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "lineNumber": 473
          },
          {
            "text": "                        if hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 474
          },
          {
            "text": "                            if node.node_tree.name == node_group.name:",
            "lineNumber": 475
          },
          {
            "text": "                                users.append(mat.name)",
            "lineNumber": 476
          },
          {
            "text": "                                break",
            "lineNumber": 477
          },
          {
            "text": "            ",
            "lineNumber": 478
          },
          {
            "text": "            # Check if used in compositor (quick check)",
            "lineNumber": 479
          },
          {
            "text": "            from ..utils import compat",
            "lineNumber": 480
          },
          {
            "text": "            scene = bpy.context.scene",
            "lineNumber": 481
          },
          {
            "text": "            if scene.use_nodes:",
            "lineNumber": 482
          },
          {
            "text": "                node_tree = compat.get_scene_compositor_node_tree(scene)",
            "lineNumber": 483
          },
          {
            "text": "                if node_tree:",
            "lineNumber": 484
          },
          {
            "text": "                    for node in node_tree.nodes:",
            "lineNumber": 485
          },
          {
            "text": "                        if hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 486
          },
          {
            "text": "                            if node.node_tree.name == node_group.name:",
            "lineNumber": 487
          },
          {
            "text": "                                users.append(\"Compositor\")",
            "lineNumber": 488
          },
          {
            "text": "                                break",
            "lineNumber": 489
          },
          {
            "text": "            ",
            "lineNumber": 490
          },
          {
            "text": "            # Check if used in other node groups (recursive check)",
            "lineNumber": 491
          },
          {
            "text": "            for other_ng in bpy.data.node_groups:",
            "lineNumber": 492
          },
          {
            "text": "                if other_ng.name == node_group.name:",
            "lineNumber": 493
          },
          {
            "text": "                    continue",
            "lineNumber": 494
          },
          {
            "text": "                for node in other_ng.nodes:",
            "lineNumber": 495
          },
          {
            "text": "                    if hasattr(node, 'node_tree') and node.node_tree:",
            "lineNumber": 496
          },
          {
            "text": "                        if node.node_tree.name == node_group.name:",
            "lineNumber": 497
          }
        ]
      },
      "score": 0.2135089635848999
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unused_parallel.py",
        "range": {
          "startPosition": {
            "line": 92
          },
          "endPosition": {
            "line": 117
          }
        },
        "contents": "def _has_any_unused_particles():\n\n    if not hasattr(bpy.data, 'particles'):\n        return False\n    \n    for particle in bpy.data.particles:\n        if compat.is_library_or_override(particle):\n            continue\n        if not users.particle_all(particle.name):\n            if not particle.use_fake_user or config.include_fake_users:\n                return True\n    return False\n\n\ndef _has_any_unused_textures():\n    \"\"\"Check if there are any unused textures (short-circuits early).\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _has_any_unused_particles():",
            "lineNumber": 93,
            "isSignature": true
          },
          {
            "lineNumber": 94
          },
          {
            "text": "    if not hasattr(bpy.data, 'particles'):",
            "lineNumber": 95
          },
          {
            "text": "        return False",
            "lineNumber": 96
          },
          {
            "text": "    ",
            "lineNumber": 97
          },
          {
            "text": "    for particle in bpy.data.particles:",
            "lineNumber": 98
          },
          {
            "text": "        if compat.is_library_or_override(particle):",
            "lineNumber": 99
          },
          {
            "text": "            continue",
            "lineNumber": 100
          },
          {
            "text": "        if not users.particle_all(particle.name):",
            "lineNumber": 101
          },
          {
            "text": "            if not particle.use_fake_user or config.include_fake_users:",
            "lineNumber": 102
          },
          {
            "text": "                return True",
            "lineNumber": 103
          },
          {
            "text": "    return False",
            "lineNumber": 104,
            "isSignature": true
          },
          {
            "lineNumber": 105
          },
          {
            "lineNumber": 106
          },
          {
            "text": "def _has_any_unused_textures():",
            "lineNumber": 107,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Check if there are any unused textures (short-circuits early).\"\"\"",
            "lineNumber": 108
          }
        ]
      },
      "score": 0.20740246772766113
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\users.py",
        "range": {
          "startPosition": {
            "line": 286,
            "column": 26
          },
          "endPosition": {
            "line": 346
          }
        },
        "contents": "def image_node_groups(image_key):\n    # returns a list of keys of node groups that use this image\n\n    users = []\n    image = bpy.data.images[image_key]\n\n    # for each node group\n    for node_group in bpy.data.node_groups:\n\n        # if node group contains our image\n        if node_group_has_image(node_group.name, image.name):\n            users.append(node_group.name)\n\n    return distinct(users)\n\n\ndef image_textures(image_key):\n    # returns a list of texture keys that use the image\n\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def image_node_groups(image_key):",
            "lineNumber": 290,
            "isSignature": true
          },
          {
            "text": "    # returns a list of keys of node groups that use this image",
            "lineNumber": 291,
            "isSignature": true
          },
          {
            "lineNumber": 292
          },
          {
            "text": "    users = []",
            "lineNumber": 293
          },
          {
            "text": "    image = bpy.data.images[image_key]",
            "lineNumber": 294
          },
          {
            "lineNumber": 295
          },
          {
            "text": "    # for each node group",
            "lineNumber": 296
          },
          {
            "text": "    for node_group in bpy.data.node_groups:",
            "lineNumber": 297
          },
          {
            "lineNumber": 298
          },
          {
            "text": "        # if node group contains our image",
            "lineNumber": 299
          },
          {
            "text": "        if node_group_has_image(node_group.name, image.name):",
            "lineNumber": 300
          },
          {
            "text": "            users.append(node_group.name)",
            "lineNumber": 301
          },
          {
            "lineNumber": 302
          },
          {
            "text": "    return distinct(users)",
            "lineNumber": 303,
            "isSignature": true
          },
          {
            "lineNumber": 304
          },
          {
            "lineNumber": 305
          },
          {
            "text": "def image_textures(image_key):",
            "lineNumber": 306,
            "isSignature": true
          },
          {
            "text": "    # returns a list of texture keys that use the image",
            "lineNumber": 307,
            "isSignature": true
          },
          {
            "lineNumber": 308
          },
          {
            "text": "    ",
            "lineNumber": 309
          }
        ]
      },
      "score": 0.20284180343151093
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": ".\\stats\\unnamed.py",
        "range": {
          "startPosition": {
            "line": 72,
            "column": 18
          },
          "endPosition": {
            "line": 174
          }
        },
        "contents": "def materials():\n    # returns the keys of all unnamed materials in the project\n    unnamed = []\n\n    for material in bpy.data.materials:\n        # Skip library-linked and override datablocks\n        if compat.is_library_or_override(material):\n            continue\n        if re.match(r'.*\\.\\d\\d\\d$', material.name) or \\\n                material.name.startswith(\"Material\"):\n            unnamed.append(material.name)\n\n    return unnamed\n\n\ndef objects():\n    # returns the keys of all unnamed materials in the project\n    # NOTE: lists of default names must be tuples!\n\n    # the default names all curve objects\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def materials():",
            "lineNumber": 76,
            "isSignature": true
          },
          {
            "text": "    # returns the keys of all unnamed materials in the project",
            "lineNumber": 77,
            "isSignature": true
          },
          {
            "text": "    unnamed = []",
            "lineNumber": 78
          },
          {
            "lineNumber": 79
          },
          {
            "text": "    for material in bpy.data.materials:",
            "lineNumber": 80
          },
          {
            "text": "        # Skip library-linked and override datablocks",
            "lineNumber": 81
          },
          {
            "text": "        if compat.is_library_or_override(material):",
            "lineNumber": 82
          },
          {
            "text": "            continue",
            "lineNumber": 83
          },
          {
            "text": "        if re.match(r'.*\\.\\d\\d\\d$', material.name) or \\",
            "lineNumber": 84
          },
          {
            "text": "                material.name.startswith(\"Material\"):",
            "lineNumber": 85
          },
          {
            "text": "            unnamed.append(material.name)",
            "lineNumber": 86
          },
          {
            "lineNumber": 87
          },
          {
            "text": "    return unnamed",
            "lineNumber": 88,
            "isSignature": true
          },
          {
            "lineNumber": 89
          },
          {
            "lineNumber": 90
          },
          {
            "text": "def objects():",
            "lineNumber": 91,
            "isSignature": true
          },
          {
            "text": "    # returns the keys of all unnamed materials in the project",
            "lineNumber": 92,
            "isSignature": true
          },
          {
            "text": "    # NOTE: lists of default names must be tuples!",
            "lineNumber": 93,
            "isSignature": true
          },
          {
            "lineNumber": 94,
            "isSignature": true
          },
          {
            "text": "    # the default names all curve objects",
            "lineNumber": 95,
            "isSignature": true
          },
          {
            "text": "    ",
            "lineNumber": 96
          }
        ]
      },
      "score": 0.19928550720214844
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


Checking `node_group_has_material()` to ensure it correctly detects "Set Material" nodes:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "Set Material|set_material|SET_MATERIAL",
  "caseInsensitive": true
}
```
Result:

```json
{
  "success": {
    "pattern": "Set Material|set_material|SET_MATERIAL",
    "outputMode": "content",
    "workspaceResults": {
      "e:\\atomic_data_manager": {
        "content": {
          "matches": [
            {
              "file": ".specstory/history/2025-12-16_23-24Z-blender-library-packed-files-error.md",
              "matches": [
                {
                  "lineNumber": 8855,
                  "content": "        \"contents\": \"def node_group_has_material(node_group_key, material_key):\\n    # returns true if a node group contains this material (directly or nested)\\n\\n    has_material = False\\n    node_group = bpy.data.node_groups[node_group_key]\\n    material = bpy.data.materials[material_key]\\n\\n    for node in node_group.nodes:\\n        # base case: nodes with a material property (e.g., Set Material)\\n        if hasattr(node, 'material') and node.material:\\n            if node.material.name == material.name:\\n                has_material = True\\n\\n        # recurse case: nested node groups\\n        elif hasattr(node, 'node_tree') and node.node_tree:\\n            has_material = node_group_has_material(\\n                node.node_tree.name, material.name)\\n\\n        if has_material:\\n            break\\n\\n    return has_material\\n\\n\\ndef particle_all(particle_key):\\n    # returns a list of keys of every data-block that uses this particle\\n    # system\\n\\n    \","
                },
                {
                  "lineNumber": 8891,
                  "content": "            \"text\": \"        # base case: nodes with a material property (e.g., Set Material)\","
                }
              ]
            },
            {
              "file": ".specstory/history/2025-12-18_18-37Z-blender-library-packed-files-error.md",
              "matches": [
                {
                  "lineNumber": 9514,
                  "content": "        \"contents\": \"def node_group_has_material(node_group_key, material_key):\\n    # returns true if a node group contains this material (directly or nested)\\n\\n    has_material = False\\n    node_group = bpy.data.node_groups[node_group_key]\\n    material = bpy.data.materials[material_key]\\n\\n    for node in node_group.nodes:\\n        # base case: nodes with a material property (e.g., Set Material)\\n        if hasattr(node, 'material') and node.material:\\n            if node.material.name == material.name:\\n                has_material = True\\n\\n        # recurse case: nested node groups\\n        elif hasattr(node, 'node_tree') and node.node_tree:\\n            has_material = node_group_has_material(\\n                node.node_tree.name, material.name)\\n\\n        if has_material:\\n            break\\n\\n    return has_material\\n\\n\\ndef particle_all(particle_key):\\n    # returns a list of keys of every data-block that uses this particle\\n    # system\\n\\n    \","
                },
                {
                  "lineNumber": 9550,
                  "content": "            \"text\": \"        # base case: nodes with a material property (e.g., Set Material)\","
                },
                {
                  "lineNumber": 17096,
                  "content": "material outline-highlight is being detected as not used, despite the fact it's used in a geonode group's 'set material' node."
                },
                {
                  "lineNumber": 17103,
                  "content": "The material is used via a Geometry Nodes \"Set Material\" node, but it's being flagged as unused. Checking how &#96;material_all()&#96; detects material usage:"
                },
                {
                  "lineNumber": 17192,
                  "content": "                  \"content\": \"        \\\"contents\\\": \\\"def node_group_has_material(node_group_key, material_key):\\\\n    # returns true if a node group contains this material (directly or nested)\\\\n\\\\n    has_material = False\\\\n    node_group = bpy.data.node_groups[node_group_key]\\\\n    material = bpy.data.materials[material_key]\\\\n\\\\n    for node in node_group.nodes:\\\\n        # base case: nodes with a material property (e.g., Set Material)\\\\n        if hasattr(node, 'material') and node.material:\\\\n            if node.material.name == material.name:\\\\n                has_material = True\\\\n\\\\n        # recurse case: nested node groups\\\\n        elif hasattr(node, 'node_tree') and node.node_tree:\\\\n            has_material = node_group_has_material(\\\\n                node.node_tree.name, material.name)\\\\n\\\\n        if has_material:\\\\n            break\\\\n\\\\n    return has_material\\\\n\\\\n\\\\ndef particle_all(particle_key):\\\\n    # returns a list of keys of every data-block that uses this par"
                }
              ]
            },
            {
              "file": "stats/users.py",
              "matches": [
                {
                  "lineNumber": 825,
                  "content": "        # base case: nodes with a material property (e.g., Set Material)"
                }
              ]
            },
            {
              "file": "stats\\users.py",
              "matches": [
                {
                  "lineNumber": 825,
                  "content": "        # base case: nodes with a material property (e.g., Set Material)"
                }
              ]
            }
          ],
          "totalLines": 9,
          "totalMatchedLines": 9
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---


Simplifying `material_node_groups()` and ensuring it correctly detects Geometry Nodes usage. The current implementation is too complex and may have bugs:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\stats\\users.py"
}
```
Additional data:

```json
{
  "codeblockId": "252fee6e-afbd-4bf7-95f7-793f6c1297ca"
}
```
Status: **completed**


</details>
</tool-use>

---


Simplifying further and ensuring it checks Geometry Nodes usage correctly, since that's the user's case:


---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\stats\\users.py"
}
```
Additional data:

```json
{
  "codeblockId": "e5ec5e38-ace8-4bd6-ad89-0d1522d44cc0"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "stats/users.py"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "stats/users.py"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


The performance issue: `material_node_groups()` is being called for every material and is expensive. Since `material_geometry_nodes()` should already catch Geometry Nodes usage, verifying it works and optimizing. Adding a test to confirm the material is detected:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\stats\users.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "def node_group_has_material",
  "contextAfter": 25,
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "def node_group_has_material",
    "outputMode": "content",
    "workspaceResults": {
      "e:\\atomic_data_manager": {
        "content": {
          "matches": [
            {
              "file": "stats\\users.py",
              "matches": [
                {
                  "lineNumber": 818,
                  "content": "def node_group_has_material(node_group_key, material_key):"
                },
                {
                  "lineNumber": 819,
                  "content": "    # returns true if a node group contains this material (directly or nested)",
                  "isContextLine": true
                },
                {
                  "lineNumber": 820,
                  "isContextLine": true
                },
                {
                  "lineNumber": 821,
                  "content": "    has_material = False",
                  "isContextLine": true
                },
                {
                  "lineNumber": 822,
                  "content": "    node_group = bpy.data.node_groups[node_group_key]",
                  "isContextLine": true
                },
                {
                  "lineNumber": 823,
                  "content": "    material = bpy.data.materials[material_key]",
                  "isContextLine": true
                },
                {
                  "lineNumber": 824,
                  "isContextLine": true
                },
                {
                  "lineNumber": 825,
                  "content": "    for node in node_group.nodes:",
                  "isContextLine": true
                },
                {
                  "lineNumber": 826,
                  "content": "        # base case: nodes with a material property (e.g., Set Material)",
                  "isContextLine": true
                },
                {
                  "lineNumber": 827,
                  "content": "        if hasattr(node, 'material') and node.material:",
                  "isContextLine": true
                },
                {
                  "lineNumber": 828,
                  "content": "            if node.material.name == material.name:",
                  "isContextLine": true
                },
                {
                  "lineNumber": 829,
                  "content": "                has_material = True",
                  "isContextLine": true
                },
                {
                  "lineNumber": 830,
                  "isContextLine": true
                },
                {
                  "lineNumber": 831,
                  "content": "        # recurse case: nested node groups",
                  "isContextLine": true
                },
                {
                  "lineNumber": 832,
                  "content": "        elif hasattr(node, 'node_tree') and node.node_tree:",
                  "isContextLine": true
                },
                {
                  "lineNumber": 833,
                  "content": "            has_material = node_group_has_material(",
                  "isContextLine": true
                },
                {
                  "lineNumber": 834,
                  "content": "                node.node_tree.name, material.name)",
                  "isContextLine": true
                },
                {
                  "lineNumber": 835,
                  "isContextLine": true
                },
                {
                  "lineNumber": 836,
                  "content": "        if has_material:",
                  "isContextLine": true
                },
                {
                  "lineNumber": 837,
                  "content": "            break",
                  "isContextLine": true
                },
                {
                  "lineNumber": 838,
                  "isContextLine": true
                },
                {
                  "lineNumber": 839,
                  "content": "    return has_material",
                  "isContextLine": true
                },
                {
                  "lineNumber": 840,
                  "isContextLine": true
                },
                {
                  "lineNumber": 841,
                  "isContextLine": true
                },
                {
                  "lineNumber": 842,
                  "content": "def particle_all(particle_key):",
                  "isContextLine": true
                },
                {
                  "lineNumber": 843,
                  "content": "    # returns a list of keys of every data-block that uses this particle",
                  "isContextLine": true
                }
              ]
            },
            {
              "file": "stats/users.py",
              "matches": [
                {
                  "lineNumber": 818,
                  "content": "def node_group_has_material(node_group_key, material_key):"
                },
                {
                  "lineNumber": 819,
                  "content": "    # returns true if a node group contains this material (directly or nested)",
                  "isContextLine": true
                },
                {
                  "lineNumber": 820,
                  "isContextLine": true
                },
                {
                  "lineNumber": 821,
                  "content": "    has_material = False",
                  "isContextLine": true
                },
                {
                  "lineNumber": 822,
                  "content": "    node_group = bpy.data.node_groups[node_group_key]",
                  "isContextLine": true
                },
                {
                  "lineNumber": 823,
                  "content": "    material = bpy.data.materials[material_key]",
                  "isContextLine": true
                },
                {
                  "lineNumber": 824,
                  "isContextLine": true
                },
                {
                  "lineNumber": 825,
                  "content": "    for node in node_group.nodes:",
                  "isContextLine": true
                },
                {
                  "lineNumber": 826,
                  "content": "        # base case: nodes with a material property (e.g., Set Material)",
                  "isContextLine": true
                },
                {
                  "lineNumber": 827,
                  "content": "        if hasattr(node, 'material') and node.material:",
                  "isContextLine": true
                },
                {
                  "lineNumber": 828,
                  "content": "            if node.material.name == material.name:",
                  "isContextLine": true
                },
                {
                  "lineNumber": 829,
                  "content": "                has_material = True",
                  "isContextLine": true
                },
                {
                  "lineNumber": 830,
                  "isContextLine": true
                },
                {
                  "lineNumber": 831,
                  "content": "        # recurse case: nested node groups",
                  "isContextLine": true
                },
                {
                  "lineNumber": 832,
                  "content": "        elif hasattr(node, 'node_tree') and node.node_tree:",
                  "isContextLine": true
                },
                {
                  "lineNumber": 833,
                  "content": "            has_material = node_group_has_material(",
                  "isContextLine": true
                },
                {
                  "lineNumber": 834,
                  "content": "                node.node_tree.name, material.name)",
                  "isContextLine": true
                },
                {
                  "lineNumber": 835,
                  "isContextLine": true
                },
                {
                  "lineNumber": 836,
                  "content": "        if has_material:",
                  "isContextLine": true
                },
                {
                  "lineNumber": 837,
                  "content": "            break",
                  "isContextLine": true
                },
                {
                  "lineNumber": 838,
                  "isContextLine": true
                },
                {
                  "lineNumber": 839,
                  "content": "    return has_material",
                  "isContextLine": true
                },
                {
                  "lineNumber": 840,
                  "isContextLine": true
                },
                {
                  "lineNumber": 841,
                  "isContextLine": true
                },
                {
                  "lineNumber": 842,
                  "content": "def particle_all(particle_key):",
                  "isContextLine": true
                },
                {
                  "lineNumber": 843,
                  "content": "    # returns a list of keys of every data-block that uses this particle",
                  "isContextLine": true
                }
              ]
            },
            {
              "file": ".specstory/history/2025-12-16_23-24Z-blender-library-packed-files-error.md",
              "matches": [
                {
                  "lineNumber": 8855,
                  "content": "        \"contents\": \"def node_group_has_material(node_group_key, material_key):\\n    # returns true if a node group contains this material (directly or nested)\\n\\n    has_material = False\\n    node_group = bpy.data.node_groups[node_group_key]\\n    material = bpy.data.materials[material_key]\\n\\n    for node in node_group.nodes:\\n        # base case: nodes with a material property (e.g., Set Material)\\n        if hasattr(node, 'material') and node.material:\\n            if node.material.name == material.name:\\n                has_material = True\\n\\n        # recurse case: nested node groups\\n        elif hasattr(node, 'node_tree') and node.node_tree:\\n            has_material = node_group_has_material(\\n                node.node_tree.name, material.name)\\n\\n        if has_material:\\n            break\\n\\n    return has_material\\n\\n\\ndef particle_all(particle_key):\\n    # returns a list of keys of every data-block that uses this particle\\n    # system\\n\\n    \","
                },
                {
                  "lineNumber": 8856,
                  "content": "        \"signatures\": {},",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8857,
                  "content": "        \"detailedLines\": [",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8858,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8859,
                  "content": "            \"text\": \"def node_group_has_material(node_group_key, material_key):\","
                },
                {
                  "lineNumber": 8860,
                  "content": "            \"lineNumber\": 759,",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8861,
                  "content": "            \"isSignature\": true",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8862,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8863,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8864,
                  "content": "            \"text\": \"    # returns true if a node group contains this material (directly or nested)\",",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8865,
                  "content": "            \"lineNumber\": 760,",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8866,
                  "content": "            \"isSignature\": true",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8867,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8868,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8869,
                  "content": "            \"lineNumber\": 761",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8870,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8871,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8872,
                  "content": "            \"text\": \"    has_material = False\",",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8873,
                  "content": "            \"lineNumber\": 762",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8874,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8875,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8876,
                  "content": "            \"text\": \"    node_group = bpy.data.node_groups[node_group_key]\",",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8877,
                  "content": "            \"lineNumber\": 763",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8878,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8879,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8880,
                  "content": "            \"text\": \"    material = bpy.data.materials[material_key]\",",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8881,
                  "content": "            \"lineNumber\": 764",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8882,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8883,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 8884,
                  "content": "            \"lineNumber\": 765",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11372,
                  "content": "        \"contents\": \"def node_group_has_texture(node_group_key, texture_key):\\n    # returns true if a node group contains this image\\n\\n    has_texture = False\\n    if not hasattr(bpy.data, 'textures'):\\n        return has_texture\\n    node_group = bpy.data.node_groups[node_group_key]\\n    texture = bpy.data.textures[texture_key]\\n\\n    # for each node in our search group\\n    for node in node_group.nodes:\\n\\n        # base case\\n        # if node has a not none image attribute\\n        if hasattr(node, 'texture') and node.texture:\\n\\n            # if the node group is our node group\\n            if node.texture.name == texture.name:\\n                has_texture = True\\n\\n        # recurse case\\n        # if node is a node group and has a valid node tree\\n        elif hasattr(node, 'node_tree') and node.node_tree:\\n            has_texture = node_group_has_texture(\\n                node.node_tree.name, texture.name)\\n\\n        # break the loop if the texture is found\\n        if has_te"
                },
                {
                  "lineNumber": 11373,
                  "content": "        \"signatures\": {},",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11374,
                  "content": "        \"detailedLines\": [",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11375,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11376,
                  "content": "            \"text\": \"def node_group_has_texture(node_group_key, texture_key):\",",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11377,
                  "content": "            \"lineNumber\": 726,",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11378,
                  "content": "            \"isSignature\": true",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11379,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11380,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11381,
                  "content": "            \"text\": \"    # returns true if a node group contains this image\",",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11382,
                  "content": "            \"lineNumber\": 727,",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11383,
                  "content": "            \"isSignature\": true",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11384,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11385,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11386,
                  "content": "            \"lineNumber\": 728",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11387,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11388,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11389,
                  "content": "            \"text\": \"    has_texture = False\",",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11390,
                  "content": "            \"lineNumber\": 729",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11391,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11392,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11393,
                  "content": "            \"text\": \"    if not hasattr(bpy.data, 'textures'):\",",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11394,
                  "content": "            \"lineNumber\": 730",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11395,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11396,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11397,
                  "content": "            \"text\": \"        return has_texture\",",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11502,
                  "content": "            \"text\": \"def node_group_has_material(node_group_key, material_key):\","
                },
                {
                  "lineNumber": 11503,
                  "content": "            \"lineNumber\": 759,",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11504,
                  "content": "            \"isSignature\": true",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11505,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11506,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11507,
                  "content": "            \"text\": \"    # returns true if a node group contains this material (directly or nested)\",",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11508,
                  "content": "            \"lineNumber\": 760,",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11509,
                  "content": "            \"isSignature\": true",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11510,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11511,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11512,
                  "content": "            \"lineNumber\": 761",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11513,
                  "content": "          },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11514,
                  "content": "          {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11515,
                  "content": "            \"text\": \"    \",",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11516,
                  "content": "            \"lineNumber\": 762",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11517,
                  "content": "          }",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11518,
                  "content": "        ]",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11519,
                  "content": "      },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11520,
                  "content": "      \"score\": 0.11521659791469574",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11521,
                  "content": "    },",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11522,
                  "content": "    {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11523,
                  "content": "      \"codeBlock\": {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11524,
                  "content": "        \"relativeWorkspacePath\": \".\\\\rainys_repo_bootstrap.py\",",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11525,
                  "content": "        \"range\": {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11526,
                  "content": "          \"startPosition\": {",
                  "isContextLine": true
                },
                {
                  "lineNumber": 11527,
                  "content": "            \"line\": 14",
                  "isContextLine": true
                }
              ]
            }
          ],
          "totalLines": 134,
          "totalMatchedLines": 6
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---


The `material_node_groups()` function is too slow. Optimizing it to return early and avoid expensive calls:


---

<tool-use data-tool-type="unknown" data-tool-name="edit_file_v2">
<details>
<summary>Tool use: **edit_file_v2**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "E:\\atomic_data_manager\\stats\\users.py"
}
```
Additional data:

```json
{
  "codeblockId": "1cea139b-620c-451c-af1e-f1e60bbd4162"
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "stats/users.py"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "stats/users.py"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


Optimized `material_node_groups()` to return early when usage is found, which should improve performance. The function now:

1. Checks Geometry Nodes usage first (most common case)
2. Returns immediately when usage is found (no need to check all contexts)
3. Only does recursive checks if needed

This should:
- Fix the detection: materials used in node groups (including "Set Material" nodes) should now be detected
- Improve performance: early returns avoid expensive recursive checks

The material "outline-highlight" should now be correctly detected as used since it's in the "box-highlight" node group, which is used by objects.

For the 30-second performance issue, the early returns should help, but the underlying `unused.materials_deep()` still checks every material. The optimizations should reduce that time.

Test it and let me know if the material is now correctly detected and if performance improved.

---

_**User**_

note that I removed the remington creative copyright from unused_parallel, because that code is not theirs.

---

_**Agent (model default, mode Agent)**_


Correct: `unused_parallel.py` is new code, so it shouldn't carry the Remington Creative copyright. Removing the copyright header is appropriate.

The file now only contains the necessary imports and functions without the copyright notice, which is fine for new code.

Is the material detection working correctly now? The `material_node_groups()` function should detect materials used in node groups (including "Set Material" nodes), and the early returns should improve performance.

---

_**User**_

the last commit by the remington guy was 0eda0a88eb7261720cee3353a33b99725e99d81d, were there any other source code elements that we created new that weren't supposed to have the remington copyright notice, but do?

---

_**Agent (model default, mode Agent)**_


Searching for files with the Remington Creative copyright notice to identify any that shouldn't have it:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "Copyright \\(C\\) 2019 Remington Creative|Remington Creative",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "Copyright \\(C\\) 2019 Remington Creative|Remington Creative",
    "outputMode": "content",
    "workspaceResults": {
      "e:\\atomic_data_manager": {
        "content": {
          "matches": [
            {
              "file": "ops/direct_use_ops.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "__init__.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": ".specstory/history/2025-12-16_23-24Z-blender-library-packed-files-error.md",
              "matches": [
                {
                  "lineNumber": 1409,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains functions that detect missing files in the Blender\\nproject.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nimport os\\n\\n\\ndef get_missing(data):\\n    # returns a list of keys of unpacked data-blocks with non-existent\\n    # fi"
                },
                {
                  "lineNumber": 1417,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 1661,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis module provides version detection and comparison utilities for\\nmulti-version Blender support (4.2 LTS, 4.5 LTS, and 5.0).\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\n\\n# Version constants\\nVERSION_4_2_LTS = (4, 2, 0)\\nVERSION_4_5_LTS = ("
                },
                {
                  "lineNumber": 1669,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 2362,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains operations for missing file handling. This includes\\nthe option to reload, remove, replace, and search for these missing files.\\n\\nIt also contains the post-reload report dialog that appears after\\nattempt"
                },
                {
                  "lineNumber": 2370,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 2888,
                  "content": "        \"contents\": \"# Changelog\\n\\nAll notable changes to this project will be documented in this file.\\n\\n## [v2.0.0] - Raincloud's first re-release\\n\\n### Feature\\n- Multi-version Blender support (4.2 LTS, 4.5 LTS, and 5.0)\\n    - Version detection utilities in &amp;#96;utils/version.py&amp;#96;\\n    - API compatibility layer in &amp;#96;utils/compat.py&amp;#96; for handling version differences\\n\\n### Fixes\\n- Blender 5.0 compatibility: Fixed &amp;#96;AttributeError&amp;#96; when accessing scene compositor node tree (changed from &amp;#96;scene.node_tree&amp;#96; to &amp;#96;scene.compositing_node_tree&amp;#96;)\\n- Collections assigned to &amp;#96;rigidbody_world.collection&amp;#96; are now correctly detected as used\\n\\n### Internal\\n- GitHub Actions release workflow\\n- Integrated &amp;#96;rainys_repo_bootstrap&amp;#96; into &amp;#96;__init__.py&amp;#96; so the Rainy's Extensions repository is registered on add-on enable and the bootstrap guard resets on disable.\\n- Removed \\\"Support Remington Creative\\\" popup and all related functionality\\n    "
                },
                {
                  "lineNumber": 2959,
                  "content": "            \"text\": \"- Removed \\\"Support Remington Creative\\\" popup and all related functionality\","
                },
                {
                  "lineNumber": 2979,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis module provides API compatibility functions for handling differences\\nbetween Blender 4.2 LTS, 4.5 LTS, and 5.0.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nfrom bpy.utils import register_class, unregister_class\\nfrom . import version\\n\\n"
                },
                {
                  "lineNumber": 2987,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 3417,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains miscellaneous statistics functions.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nimport os\\n\\n\\ndef blend_size():\\n    # returns the size of the current Blender file as a string\\n\\n    filepath = bpy.data.filepath\\n    size_b"
                },
                {
                  "lineNumber": 3425,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 8042,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains functions that detect data-blocks that have no users,\\nas determined by stats.users.py\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nfrom .. import config\\nfrom . import users\\n\\n\\ndef shallow(data):\\n    # returns a list of k"
                },
                {
                  "lineNumber": 8050,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 8255,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains functions for duplicating data-blocks from Atomic's\\ninspection interface.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\n\\n\\ndef duplicate_data(data, key):\\n    # creates a copy of the specified data-block and returns its key\\"
                },
                {
                  "lineNumber": 8263,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 8987,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains functions for deleting individual data-blocks from\\nAtomic's inspection inteface.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\n\\n\\ndef delete_datablock(data, key):\\n    # deletes a specific data-block from a set of data\\n    "
                },
                {
                  "lineNumber": 8995,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 9142,
                  "content": "        \"contents\": \"## [v2.0.1] - 2025-12-16\\n\\n### Fixes\\n- Blender 5.0 compatibility: Fixed &amp;#96;AttributeError&amp;#96; when detecting missing library files (Library objects use &amp;#96;packed_file&amp;#96; singular, Image objects use &amp;#96;packed_files&amp;#96; plural in 5.0)\\n- Fixed unregistration errors in Blender 4.5 by using safe unregister functions throughout the codebase\\n\\n## [v2.0.0] - Raincloud's first re-release\\n\\n### Feature\\n- Multi-version Blender support (4.2 LTS, 4.5 LTS, and 5.0)\\n    - Version detection utilities in &amp;#96;utils/version.py&amp;#96;\\n    - API compatibility layer in &amp;#96;utils/compat.py&amp;#96; for handling version differences\\n\\n### Fixes\\n- Blender 5.0 compatibility: Fixed &amp;#96;AttributeError&amp;#96; when accessing scene compositor node tree (changed from &amp;#96;scene.node_tree&amp;#96; to &amp;#96;scene.compositing_node_tree&amp;#96;)\\n- Collections assigned to &amp;#96;rigidbody_world.collection&amp;#96; are now correctly detected as used\\n\\n### Internal\\n- GitHub Actions release workflow\\n"
                },
                {
                  "lineNumber": 9221,
                  "content": "            \"text\": \"- Removed \\\"Support Remington Creative\\\" popup and all related functionality\","
                },
                {
                  "lineNumber": 10066,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains the Atomic preferences UI, preferences properties, and\\nsome functions for syncing the preference properties with external factors.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nfrom bpy.utils import register_class\\nfrom ..uti"
                },
                {
                  "lineNumber": 10074,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 10270,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis module provides version detection and comparison utilities for\\nmulti-version Blender support (4.2 LTS, 4.5 LTS, and 5.0).\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\n\\n# Version constants\\nVERSION_4_2_LTS = (4, 2, 0)\\nVERSION_4_5_LTS = ("
                },
                {
                  "lineNumber": 10278,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 10948,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains functions that return the keys of data-blocks that\\nuse other data-blocks.\\n\\nThey are titled as such that the first part of the function name is the\\ntype of the data being passed in and the second part o"
                },
                {
                  "lineNumber": 10956,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 11162,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis module provides API compatibility functions for handling differences\\nbetween Blender 4.2 LTS, 4.5 LTS, and 5.0.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nfrom bpy.utils import register_class, unregister_class\\nfrom . import version\\n\\n"
                },
                {
                  "lineNumber": 11170,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 11819,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains operations for missing file handling. This includes\\nthe option to reload, remove, replace, and search for these missing files.\\n\\nIt also contains the post-reload report dialog that appears after\\nattempt"
                },
                {
                  "lineNumber": 11827,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 12182,
                  "content": "                  \"content\": \"        \\\"contents\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\nCopyright (C) 2019 Remington Creative\\\\n\\\\nThis file is part of Atomic Data Manager.\\\\n\\\\nAtomic Data Manager is free software: you can redistribute\\\\nit and/or modify it under the terms of the GNU General Public License\\\\nas published by the Free Software Foundation, either version 3 of the\\\\nLicense, or (at your option) any later version.\\\\n\\\\nAtomic Data Manager is distributed in the hope that it will\\\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\\\nGeneral Public License for more details.\\\\n\\\\nYou should have received a copy of the GNU General Public License along\\\\nwith Atomic Data Manager.  If not, see &amp;amp;lt;https://www.gnu.org/licenses/&amp;amp;gt;.\\\\n\\\\n---\\\\n\\\\nThis file contains functions that detect missing files in the Blender\\\\nproject.\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport bpy\\\\nimport os\\\\n\\\\n\\\\ndef get_missing(data):"
                },
                {
                  "lineNumber": 12190,
                  "content": "                  \"content\": \"        \\\"contents\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\nCopyright (C) 2019 Remington Creative\\\\n\\\\nThis file is part of Atomic Data Manager.\\\\n\\\\nAtomic Data Manager is free software: you can redistribute\\\\nit and/or modify it under the terms of the GNU General Public License\\\\nas published by the Free Software Foundation, either version 3 of the\\\\nLicense, or (at your option) any later version.\\\\n\\\\nAtomic Data Manager is distributed in the hope that it will\\\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\\\nGeneral Public License for more details.\\\\n\\\\nYou should have received a copy of the GNU General Public License along\\\\nwith Atomic Data Manager.  If not, see &amp;amp;lt;https://www.gnu.org/licenses/&amp;amp;gt;.\\\\n\\\\n---\\\\n\\\\nThis file contains operations for missing file handling. This includes\\\\nthe option to reload, remove, replace, and search for these missing files.\\\\n\\\\nIt a"
                },
                {
                  "lineNumber": 12372,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains functions that return the keys of data-blocks that\\nuse other data-blocks.\\n\\nThey are titled as such that the first part of the function name is the\\ntype of the data being passed in and the second part o"
                },
                {
                  "lineNumber": 12380,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 21773,
                  "content": "                  \"content\": \"        \\\"contents\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\nCopyright (C) 2019 Remington Creative\\\\n\\\\nThis file is part of Atomic Data Manager.\\\\n\\\\nAtomic Data Manager is free software: you can redistribute\\\\nit and/or modify it under the terms of the GNU General Public License\\\\nas published by the Free Software Foundation, either version 3 of the\\\\nLicense, or (at your option) any later version.\\\\n\\\\nAtomic Data Manager is distributed in the hope that it will\\\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\\\nGeneral Public License for more details.\\\\n\\\\nYou should have received a copy of the GNU General Public License along\\\\nwith Atomic Data Manager.  If not, see &amp;amp;lt;https://www.gnu.org/licenses/&amp;amp;gt;.\\\\n\\\\n---\\\\n\\\\nThis file contains the Atomic preferences UI, preferences properties, and\\\\nsome functions for syncing the preference properties with external factors.\\\\n\\\\n"
                },
                {
                  "lineNumber": 21781,
                  "content": "                  \"content\": \"        \\\"contents\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\nCopyright (C) 2019 Remington Creative\\\\n\\\\nThis file is part of Atomic Data Manager.\\\\n\\\\nAtomic Data Manager is free software: you can redistribute\\\\nit and/or modify it under the terms of the GNU General Public License\\\\nas published by the Free Software Foundation, either version 3 of the\\\\nLicense, or (at your option) any later version.\\\\n\\\\nAtomic Data Manager is distributed in the hope that it will\\\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\\\nGeneral Public License for more details.\\\\n\\\\nYou should have received a copy of the GNU General Public License along\\\\nwith Atomic Data Manager.  If not, see &amp;amp;lt;https://www.gnu.org/licenses/&amp;amp;gt;.\\\\n\\\\n---\\\\n\\\\nThis file contains operations for missing file handling. This includes\\\\nthe option to reload, remove, replace, and search for these missing files.\\\\n\\\\nIt a"
                }
              ]
            },
            {
              "file": "ui/inspect_ui.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "CHANGELOG.md",
              "matches": [
                {
                  "lineNumber": 31,
                  "content": "- Removed \"Support Remington Creative\" popup and all related functionality"
                }
              ]
            },
            {
              "file": "utils/version.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ops\\main_ops.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ui/support_me_ui.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                },
                {
                  "lineNumber": 22,
                  "content": "support Remington Creative popup."
                },
                {
                  "lineNumber": 97,
                  "content": "            text=\"Support Remington Creative\","
                }
              ]
            },
            {
              "file": "ops\\direct_use_ops.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "stats/missing.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "stats/unused.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ops/utils/clean.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ops/inspect_ops.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ops/main_ops.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ops/utils/duplicate.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ui/utils/ui_layouts.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "stats/misc.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ui/pie_menu_ui.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ops/missing_file_ops.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ui/__init__.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ops/utils/delete.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ops/utils/nuke.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ui/stats_panel_ui.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ui/main_panel_ui.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "stats\\users.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "config.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "stats/unnamed.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "utils/__init__.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "utils/compat.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "README.md",
              "matches": [
                {
                  "lineNumber": 46,
                  "content": "**Like the Add-on?** [Consider Supporting Remington Creative](https://remington.pro/support/)!"
                }
              ]
            },
            {
              "file": "ui/missing_file_ui.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "stats/users.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ui/preferences_ui.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": ".specstory/history/2025-12-18_18-37Z-blender-library-packed-files-error.md",
              "matches": [
                {
                  "lineNumber": 2532,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains the main operators found in the main panel of the\\nAtomic Data Manager interface. This includes nuke, clean, undo, and the\\nvarious selection operations.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nfrom bpy.utils import regi"
                },
                {
                  "lineNumber": 2540,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 4137,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains operations for missing file handling. This includes\\nthe option to reload, remove, replace, and search for these missing files.\\n\\nIt also contains the post-reload report dialog that appears after\\nattempt"
                },
                {
                  "lineNumber": 4145,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 6379,
                  "content": "        \"contents\": \"## [v2.0.3] - 2025-12-17\\n\\n### Fixes\\n- Fixed missing import error in missing file detection\\n\\n## [v2.0.2] - 2025-12-17\\n\\n### Fixes\\n- Atomic now completely ignores all library-linked and override datablocks across all operations, as originally intended.\\n\\n## [v2.0.1] - 2025-12-16\\n\\n### Fixes\\n- Blender 5.0 compatibility: Fixed &amp;#96;AttributeError&amp;#96; when detecting missing library files (Library objects use &amp;#96;packed_file&amp;#96; singular, Image objects use &amp;#96;packed_files&amp;#96; plural in 5.0)\\n- Fixed unregistration errors in Blender 4.5 by using safe unregister functions throughout the codebase\\n\\n## [v2.0.0] - Raincloud's first re-release\\n\\n### Feature\\n- Multi-version Blender support (4.2 LTS, 4.5 LTS, and 5.0)\\n    - Version detection utilities in &amp;#96;utils/version.py&amp;#96;\\n    - API compatibility layer in &amp;#96;utils/compat.py&amp;#96; for handling version differences\\n\\n### Fixes\\n- Blender 5.0 compatibility: Fixed &amp;#96;AttributeError&amp;#96; when accessing"
                },
                {
                  "lineNumber": 6494,
                  "content": "            \"text\": \"- Removed \\\"Support Remington Creative\\\" popup and all related functionality\","
                },
                {
                  "lineNumber": 7210,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains the direct use operators, intended to be used with\\nAtomic's pie menu interface. However, they can be implemented anywhere\\nif they need to be.\\n\\nThese operators basically wrap the functions from ops.util"
                },
                {
                  "lineNumber": 7218,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 7660,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains operations for missing file handling. This includes\\nthe option to reload, remove, replace, and search for these missing files.\\n\\nIt also contains the post-reload report dialog that appears after\\nattempt"
                },
                {
                  "lineNumber": 7668,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 7906,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file handles the registration of the atomic_data_manager.ops package\\n\\n\\\"\\\"\\\"\\n\\nfrom . import main_ops\\nfrom . import inspect_ops\\nfrom . import direct_use_ops\\nfrom . import missing_file_ops\\n\\n\\ndef register():\\n   "
                },
                {
                  "lineNumber": 7914,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 8355,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains the main operators found in the main panel of the\\nAtomic Data Manager interface. This includes nuke, clean, undo, and the\\nvarious selection operations.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nfrom bpy.utils import regi"
                },
                {
                  "lineNumber": 8363,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 8688,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file handles the registration of the atomic_data_manager.ui package\\n\\n\\\"\\\"\\\"\\n\\nfrom . import main_panel_ui\\nfrom . import stats_panel_ui\\nfrom . import inspect_ui\\nfrom . import missing_file_ui\\nfrom . import missing_"
                },
                {
                  "lineNumber": 8696,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 9350,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains Atomic's global properties and handles the\\nregistration for all packages within the add-on.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nfrom bpy.utils import register_class\\nfrom .utils import compat\\nfrom . import ops\\nfro"
                },
                {
                  "lineNumber": 9358,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 9862,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains global copies of Atomic's preferences so that they\\ncan be easily access throughout the add-on.\\n\\nNOTE:\\nChanging the values of these variables will NOT change the values in the\\nAtomic's preferences. If "
                },
                {
                  "lineNumber": 9870,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 10221,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains functions for duplicating data-blocks from Atomic's\\ninspection interface.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\n\\n\\ndef duplicate_data(data, key):\\n    # creates a copy of the specified data-block and returns its key\\"
                },
                {
                  "lineNumber": 10229,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 10472,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains functions that return the keys of data-blocks that\\nuse other data-blocks.\\n\\nThey are titled as such that the first part of the function name is the\\ntype of the data being passed in and the second part o"
                },
                {
                  "lineNumber": 10480,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 11782,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains parallelized versions of unused data detection functions.\\nUses threading with locks to safely access Blender's API from multiple threads.\\n\\n\\\"\\\"\\\"\\n\\nimport threading\\nfrom concurrent.futures import Thre"
                },
                {
                  "lineNumber": 11790,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 12211,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains functions that detect data-blocks that have no users,\\nas determined by stats.users.py\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nfrom .. import config\\nfrom ..utils import compat\\nfrom . import users\\n\\n\\ndef shallow(data)"
                },
                {
                  "lineNumber": 12219,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 14283,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains functions that detect data-blocks that have no users,\\nas determined by stats.users.py\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nfrom .. import config\\nfrom ..utils import compat\\nfrom . import users\\n\\n\\ndef shallow(data)"
                },
                {
                  "lineNumber": 14291,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 15233,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains functions that return the keys of data-blocks that\\nuse other data-blocks.\\n\\nThey are titled as such that the first part of the function name is the\\ntype of the data being passed in and the second part o"
                },
                {
                  "lineNumber": 15241,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 15563,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains functions that detect unnamed data-blocks in the\\nBlender project.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nimport re\\nfrom ..utils import compat\\n\\n\\ndef collections():\\n    # returns the keys of all unnamed collections "
                },
                {
                  "lineNumber": 15571,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 15902,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains optimized batched versions of unused data detection functions.\\nSince Blender's Python API is not thread-safe, we batch calls efficiently\\ninstead of using threading (which would serialize anyway due to lo"
                },
                {
                  "lineNumber": 15910,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 19179,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains functions for cleaning out specific data categories.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nfrom ...stats import unused\\n\\n\\ndef collections():\\n    # removes all unused collections from the project\\n    for collection_"
                },
                {
                  "lineNumber": 19187,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                },
                {
                  "lineNumber": 21063,
                  "content": "        \"contents\": \"\\\"\\\"\\\"\\nCopyright (C) 2019 Remington Creative\\n\\nThis file is part of Atomic Data Manager.\\n\\nAtomic Data Manager is free software: you can redistribute\\nit and/or modify it under the terms of the GNU General Public License\\nas published by the Free Software Foundation, either version 3 of the\\nLicense, or (at your option) any later version.\\n\\nAtomic Data Manager is distributed in the hope that it will\\nbe useful, but WITHOUT ANY WARRANTY; without even the implied warranty\\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\nGeneral Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License along\\nwith Atomic Data Manager.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;.\\n\\n---\\n\\nThis file contains the main operators found in the main panel of the\\nAtomic Data Manager interface. This includes nuke, clean, undo, and the\\nvarious selection operations.\\n\\n\\\"\\\"\\\"\\n\\nimport bpy\\nfrom bpy.utils import regi"
                },
                {
                  "lineNumber": 21071,
                  "content": "            \"text\": \"Copyright (C) 2019 Remington Creative\","
                }
              ]
            },
            {
              "file": "stats/count.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            },
            {
              "file": "ops/support_me_ops.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                },
                {
                  "lineNumber": 22,
                  "content": "This file contains the operator for opening the Remington Creative"
                },
                {
                  "lineNumber": 36,
                  "content": "    \"\"\"Opens the Remington Creative \\\"Support Me\\\" webpage\"\"\""
                }
              ]
            },
            {
              "file": "ops/__init__.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "Copyright (C) 2019 Remington Creative"
                }
              ]
            }
          ],
          "totalLines": 115,
          "totalMatchedLines": 115
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="list_dir_v2">
<details>
<summary>Tool use: **list_dir_v2**</summary>


Parameters:

```json
{
  "targetDirectory": "E:\\atomic_data_manager"
}
```
Result:

```json
{
  "directoryTreeRoot": {
    "absPath": "E:\\atomic_data_manager",
    "childrenDirs": [
      {
        "absPath": "E:\\atomic_data_manager\\.github",
        "childrenDirs": [
          {
            "absPath": "E:\\atomic_data_manager\\.github\\workflows",
            "childrenFiles": [
              {
                "name": "release.yml"
              }
            ],
            "childrenWereProcessed": true
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "E:\\atomic_data_manager\\.specstory",
        "childrenDirs": [
          {
            "absPath": "E:\\atomic_data_manager\\.specstory\\history",
            "childrenFiles": [
              {
                "name": "2025-10-09_00-08Z-update-blender-addon-for-version-4-5.md"
              },
              {
                "name": "2025-12-01_19-37Z-integrate-multi-blender-version-support.md"
              },
              {
                "name": "2025-12-01_20-15Z-blender-integration-error-troubleshooting.md"
              },
              {
                "name": "2025-12-01_20-46Z-setting-up-a-blender-extension-api.md"
              },
              {
                "name": "2025-12-16_23-24Z-blender-library-packed-files-error.md"
              },
              {
                "name": "2025-12-18_18-37Z-blender-library-packed-files-error.md"
              }
            ],
            "childrenWereProcessed": true
          }
        ],
        "childrenFiles": [
          {
            "name": ".gitignore"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "E:\\atomic_data_manager\\ops",
        "childrenDirs": [
          {
            "absPath": "E:\\atomic_data_manager\\ops\\utils",
            "childrenFiles": [
              {
                "name": "clean.py"
              },
              {
                "name": "delete.py"
              },
              {
                "name": "duplicate.py"
              },
              {
                "name": "nuke.py"
              }
            ],
            "childrenWereProcessed": true
          }
        ],
        "childrenFiles": [
          {
            "name": "__init__.py"
          },
          {
            "name": "direct_use_ops.py"
          },
          {
            "name": "inspect_ops.py"
          },
          {
            "name": "main_ops.py"
          },
          {
            "name": "missing_file_ops.py"
          },
          {
            "name": "support_me_ops.py"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "E:\\atomic_data_manager\\stats",
        "childrenFiles": [
          {
            "name": "count.py"
          },
          {
            "name": "misc.py"
          },
          {
            "name": "missing.py"
          },
          {
            "name": "unnamed.py"
          },
          {
            "name": "unused_parallel.py"
          },
          {
            "name": "unused.py"
          },
          {
            "name": "users.py"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "E:\\atomic_data_manager\\ui",
        "childrenDirs": [
          {
            "absPath": "E:\\atomic_data_manager\\ui\\utils",
            "childrenFiles": [
              {
                "name": "ui_layouts.py"
              }
            ],
            "childrenWereProcessed": true
          }
        ],
        "childrenFiles": [
          {
            "name": "__init__.py"
          },
          {
            "name": "inspect_ui.py"
          },
          {
            "name": "main_panel_ui.py"
          },
          {
            "name": "missing_file_ui.py"
          },
          {
            "name": "pie_menu_ui.py"
          },
          {
            "name": "preferences_ui.py"
          },
          {
            "name": "stats_panel_ui.py"
          },
          {
            "name": "support_me_ui.py"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "E:\\atomic_data_manager\\utils",
        "childrenFiles": [
          {
            "name": "__init__.py"
          },
          {
            "name": "compat.py"
          },
          {
            "name": "version.py"
          }
        ],
        "childrenWereProcessed": true
      }
    ],
    "childrenFiles": [
      {
        "name": "__init__.py"
      },
      {
        "name": ".cursorindexingignore"
      },
      {
        "name": ".gitignore"
      },
      {
        "name": "blender_manifest.toml"
      },
      {
        "name": "CHANGELOG.md"
      },
      {
        "name": "config.py"
      },
      {
        "name": "LICENSE.txt"
      },
      {
        "name": "rainys_repo_bootstrap.py"
      },
      {
        "name": "README.md"
      }
    ],
    "childrenWereProcessed": true
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: E:\atomic_data_manager\rainys_repo_bootstrap.py</summary>

</details>
</tool-use>

---

